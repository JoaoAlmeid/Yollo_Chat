
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Baileys
 * 
 */
export type Baileys = $Result.DefaultSelection<Prisma.$BaileysPayload>
/**
 * Model BaileysChats
 * 
 */
export type BaileysChats = $Result.DefaultSelection<Prisma.$BaileysChatsPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignSetting
 * 
 */
export type CampaignSetting = $Result.DefaultSelection<Prisma.$CampaignSettingPayload>
/**
 * Model CampaignShipping
 * 
 */
export type CampaignShipping = $Result.DefaultSelection<Prisma.$CampaignShippingPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model ChatUser
 * 
 */
export type ChatUser = $Result.DefaultSelection<Prisma.$ChatUserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ContactCustomField
 * 
 */
export type ContactCustomField = $Result.DefaultSelection<Prisma.$ContactCustomFieldPayload>
/**
 * Model ContactList
 * 
 */
export type ContactList = $Result.DefaultSelection<Prisma.$ContactListPayload>
/**
 * Model ContactListItem
 * 
 */
export type ContactListItem = $Result.DefaultSelection<Prisma.$ContactListItemPayload>
/**
 * Model Files
 * 
 */
export type Files = $Result.DefaultSelection<Prisma.$FilesPayload>
/**
 * Model FilesOptions
 * 
 */
export type FilesOptions = $Result.DefaultSelection<Prisma.$FilesOptionsPayload>
/**
 * Model Help
 * 
 */
export type Help = $Result.DefaultSelection<Prisma.$HelpPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model System_Logs
 * 
 */
export type System_Logs = $Result.DefaultSelection<Prisma.$System_LogsPayload>
/**
 * Model Action_Logs
 * 
 */
export type Action_Logs = $Result.DefaultSelection<Prisma.$Action_LogsPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Prompt
 * 
 */
export type Prompt = $Result.DefaultSelection<Prisma.$PromptPayload>
/**
 * Model Queue
 * 
 */
export type Queue = $Result.DefaultSelection<Prisma.$QueuePayload>
/**
 * Model QueueIntegrations
 * 
 */
export type QueueIntegrations = $Result.DefaultSelection<Prisma.$QueueIntegrationsPayload>
/**
 * Model QueueOption
 * 
 */
export type QueueOption = $Result.DefaultSelection<Prisma.$QueueOptionPayload>
/**
 * Model QuickMessage
 * 
 */
export type QuickMessage = $Result.DefaultSelection<Prisma.$QuickMessagePayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketNote
 * 
 */
export type TicketNote = $Result.DefaultSelection<Prisma.$TicketNotePayload>
/**
 * Model TicketTag
 * 
 */
export type TicketTag = $Result.DefaultSelection<Prisma.$TicketTagPayload>
/**
 * Model TicketTracking
 * 
 */
export type TicketTracking = $Result.DefaultSelection<Prisma.$TicketTrackingPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserQueue
 * 
 */
export type UserQueue = $Result.DefaultSelection<Prisma.$UserQueuePayload>
/**
 * Model UserRating
 * 
 */
export type UserRating = $Result.DefaultSelection<Prisma.$UserRatingPayload>
/**
 * Model Whatsapp
 * 
 */
export type Whatsapp = $Result.DefaultSelection<Prisma.$WhatsappPayload>
/**
 * Model WhatsappQueue
 * 
 */
export type WhatsappQueue = $Result.DefaultSelection<Prisma.$WhatsappQueuePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Announcements
 * const announcements = await prisma.announcement.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Announcements
   * const announcements = await prisma.announcement.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs>;

  /**
   * `prisma.baileys`: Exposes CRUD operations for the **Baileys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Baileys
    * const baileys = await prisma.baileys.findMany()
    * ```
    */
  get baileys(): Prisma.BaileysDelegate<ExtArgs>;

  /**
   * `prisma.baileysChats`: Exposes CRUD operations for the **BaileysChats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaileysChats
    * const baileysChats = await prisma.baileysChats.findMany()
    * ```
    */
  get baileysChats(): Prisma.BaileysChatsDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignSetting`: Exposes CRUD operations for the **CampaignSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignSettings
    * const campaignSettings = await prisma.campaignSetting.findMany()
    * ```
    */
  get campaignSetting(): Prisma.CampaignSettingDelegate<ExtArgs>;

  /**
   * `prisma.campaignShipping`: Exposes CRUD operations for the **CampaignShipping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignShippings
    * const campaignShippings = await prisma.campaignShipping.findMany()
    * ```
    */
  get campaignShipping(): Prisma.CampaignShippingDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs>;

  /**
   * `prisma.chatUser`: Exposes CRUD operations for the **ChatUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatUsers
    * const chatUsers = await prisma.chatUser.findMany()
    * ```
    */
  get chatUser(): Prisma.ChatUserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.contactCustomField`: Exposes CRUD operations for the **ContactCustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactCustomFields
    * const contactCustomFields = await prisma.contactCustomField.findMany()
    * ```
    */
  get contactCustomField(): Prisma.ContactCustomFieldDelegate<ExtArgs>;

  /**
   * `prisma.contactList`: Exposes CRUD operations for the **ContactList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactLists
    * const contactLists = await prisma.contactList.findMany()
    * ```
    */
  get contactList(): Prisma.ContactListDelegate<ExtArgs>;

  /**
   * `prisma.contactListItem`: Exposes CRUD operations for the **ContactListItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactListItems
    * const contactListItems = await prisma.contactListItem.findMany()
    * ```
    */
  get contactListItem(): Prisma.ContactListItemDelegate<ExtArgs>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **Files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.FilesDelegate<ExtArgs>;

  /**
   * `prisma.filesOptions`: Exposes CRUD operations for the **FilesOptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilesOptions
    * const filesOptions = await prisma.filesOptions.findMany()
    * ```
    */
  get filesOptions(): Prisma.FilesOptionsDelegate<ExtArgs>;

  /**
   * `prisma.help`: Exposes CRUD operations for the **Help** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Helps
    * const helps = await prisma.help.findMany()
    * ```
    */
  get help(): Prisma.HelpDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.system_Logs`: Exposes CRUD operations for the **System_Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more System_Logs
    * const system_Logs = await prisma.system_Logs.findMany()
    * ```
    */
  get system_Logs(): Prisma.System_LogsDelegate<ExtArgs>;

  /**
   * `prisma.action_Logs`: Exposes CRUD operations for the **Action_Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Action_Logs
    * const action_Logs = await prisma.action_Logs.findMany()
    * ```
    */
  get action_Logs(): Prisma.Action_LogsDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.prompt`: Exposes CRUD operations for the **Prompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prompts
    * const prompts = await prisma.prompt.findMany()
    * ```
    */
  get prompt(): Prisma.PromptDelegate<ExtArgs>;

  /**
   * `prisma.queue`: Exposes CRUD operations for the **Queue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queues
    * const queues = await prisma.queue.findMany()
    * ```
    */
  get queue(): Prisma.QueueDelegate<ExtArgs>;

  /**
   * `prisma.queueIntegrations`: Exposes CRUD operations for the **QueueIntegrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueIntegrations
    * const queueIntegrations = await prisma.queueIntegrations.findMany()
    * ```
    */
  get queueIntegrations(): Prisma.QueueIntegrationsDelegate<ExtArgs>;

  /**
   * `prisma.queueOption`: Exposes CRUD operations for the **QueueOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueOptions
    * const queueOptions = await prisma.queueOption.findMany()
    * ```
    */
  get queueOption(): Prisma.QueueOptionDelegate<ExtArgs>;

  /**
   * `prisma.quickMessage`: Exposes CRUD operations for the **QuickMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuickMessages
    * const quickMessages = await prisma.quickMessage.findMany()
    * ```
    */
  get quickMessage(): Prisma.QuickMessageDelegate<ExtArgs>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketNote`: Exposes CRUD operations for the **TicketNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketNotes
    * const ticketNotes = await prisma.ticketNote.findMany()
    * ```
    */
  get ticketNote(): Prisma.TicketNoteDelegate<ExtArgs>;

  /**
   * `prisma.ticketTag`: Exposes CRUD operations for the **TicketTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketTags
    * const ticketTags = await prisma.ticketTag.findMany()
    * ```
    */
  get ticketTag(): Prisma.TicketTagDelegate<ExtArgs>;

  /**
   * `prisma.ticketTracking`: Exposes CRUD operations for the **TicketTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketTrackings
    * const ticketTrackings = await prisma.ticketTracking.findMany()
    * ```
    */
  get ticketTracking(): Prisma.TicketTrackingDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userQueue`: Exposes CRUD operations for the **UserQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQueues
    * const userQueues = await prisma.userQueue.findMany()
    * ```
    */
  get userQueue(): Prisma.UserQueueDelegate<ExtArgs>;

  /**
   * `prisma.userRating`: Exposes CRUD operations for the **UserRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRatings
    * const userRatings = await prisma.userRating.findMany()
    * ```
    */
  get userRating(): Prisma.UserRatingDelegate<ExtArgs>;

  /**
   * `prisma.whatsapp`: Exposes CRUD operations for the **Whatsapp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsapps
    * const whatsapps = await prisma.whatsapp.findMany()
    * ```
    */
  get whatsapp(): Prisma.WhatsappDelegate<ExtArgs>;

  /**
   * `prisma.whatsappQueue`: Exposes CRUD operations for the **WhatsappQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsappQueues
    * const whatsappQueues = await prisma.whatsappQueue.findMany()
    * ```
    */
  get whatsappQueue(): Prisma.WhatsappQueueDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Announcement: 'Announcement',
    Baileys: 'Baileys',
    BaileysChats: 'BaileysChats',
    Campaign: 'Campaign',
    CampaignSetting: 'CampaignSetting',
    CampaignShipping: 'CampaignShipping',
    Chat: 'Chat',
    ChatMessage: 'ChatMessage',
    ChatUser: 'ChatUser',
    Company: 'Company',
    Contact: 'Contact',
    ContactCustomField: 'ContactCustomField',
    ContactList: 'ContactList',
    ContactListItem: 'ContactListItem',
    Files: 'Files',
    FilesOptions: 'FilesOptions',
    Help: 'Help',
    Invoice: 'Invoice',
    System_Logs: 'System_Logs',
    Action_Logs: 'Action_Logs',
    Message: 'Message',
    Plan: 'Plan',
    Prompt: 'Prompt',
    Queue: 'Queue',
    QueueIntegrations: 'QueueIntegrations',
    QueueOption: 'QueueOption',
    QuickMessage: 'QuickMessage',
    Rating: 'Rating',
    Schedule: 'Schedule',
    Setting: 'Setting',
    Subscription: 'Subscription',
    Tag: 'Tag',
    Ticket: 'Ticket',
    TicketNote: 'TicketNote',
    TicketTag: 'TicketTag',
    TicketTracking: 'TicketTracking',
    User: 'User',
    UserQueue: 'UserQueue',
    UserRating: 'UserRating',
    Whatsapp: 'Whatsapp',
    WhatsappQueue: 'WhatsappQueue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "announcement" | "baileys" | "baileysChats" | "campaign" | "campaignSetting" | "campaignShipping" | "chat" | "chatMessage" | "chatUser" | "company" | "contact" | "contactCustomField" | "contactList" | "contactListItem" | "files" | "filesOptions" | "help" | "invoice" | "system_Logs" | "action_Logs" | "message" | "plan" | "prompt" | "queue" | "queueIntegrations" | "queueOption" | "quickMessage" | "rating" | "schedule" | "setting" | "subscription" | "tag" | "ticket" | "ticketNote" | "ticketTag" | "ticketTracking" | "user" | "userQueue" | "userRating" | "whatsapp" | "whatsappQueue"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Baileys: {
        payload: Prisma.$BaileysPayload<ExtArgs>
        fields: Prisma.BaileysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaileysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaileysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>
          }
          findFirst: {
            args: Prisma.BaileysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaileysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>
          }
          findMany: {
            args: Prisma.BaileysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>[]
          }
          create: {
            args: Prisma.BaileysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>
          }
          createMany: {
            args: Prisma.BaileysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BaileysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>
          }
          update: {
            args: Prisma.BaileysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>
          }
          deleteMany: {
            args: Prisma.BaileysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaileysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BaileysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysPayload>
          }
          aggregate: {
            args: Prisma.BaileysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaileys>
          }
          groupBy: {
            args: Prisma.BaileysGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaileysGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaileysCountArgs<ExtArgs>
            result: $Utils.Optional<BaileysCountAggregateOutputType> | number
          }
        }
      }
      BaileysChats: {
        payload: Prisma.$BaileysChatsPayload<ExtArgs>
        fields: Prisma.BaileysChatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BaileysChatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BaileysChatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>
          }
          findFirst: {
            args: Prisma.BaileysChatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BaileysChatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>
          }
          findMany: {
            args: Prisma.BaileysChatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>[]
          }
          create: {
            args: Prisma.BaileysChatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>
          }
          createMany: {
            args: Prisma.BaileysChatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BaileysChatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>
          }
          update: {
            args: Prisma.BaileysChatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>
          }
          deleteMany: {
            args: Prisma.BaileysChatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BaileysChatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BaileysChatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BaileysChatsPayload>
          }
          aggregate: {
            args: Prisma.BaileysChatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaileysChats>
          }
          groupBy: {
            args: Prisma.BaileysChatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BaileysChatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BaileysChatsCountArgs<ExtArgs>
            result: $Utils.Optional<BaileysChatsCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignSetting: {
        payload: Prisma.$CampaignSettingPayload<ExtArgs>
        fields: Prisma.CampaignSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>
          }
          findFirst: {
            args: Prisma.CampaignSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>
          }
          findMany: {
            args: Prisma.CampaignSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>[]
          }
          create: {
            args: Prisma.CampaignSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>
          }
          createMany: {
            args: Prisma.CampaignSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CampaignSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>
          }
          update: {
            args: Prisma.CampaignSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>
          }
          deleteMany: {
            args: Prisma.CampaignSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSettingPayload>
          }
          aggregate: {
            args: Prisma.CampaignSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignSetting>
          }
          groupBy: {
            args: Prisma.CampaignSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignSettingCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignSettingCountAggregateOutputType> | number
          }
        }
      }
      CampaignShipping: {
        payload: Prisma.$CampaignShippingPayload<ExtArgs>
        fields: Prisma.CampaignShippingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignShippingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignShippingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>
          }
          findFirst: {
            args: Prisma.CampaignShippingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignShippingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>
          }
          findMany: {
            args: Prisma.CampaignShippingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>[]
          }
          create: {
            args: Prisma.CampaignShippingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>
          }
          createMany: {
            args: Prisma.CampaignShippingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CampaignShippingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>
          }
          update: {
            args: Prisma.CampaignShippingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>
          }
          deleteMany: {
            args: Prisma.CampaignShippingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignShippingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignShippingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignShippingPayload>
          }
          aggregate: {
            args: Prisma.CampaignShippingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignShipping>
          }
          groupBy: {
            args: Prisma.CampaignShippingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignShippingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignShippingCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignShippingCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      ChatUser: {
        payload: Prisma.$ChatUserPayload<ExtArgs>
        fields: Prisma.ChatUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>
          }
          findFirst: {
            args: Prisma.ChatUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>
          }
          findMany: {
            args: Prisma.ChatUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>[]
          }
          create: {
            args: Prisma.ChatUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>
          }
          createMany: {
            args: Prisma.ChatUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>
          }
          update: {
            args: Prisma.ChatUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>
          }
          deleteMany: {
            args: Prisma.ChatUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatUserPayload>
          }
          aggregate: {
            args: Prisma.ChatUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatUser>
          }
          groupBy: {
            args: Prisma.ChatUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatUserCountArgs<ExtArgs>
            result: $Utils.Optional<ChatUserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ContactCustomField: {
        payload: Prisma.$ContactCustomFieldPayload<ExtArgs>
        fields: Prisma.ContactCustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactCustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactCustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>
          }
          findFirst: {
            args: Prisma.ContactCustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactCustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>
          }
          findMany: {
            args: Prisma.ContactCustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>[]
          }
          create: {
            args: Prisma.ContactCustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>
          }
          createMany: {
            args: Prisma.ContactCustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactCustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>
          }
          update: {
            args: Prisma.ContactCustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.ContactCustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactCustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactCustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCustomFieldPayload>
          }
          aggregate: {
            args: Prisma.ContactCustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactCustomField>
          }
          groupBy: {
            args: Prisma.ContactCustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactCustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCustomFieldCountAggregateOutputType> | number
          }
        }
      }
      ContactList: {
        payload: Prisma.$ContactListPayload<ExtArgs>
        fields: Prisma.ContactListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>
          }
          findFirst: {
            args: Prisma.ContactListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>
          }
          findMany: {
            args: Prisma.ContactListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>[]
          }
          create: {
            args: Prisma.ContactListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>
          }
          createMany: {
            args: Prisma.ContactListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>
          }
          update: {
            args: Prisma.ContactListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>
          }
          deleteMany: {
            args: Prisma.ContactListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListPayload>
          }
          aggregate: {
            args: Prisma.ContactListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactList>
          }
          groupBy: {
            args: Prisma.ContactListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactListCountArgs<ExtArgs>
            result: $Utils.Optional<ContactListCountAggregateOutputType> | number
          }
        }
      }
      ContactListItem: {
        payload: Prisma.$ContactListItemPayload<ExtArgs>
        fields: Prisma.ContactListItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactListItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactListItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>
          }
          findFirst: {
            args: Prisma.ContactListItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactListItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>
          }
          findMany: {
            args: Prisma.ContactListItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>[]
          }
          create: {
            args: Prisma.ContactListItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>
          }
          createMany: {
            args: Prisma.ContactListItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactListItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>
          }
          update: {
            args: Prisma.ContactListItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>
          }
          deleteMany: {
            args: Prisma.ContactListItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactListItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactListItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactListItemPayload>
          }
          aggregate: {
            args: Prisma.ContactListItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactListItem>
          }
          groupBy: {
            args: Prisma.ContactListItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactListItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactListItemCountArgs<ExtArgs>
            result: $Utils.Optional<ContactListItemCountAggregateOutputType> | number
          }
        }
      }
      Files: {
        payload: Prisma.$FilesPayload<ExtArgs>
        fields: Prisma.FilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          findFirst: {
            args: Prisma.FilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          findMany: {
            args: Prisma.FilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>[]
          }
          create: {
            args: Prisma.FilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          createMany: {
            args: Prisma.FilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          update: {
            args: Prisma.FilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          deleteMany: {
            args: Prisma.FilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesPayload>
          }
          aggregate: {
            args: Prisma.FilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiles>
          }
          groupBy: {
            args: Prisma.FilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilesCountArgs<ExtArgs>
            result: $Utils.Optional<FilesCountAggregateOutputType> | number
          }
        }
      }
      FilesOptions: {
        payload: Prisma.$FilesOptionsPayload<ExtArgs>
        fields: Prisma.FilesOptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilesOptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilesOptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>
          }
          findFirst: {
            args: Prisma.FilesOptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilesOptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>
          }
          findMany: {
            args: Prisma.FilesOptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>[]
          }
          create: {
            args: Prisma.FilesOptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>
          }
          createMany: {
            args: Prisma.FilesOptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FilesOptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>
          }
          update: {
            args: Prisma.FilesOptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>
          }
          deleteMany: {
            args: Prisma.FilesOptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilesOptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FilesOptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilesOptionsPayload>
          }
          aggregate: {
            args: Prisma.FilesOptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilesOptions>
          }
          groupBy: {
            args: Prisma.FilesOptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilesOptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilesOptionsCountArgs<ExtArgs>
            result: $Utils.Optional<FilesOptionsCountAggregateOutputType> | number
          }
        }
      }
      Help: {
        payload: Prisma.$HelpPayload<ExtArgs>
        fields: Prisma.HelpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          findFirst: {
            args: Prisma.HelpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          findMany: {
            args: Prisma.HelpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>[]
          }
          create: {
            args: Prisma.HelpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          createMany: {
            args: Prisma.HelpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HelpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          update: {
            args: Prisma.HelpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          deleteMany: {
            args: Prisma.HelpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpPayload>
          }
          aggregate: {
            args: Prisma.HelpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelp>
          }
          groupBy: {
            args: Prisma.HelpGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      System_Logs: {
        payload: Prisma.$System_LogsPayload<ExtArgs>
        fields: Prisma.System_LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.System_LogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.System_LogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>
          }
          findFirst: {
            args: Prisma.System_LogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.System_LogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>
          }
          findMany: {
            args: Prisma.System_LogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>[]
          }
          create: {
            args: Prisma.System_LogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>
          }
          createMany: {
            args: Prisma.System_LogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.System_LogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>
          }
          update: {
            args: Prisma.System_LogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>
          }
          deleteMany: {
            args: Prisma.System_LogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.System_LogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.System_LogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$System_LogsPayload>
          }
          aggregate: {
            args: Prisma.System_LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystem_Logs>
          }
          groupBy: {
            args: Prisma.System_LogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<System_LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.System_LogsCountArgs<ExtArgs>
            result: $Utils.Optional<System_LogsCountAggregateOutputType> | number
          }
        }
      }
      Action_Logs: {
        payload: Prisma.$Action_LogsPayload<ExtArgs>
        fields: Prisma.Action_LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Action_LogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Action_LogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>
          }
          findFirst: {
            args: Prisma.Action_LogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Action_LogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>
          }
          findMany: {
            args: Prisma.Action_LogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>[]
          }
          create: {
            args: Prisma.Action_LogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>
          }
          createMany: {
            args: Prisma.Action_LogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Action_LogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>
          }
          update: {
            args: Prisma.Action_LogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>
          }
          deleteMany: {
            args: Prisma.Action_LogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Action_LogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Action_LogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Action_LogsPayload>
          }
          aggregate: {
            args: Prisma.Action_LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction_Logs>
          }
          groupBy: {
            args: Prisma.Action_LogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Action_LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Action_LogsCountArgs<ExtArgs>
            result: $Utils.Optional<Action_LogsCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Prompt: {
        payload: Prisma.$PromptPayload<ExtArgs>
        fields: Prisma.PromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findFirst: {
            args: Prisma.PromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findMany: {
            args: Prisma.PromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          create: {
            args: Prisma.PromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          createMany: {
            args: Prisma.PromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          update: {
            args: Prisma.PromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          deleteMany: {
            args: Prisma.PromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          aggregate: {
            args: Prisma.PromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrompt>
          }
          groupBy: {
            args: Prisma.PromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptCountArgs<ExtArgs>
            result: $Utils.Optional<PromptCountAggregateOutputType> | number
          }
        }
      }
      Queue: {
        payload: Prisma.$QueuePayload<ExtArgs>
        fields: Prisma.QueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          findFirst: {
            args: Prisma.QueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          findMany: {
            args: Prisma.QueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          create: {
            args: Prisma.QueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          createMany: {
            args: Prisma.QueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          update: {
            args: Prisma.QueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          deleteMany: {
            args: Prisma.QueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          aggregate: {
            args: Prisma.QueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueue>
          }
          groupBy: {
            args: Prisma.QueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueCountArgs<ExtArgs>
            result: $Utils.Optional<QueueCountAggregateOutputType> | number
          }
        }
      }
      QueueIntegrations: {
        payload: Prisma.$QueueIntegrationsPayload<ExtArgs>
        fields: Prisma.QueueIntegrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueIntegrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueIntegrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>
          }
          findFirst: {
            args: Prisma.QueueIntegrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueIntegrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>
          }
          findMany: {
            args: Prisma.QueueIntegrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>[]
          }
          create: {
            args: Prisma.QueueIntegrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>
          }
          createMany: {
            args: Prisma.QueueIntegrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QueueIntegrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>
          }
          update: {
            args: Prisma.QueueIntegrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>
          }
          deleteMany: {
            args: Prisma.QueueIntegrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueIntegrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QueueIntegrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueIntegrationsPayload>
          }
          aggregate: {
            args: Prisma.QueueIntegrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueIntegrations>
          }
          groupBy: {
            args: Prisma.QueueIntegrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueIntegrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueIntegrationsCountArgs<ExtArgs>
            result: $Utils.Optional<QueueIntegrationsCountAggregateOutputType> | number
          }
        }
      }
      QueueOption: {
        payload: Prisma.$QueueOptionPayload<ExtArgs>
        fields: Prisma.QueueOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>
          }
          findFirst: {
            args: Prisma.QueueOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>
          }
          findMany: {
            args: Prisma.QueueOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>[]
          }
          create: {
            args: Prisma.QueueOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>
          }
          createMany: {
            args: Prisma.QueueOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QueueOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>
          }
          update: {
            args: Prisma.QueueOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>
          }
          deleteMany: {
            args: Prisma.QueueOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QueueOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueOptionPayload>
          }
          aggregate: {
            args: Prisma.QueueOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueOption>
          }
          groupBy: {
            args: Prisma.QueueOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueOptionCountArgs<ExtArgs>
            result: $Utils.Optional<QueueOptionCountAggregateOutputType> | number
          }
        }
      }
      QuickMessage: {
        payload: Prisma.$QuickMessagePayload<ExtArgs>
        fields: Prisma.QuickMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuickMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuickMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>
          }
          findFirst: {
            args: Prisma.QuickMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuickMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>
          }
          findMany: {
            args: Prisma.QuickMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>[]
          }
          create: {
            args: Prisma.QuickMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>
          }
          createMany: {
            args: Prisma.QuickMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuickMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>
          }
          update: {
            args: Prisma.QuickMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>
          }
          deleteMany: {
            args: Prisma.QuickMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuickMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuickMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuickMessagePayload>
          }
          aggregate: {
            args: Prisma.QuickMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuickMessage>
          }
          groupBy: {
            args: Prisma.QuickMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuickMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuickMessageCountArgs<ExtArgs>
            result: $Utils.Optional<QuickMessageCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketNote: {
        payload: Prisma.$TicketNotePayload<ExtArgs>
        fields: Prisma.TicketNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          findFirst: {
            args: Prisma.TicketNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          findMany: {
            args: Prisma.TicketNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>[]
          }
          create: {
            args: Prisma.TicketNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          createMany: {
            args: Prisma.TicketNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          update: {
            args: Prisma.TicketNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          deleteMany: {
            args: Prisma.TicketNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          aggregate: {
            args: Prisma.TicketNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketNote>
          }
          groupBy: {
            args: Prisma.TicketNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketNoteCountArgs<ExtArgs>
            result: $Utils.Optional<TicketNoteCountAggregateOutputType> | number
          }
        }
      }
      TicketTag: {
        payload: Prisma.$TicketTagPayload<ExtArgs>
        fields: Prisma.TicketTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          findFirst: {
            args: Prisma.TicketTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          findMany: {
            args: Prisma.TicketTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>[]
          }
          create: {
            args: Prisma.TicketTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          createMany: {
            args: Prisma.TicketTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          update: {
            args: Prisma.TicketTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          deleteMany: {
            args: Prisma.TicketTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTagPayload>
          }
          aggregate: {
            args: Prisma.TicketTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketTag>
          }
          groupBy: {
            args: Prisma.TicketTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketTagCountArgs<ExtArgs>
            result: $Utils.Optional<TicketTagCountAggregateOutputType> | number
          }
        }
      }
      TicketTracking: {
        payload: Prisma.$TicketTrackingPayload<ExtArgs>
        fields: Prisma.TicketTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>
          }
          findFirst: {
            args: Prisma.TicketTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>
          }
          findMany: {
            args: Prisma.TicketTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>[]
          }
          create: {
            args: Prisma.TicketTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>
          }
          createMany: {
            args: Prisma.TicketTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>
          }
          update: {
            args: Prisma.TicketTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>
          }
          deleteMany: {
            args: Prisma.TicketTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTrackingPayload>
          }
          aggregate: {
            args: Prisma.TicketTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketTracking>
          }
          groupBy: {
            args: Prisma.TicketTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<TicketTrackingCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserQueue: {
        payload: Prisma.$UserQueuePayload<ExtArgs>
        fields: Prisma.UserQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          findFirst: {
            args: Prisma.UserQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          findMany: {
            args: Prisma.UserQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>[]
          }
          create: {
            args: Prisma.UserQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          createMany: {
            args: Prisma.UserQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          update: {
            args: Prisma.UserQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          deleteMany: {
            args: Prisma.UserQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQueuePayload>
          }
          aggregate: {
            args: Prisma.UserQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQueue>
          }
          groupBy: {
            args: Prisma.UserQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQueueCountArgs<ExtArgs>
            result: $Utils.Optional<UserQueueCountAggregateOutputType> | number
          }
        }
      }
      UserRating: {
        payload: Prisma.$UserRatingPayload<ExtArgs>
        fields: Prisma.UserRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          findFirst: {
            args: Prisma.UserRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          findMany: {
            args: Prisma.UserRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>[]
          }
          create: {
            args: Prisma.UserRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          createMany: {
            args: Prisma.UserRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          update: {
            args: Prisma.UserRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          deleteMany: {
            args: Prisma.UserRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRatingPayload>
          }
          aggregate: {
            args: Prisma.UserRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRating>
          }
          groupBy: {
            args: Prisma.UserRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRatingCountArgs<ExtArgs>
            result: $Utils.Optional<UserRatingCountAggregateOutputType> | number
          }
        }
      }
      Whatsapp: {
        payload: Prisma.$WhatsappPayload<ExtArgs>
        fields: Prisma.WhatsappFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>
          }
          findFirst: {
            args: Prisma.WhatsappFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>
          }
          findMany: {
            args: Prisma.WhatsappFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>[]
          }
          create: {
            args: Prisma.WhatsappCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>
          }
          createMany: {
            args: Prisma.WhatsappCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WhatsappDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>
          }
          update: {
            args: Prisma.WhatsappUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>
          }
          deleteMany: {
            args: Prisma.WhatsappDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhatsappUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappPayload>
          }
          aggregate: {
            args: Prisma.WhatsappAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsapp>
          }
          groupBy: {
            args: Prisma.WhatsappGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappCountAggregateOutputType> | number
          }
        }
      }
      WhatsappQueue: {
        payload: Prisma.$WhatsappQueuePayload<ExtArgs>
        fields: Prisma.WhatsappQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>
          }
          findFirst: {
            args: Prisma.WhatsappQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>
          }
          findMany: {
            args: Prisma.WhatsappQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>[]
          }
          create: {
            args: Prisma.WhatsappQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>
          }
          createMany: {
            args: Prisma.WhatsappQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WhatsappQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>
          }
          update: {
            args: Prisma.WhatsappQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>
          }
          deleteMany: {
            args: Prisma.WhatsappQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhatsappQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappQueuePayload>
          }
          aggregate: {
            args: Prisma.WhatsappQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsappQueue>
          }
          groupBy: {
            args: Prisma.WhatsappQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappQueueCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappQueueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    shipping: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipping?: boolean | CampaignCountOutputTypeCountShippingArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignShippingWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    users: number
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ChatCountOutputTypeCountUsersArgs
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatUserWhereInput
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    schedules: number
    users: number
    userRatings: number
    queues: number
    whatsapps: number
    messages: number
    contacts: number
    settings: number
    tags: number
    tickets: number
    ticketTrackings: number
    subscriptions: number
    quickMessages: number
    queueIntegrationss: number
    prompts: number
    filess: number
    contactListItems: number
    contactLists: number
    chats: number
    campaignSettings: number
    campaigns: number
    announcements: number
    queue: number
    ratings: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | CompanyCountOutputTypeCountSchedulesArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    userRatings?: boolean | CompanyCountOutputTypeCountUserRatingsArgs
    queues?: boolean | CompanyCountOutputTypeCountQueuesArgs
    whatsapps?: boolean | CompanyCountOutputTypeCountWhatsappsArgs
    messages?: boolean | CompanyCountOutputTypeCountMessagesArgs
    contacts?: boolean | CompanyCountOutputTypeCountContactsArgs
    settings?: boolean | CompanyCountOutputTypeCountSettingsArgs
    tags?: boolean | CompanyCountOutputTypeCountTagsArgs
    tickets?: boolean | CompanyCountOutputTypeCountTicketsArgs
    ticketTrackings?: boolean | CompanyCountOutputTypeCountTicketTrackingsArgs
    subscriptions?: boolean | CompanyCountOutputTypeCountSubscriptionsArgs
    quickMessages?: boolean | CompanyCountOutputTypeCountQuickMessagesArgs
    queueIntegrationss?: boolean | CompanyCountOutputTypeCountQueueIntegrationssArgs
    prompts?: boolean | CompanyCountOutputTypeCountPromptsArgs
    filess?: boolean | CompanyCountOutputTypeCountFilessArgs
    contactListItems?: boolean | CompanyCountOutputTypeCountContactListItemsArgs
    contactLists?: boolean | CompanyCountOutputTypeCountContactListsArgs
    chats?: boolean | CompanyCountOutputTypeCountChatsArgs
    campaignSettings?: boolean | CompanyCountOutputTypeCountCampaignSettingsArgs
    campaigns?: boolean | CompanyCountOutputTypeCountCampaignsArgs
    announcements?: boolean | CompanyCountOutputTypeCountAnnouncementsArgs
    queue?: boolean | CompanyCountOutputTypeCountQueueArgs
    ratings?: boolean | CompanyCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUserRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRatingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWhatsappsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTicketTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTrackingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountQuickMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickMessageWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountQueueIntegrationssArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueIntegrationsWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFilessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContactListItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactListItemWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContactListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactListWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCampaignSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignSettingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    tickets: number
    extraInfo: number
    schedules: number
    TicketNote: number
    Message: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | ContactCountOutputTypeCountTicketsArgs
    extraInfo?: boolean | ContactCountOutputTypeCountExtraInfoArgs
    schedules?: boolean | ContactCountOutputTypeCountSchedulesArgs
    TicketNote?: boolean | ContactCountOutputTypeCountTicketNoteArgs
    Message?: boolean | ContactCountOutputTypeCountMessageArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountExtraInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactCustomFieldWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type ContactListCountOutputType
   */

  export type ContactListCountOutputType = {
    items: number
    Campaign: number
  }

  export type ContactListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ContactListCountOutputTypeCountItemsArgs
    Campaign?: boolean | ContactListCountOutputTypeCountCampaignArgs
  }

  // Custom InputTypes
  /**
   * ContactListCountOutputType without action
   */
  export type ContactListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListCountOutputType
     */
    select?: ContactListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactListCountOutputType without action
   */
  export type ContactListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactListItemWhereInput
  }

  /**
   * ContactListCountOutputType without action
   */
  export type ContactListCountOutputTypeCountCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type ContactListItemCountOutputType
   */

  export type ContactListItemCountOutputType = {
    CampaignShipping: number
  }

  export type ContactListItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CampaignShipping?: boolean | ContactListItemCountOutputTypeCountCampaignShippingArgs
  }

  // Custom InputTypes
  /**
   * ContactListItemCountOutputType without action
   */
  export type ContactListItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItemCountOutputType
     */
    select?: ContactListItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactListItemCountOutputType without action
   */
  export type ContactListItemCountOutputTypeCountCampaignShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignShippingWhereInput
  }


  /**
   * Count Type FilesCountOutputType
   */

  export type FilesCountOutputType = {
    options: number
    Campaign: number
  }

  export type FilesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | FilesCountOutputTypeCountOptionsArgs
    Campaign?: boolean | FilesCountOutputTypeCountCampaignArgs
  }

  // Custom InputTypes
  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesCountOutputType
     */
    select?: FilesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesOptionsWhereInput
  }

  /**
   * FilesCountOutputType without action
   */
  export type FilesCountOutputTypeCountCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type Action_LogsCountOutputType
   */

  export type Action_LogsCountOutputType = {
    System_Logs: number
  }

  export type Action_LogsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    System_Logs?: boolean | Action_LogsCountOutputTypeCountSystem_LogsArgs
  }

  // Custom InputTypes
  /**
   * Action_LogsCountOutputType without action
   */
  export type Action_LogsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_LogsCountOutputType
     */
    select?: Action_LogsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Action_LogsCountOutputType without action
   */
  export type Action_LogsCountOutputTypeCountSystem_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: System_LogsWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    Message: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Message?: boolean | MessageCountOutputTypeCountMessageArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    Company: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | PlanCountOutputTypeCountCompanyArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }


  /**
   * Count Type PromptCountOutputType
   */

  export type PromptCountOutputType = {
    Whatsapp: number
    Ticket: number
  }

  export type PromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Whatsapp?: boolean | PromptCountOutputTypeCountWhatsappArgs
    Ticket?: boolean | PromptCountOutputTypeCountTicketArgs
  }

  // Custom InputTypes
  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCountOutputType
     */
    select?: PromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountWhatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type QueueCountOutputType
   */

  export type QueueCountOutputType = {
    whatsapps: number
    users: number
    options: number
    prompt: number
    UserQueue: number
    WhatsappQueue: number
    Ticket: number
    Message: number
    Company: number
  }

  export type QueueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsapps?: boolean | QueueCountOutputTypeCountWhatsappsArgs
    users?: boolean | QueueCountOutputTypeCountUsersArgs
    options?: boolean | QueueCountOutputTypeCountOptionsArgs
    prompt?: boolean | QueueCountOutputTypeCountPromptArgs
    UserQueue?: boolean | QueueCountOutputTypeCountUserQueueArgs
    WhatsappQueue?: boolean | QueueCountOutputTypeCountWhatsappQueueArgs
    Ticket?: boolean | QueueCountOutputTypeCountTicketArgs
    Message?: boolean | QueueCountOutputTypeCountMessageArgs
    Company?: boolean | QueueCountOutputTypeCountCompanyArgs
  }

  // Custom InputTypes
  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueCountOutputType
     */
    select?: QueueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountWhatsappsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueOptionWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountPromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountUserQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQueueWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountWhatsappQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappQueueWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }


  /**
   * Count Type QueueIntegrationsCountOutputType
   */

  export type QueueIntegrationsCountOutputType = {
    Ticket: number
    Queue: number
  }

  export type QueueIntegrationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | QueueIntegrationsCountOutputTypeCountTicketArgs
    Queue?: boolean | QueueIntegrationsCountOutputTypeCountQueueArgs
  }

  // Custom InputTypes
  /**
   * QueueIntegrationsCountOutputType without action
   */
  export type QueueIntegrationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrationsCountOutputType
     */
    select?: QueueIntegrationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueueIntegrationsCountOutputType without action
   */
  export type QueueIntegrationsCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * QueueIntegrationsCountOutputType without action
   */
  export type QueueIntegrationsCountOutputTypeCountQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
  }


  /**
   * Count Type QueueOptionCountOutputType
   */

  export type QueueOptionCountOutputType = {
    Ticket: number
    QueueOption: number
  }

  export type QueueOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ticket?: boolean | QueueOptionCountOutputTypeCountTicketArgs
    QueueOption?: boolean | QueueOptionCountOutputTypeCountQueueOptionArgs
  }

  // Custom InputTypes
  /**
   * QueueOptionCountOutputType without action
   */
  export type QueueOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOptionCountOutputType
     */
    select?: QueueOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueueOptionCountOutputType without action
   */
  export type QueueOptionCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * QueueOptionCountOutputType without action
   */
  export type QueueOptionCountOutputTypeCountQueueOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueOptionWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    ticketTags: number
    tickets: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticketTags?: boolean | TagCountOutputTypeCountTicketTagsArgs
    tickets?: boolean | TagCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTicketTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    messages: number
    ticketTags: number
    tags: number
    UserRating: number
    TicketTracking: number
    TicketNote: number
    Schedule: number
    Action_Logs: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | TicketCountOutputTypeCountMessagesArgs
    ticketTags?: boolean | TicketCountOutputTypeCountTicketTagsArgs
    tags?: boolean | TicketCountOutputTypeCountTagsArgs
    UserRating?: boolean | TicketCountOutputTypeCountUserRatingArgs
    TicketTracking?: boolean | TicketCountOutputTypeCountTicketTrackingArgs
    TicketNote?: boolean | TicketCountOutputTypeCountTicketNoteArgs
    Schedule?: boolean | TicketCountOutputTypeCountScheduleArgs
    Action_Logs?: boolean | TicketCountOutputTypeCountAction_LogsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicketTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountUserRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRatingWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTrackingWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountTicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountAction_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Action_LogsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tickets: number
    queues: number
    quickMessages: number
    ChatUsers: number
    UserQueue: number
    UserRating: number
    TicketTracking: number
    TicketNote: number
    Schedule: number
    ChatMessage: number
    Chat: number
    Action_Logs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    queues?: boolean | UserCountOutputTypeCountQueuesArgs
    quickMessages?: boolean | UserCountOutputTypeCountQuickMessagesArgs
    ChatUsers?: boolean | UserCountOutputTypeCountChatUsersArgs
    UserQueue?: boolean | UserCountOutputTypeCountUserQueueArgs
    UserRating?: boolean | UserCountOutputTypeCountUserRatingArgs
    TicketTracking?: boolean | UserCountOutputTypeCountTicketTrackingArgs
    TicketNote?: boolean | UserCountOutputTypeCountTicketNoteArgs
    Schedule?: boolean | UserCountOutputTypeCountScheduleArgs
    ChatMessage?: boolean | UserCountOutputTypeCountChatMessageArgs
    Chat?: boolean | UserCountOutputTypeCountChatArgs
    Action_Logs?: boolean | UserCountOutputTypeCountAction_LogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuickMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQueueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAction_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Action_LogsWhereInput
  }


  /**
   * Count Type WhatsappCountOutputType
   */

  export type WhatsappCountOutputType = {
    tickets: number
    queues: number
    whatsappQueues: number
    User: number
    TicketTracking: number
    Contact: number
    Campaign: number
    BaileysChats: number
    Baileys: number
  }

  export type WhatsappCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | WhatsappCountOutputTypeCountTicketsArgs
    queues?: boolean | WhatsappCountOutputTypeCountQueuesArgs
    whatsappQueues?: boolean | WhatsappCountOutputTypeCountWhatsappQueuesArgs
    User?: boolean | WhatsappCountOutputTypeCountUserArgs
    TicketTracking?: boolean | WhatsappCountOutputTypeCountTicketTrackingArgs
    Contact?: boolean | WhatsappCountOutputTypeCountContactArgs
    Campaign?: boolean | WhatsappCountOutputTypeCountCampaignArgs
    BaileysChats?: boolean | WhatsappCountOutputTypeCountBaileysChatsArgs
    Baileys?: boolean | WhatsappCountOutputTypeCountBaileysArgs
  }

  // Custom InputTypes
  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappCountOutputType
     */
    select?: WhatsappCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountWhatsappQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappQueueWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountTicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTrackingWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountBaileysChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaileysChatsWhereInput
  }

  /**
   * WhatsappCountOutputType without action
   */
  export type WhatsappCountOutputTypeCountBaileysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaileysWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementAvgAggregateOutputType = {
    id: number | null
    priority: number | null
    companyId: number | null
  }

  export type AnnouncementSumAggregateOutputType = {
    id: number | null
    priority: number | null
    companyId: number | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: number | null
    priority: number | null
    title: string | null
    text: string | null
    mediaPath: string | null
    mediaName: string | null
    companyId: number | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: number | null
    priority: number | null
    title: string | null
    text: string | null
    mediaPath: string | null
    mediaName: string | null
    companyId: number | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    priority: number
    title: number
    text: number
    mediaPath: number
    mediaName: number
    companyId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementAvgAggregateInputType = {
    id?: true
    priority?: true
    companyId?: true
  }

  export type AnnouncementSumAggregateInputType = {
    id?: true
    priority?: true
    companyId?: true
  }

  export type AnnouncementMinAggregateInputType = {
    id?: true
    priority?: true
    title?: true
    text?: true
    mediaPath?: true
    mediaName?: true
    companyId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    priority?: true
    title?: true
    text?: true
    mediaPath?: true
    mediaName?: true
    companyId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    priority?: true
    title?: true
    text?: true
    mediaPath?: true
    mediaName?: true
    companyId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _avg?: AnnouncementAvgAggregateInputType
    _sum?: AnnouncementSumAggregateInputType
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: number
    priority: number
    title: string
    text: string
    mediaPath: string | null
    mediaName: string | null
    companyId: number
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priority?: boolean
    title?: boolean
    text?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    companyId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>


  export type AnnouncementSelectScalar = {
    id?: boolean
    priority?: boolean
    title?: boolean
    text?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    companyId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      priority: number
      title: string
      text: string
      mediaPath: string | null
      mediaName: string | null
      companyId: number
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */ 
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'Int'>
    readonly priority: FieldRef<"Announcement", 'Int'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly text: FieldRef<"Announcement", 'String'>
    readonly mediaPath: FieldRef<"Announcement", 'String'>
    readonly mediaName: FieldRef<"Announcement", 'String'>
    readonly companyId: FieldRef<"Announcement", 'Int'>
    readonly status: FieldRef<"Announcement", 'Boolean'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model Baileys
   */

  export type AggregateBaileys = {
    _count: BaileysCountAggregateOutputType | null
    _avg: BaileysAvgAggregateOutputType | null
    _sum: BaileysSumAggregateOutputType | null
    _min: BaileysMinAggregateOutputType | null
    _max: BaileysMaxAggregateOutputType | null
  }

  export type BaileysAvgAggregateOutputType = {
    id: number | null
    whatsappId: number | null
  }

  export type BaileysSumAggregateOutputType = {
    id: number | null
    whatsappId: number | null
  }

  export type BaileysMinAggregateOutputType = {
    id: number | null
    contacts: string | null
    chats: string | null
    createdAt: Date | null
    updatedAt: Date | null
    whatsappId: number | null
  }

  export type BaileysMaxAggregateOutputType = {
    id: number | null
    contacts: string | null
    chats: string | null
    createdAt: Date | null
    updatedAt: Date | null
    whatsappId: number | null
  }

  export type BaileysCountAggregateOutputType = {
    id: number
    contacts: number
    chats: number
    createdAt: number
    updatedAt: number
    whatsappId: number
    _all: number
  }


  export type BaileysAvgAggregateInputType = {
    id?: true
    whatsappId?: true
  }

  export type BaileysSumAggregateInputType = {
    id?: true
    whatsappId?: true
  }

  export type BaileysMinAggregateInputType = {
    id?: true
    contacts?: true
    chats?: true
    createdAt?: true
    updatedAt?: true
    whatsappId?: true
  }

  export type BaileysMaxAggregateInputType = {
    id?: true
    contacts?: true
    chats?: true
    createdAt?: true
    updatedAt?: true
    whatsappId?: true
  }

  export type BaileysCountAggregateInputType = {
    id?: true
    contacts?: true
    chats?: true
    createdAt?: true
    updatedAt?: true
    whatsappId?: true
    _all?: true
  }

  export type BaileysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Baileys to aggregate.
     */
    where?: BaileysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baileys to fetch.
     */
    orderBy?: BaileysOrderByWithRelationInput | BaileysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaileysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baileys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baileys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Baileys
    **/
    _count?: true | BaileysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaileysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaileysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaileysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaileysMaxAggregateInputType
  }

  export type GetBaileysAggregateType<T extends BaileysAggregateArgs> = {
        [P in keyof T & keyof AggregateBaileys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaileys[P]>
      : GetScalarType<T[P], AggregateBaileys[P]>
  }




  export type BaileysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaileysWhereInput
    orderBy?: BaileysOrderByWithAggregationInput | BaileysOrderByWithAggregationInput[]
    by: BaileysScalarFieldEnum[] | BaileysScalarFieldEnum
    having?: BaileysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaileysCountAggregateInputType | true
    _avg?: BaileysAvgAggregateInputType
    _sum?: BaileysSumAggregateInputType
    _min?: BaileysMinAggregateInputType
    _max?: BaileysMaxAggregateInputType
  }

  export type BaileysGroupByOutputType = {
    id: number
    contacts: string | null
    chats: string | null
    createdAt: Date
    updatedAt: Date
    whatsappId: number
    _count: BaileysCountAggregateOutputType | null
    _avg: BaileysAvgAggregateOutputType | null
    _sum: BaileysSumAggregateOutputType | null
    _min: BaileysMinAggregateOutputType | null
    _max: BaileysMaxAggregateOutputType | null
  }

  type GetBaileysGroupByPayload<T extends BaileysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaileysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaileysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaileysGroupByOutputType[P]>
            : GetScalarType<T[P], BaileysGroupByOutputType[P]>
        }
      >
    >


  export type BaileysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contacts?: boolean
    chats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsappId?: boolean
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["baileys"]>


  export type BaileysSelectScalar = {
    id?: boolean
    contacts?: boolean
    chats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsappId?: boolean
  }

  export type BaileysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
  }

  export type $BaileysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Baileys"
    objects: {
      whatsapp: Prisma.$WhatsappPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contacts: string | null
      chats: string | null
      createdAt: Date
      updatedAt: Date
      whatsappId: number
    }, ExtArgs["result"]["baileys"]>
    composites: {}
  }

  type BaileysGetPayload<S extends boolean | null | undefined | BaileysDefaultArgs> = $Result.GetResult<Prisma.$BaileysPayload, S>

  type BaileysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BaileysFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: BaileysCountAggregateInputType | true
    }

  export interface BaileysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Baileys'], meta: { name: 'Baileys' } }
    /**
     * Find zero or one Baileys that matches the filter.
     * @param {BaileysFindUniqueArgs} args - Arguments to find a Baileys
     * @example
     * // Get one Baileys
     * const baileys = await prisma.baileys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaileysFindUniqueArgs>(args: SelectSubset<T, BaileysFindUniqueArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Baileys that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BaileysFindUniqueOrThrowArgs} args - Arguments to find a Baileys
     * @example
     * // Get one Baileys
     * const baileys = await prisma.baileys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaileysFindUniqueOrThrowArgs>(args: SelectSubset<T, BaileysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Baileys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysFindFirstArgs} args - Arguments to find a Baileys
     * @example
     * // Get one Baileys
     * const baileys = await prisma.baileys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaileysFindFirstArgs>(args?: SelectSubset<T, BaileysFindFirstArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Baileys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysFindFirstOrThrowArgs} args - Arguments to find a Baileys
     * @example
     * // Get one Baileys
     * const baileys = await prisma.baileys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaileysFindFirstOrThrowArgs>(args?: SelectSubset<T, BaileysFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Baileys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Baileys
     * const baileys = await prisma.baileys.findMany()
     * 
     * // Get first 10 Baileys
     * const baileys = await prisma.baileys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baileysWithIdOnly = await prisma.baileys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaileysFindManyArgs>(args?: SelectSubset<T, BaileysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Baileys.
     * @param {BaileysCreateArgs} args - Arguments to create a Baileys.
     * @example
     * // Create one Baileys
     * const Baileys = await prisma.baileys.create({
     *   data: {
     *     // ... data to create a Baileys
     *   }
     * })
     * 
     */
    create<T extends BaileysCreateArgs>(args: SelectSubset<T, BaileysCreateArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Baileys.
     * @param {BaileysCreateManyArgs} args - Arguments to create many Baileys.
     * @example
     * // Create many Baileys
     * const baileys = await prisma.baileys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaileysCreateManyArgs>(args?: SelectSubset<T, BaileysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Baileys.
     * @param {BaileysDeleteArgs} args - Arguments to delete one Baileys.
     * @example
     * // Delete one Baileys
     * const Baileys = await prisma.baileys.delete({
     *   where: {
     *     // ... filter to delete one Baileys
     *   }
     * })
     * 
     */
    delete<T extends BaileysDeleteArgs>(args: SelectSubset<T, BaileysDeleteArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Baileys.
     * @param {BaileysUpdateArgs} args - Arguments to update one Baileys.
     * @example
     * // Update one Baileys
     * const baileys = await prisma.baileys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaileysUpdateArgs>(args: SelectSubset<T, BaileysUpdateArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Baileys.
     * @param {BaileysDeleteManyArgs} args - Arguments to filter Baileys to delete.
     * @example
     * // Delete a few Baileys
     * const { count } = await prisma.baileys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaileysDeleteManyArgs>(args?: SelectSubset<T, BaileysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Baileys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Baileys
     * const baileys = await prisma.baileys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaileysUpdateManyArgs>(args: SelectSubset<T, BaileysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Baileys.
     * @param {BaileysUpsertArgs} args - Arguments to update or create a Baileys.
     * @example
     * // Update or create a Baileys
     * const baileys = await prisma.baileys.upsert({
     *   create: {
     *     // ... data to create a Baileys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Baileys we want to update
     *   }
     * })
     */
    upsert<T extends BaileysUpsertArgs>(args: SelectSubset<T, BaileysUpsertArgs<ExtArgs>>): Prisma__BaileysClient<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Baileys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysCountArgs} args - Arguments to filter Baileys to count.
     * @example
     * // Count the number of Baileys
     * const count = await prisma.baileys.count({
     *   where: {
     *     // ... the filter for the Baileys we want to count
     *   }
     * })
    **/
    count<T extends BaileysCountArgs>(
      args?: Subset<T, BaileysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaileysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Baileys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaileysAggregateArgs>(args: Subset<T, BaileysAggregateArgs>): Prisma.PrismaPromise<GetBaileysAggregateType<T>>

    /**
     * Group by Baileys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaileysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaileysGroupByArgs['orderBy'] }
        : { orderBy?: BaileysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaileysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaileysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Baileys model
   */
  readonly fields: BaileysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Baileys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaileysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsapp<T extends WhatsappDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappDefaultArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Baileys model
   */ 
  interface BaileysFieldRefs {
    readonly id: FieldRef<"Baileys", 'Int'>
    readonly contacts: FieldRef<"Baileys", 'String'>
    readonly chats: FieldRef<"Baileys", 'String'>
    readonly createdAt: FieldRef<"Baileys", 'DateTime'>
    readonly updatedAt: FieldRef<"Baileys", 'DateTime'>
    readonly whatsappId: FieldRef<"Baileys", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Baileys findUnique
   */
  export type BaileysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * Filter, which Baileys to fetch.
     */
    where: BaileysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys findUniqueOrThrow
   */
  export type BaileysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * Filter, which Baileys to fetch.
     */
    where: BaileysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys findFirst
   */
  export type BaileysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * Filter, which Baileys to fetch.
     */
    where?: BaileysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baileys to fetch.
     */
    orderBy?: BaileysOrderByWithRelationInput | BaileysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Baileys.
     */
    cursor?: BaileysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baileys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baileys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Baileys.
     */
    distinct?: BaileysScalarFieldEnum | BaileysScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys findFirstOrThrow
   */
  export type BaileysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * Filter, which Baileys to fetch.
     */
    where?: BaileysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baileys to fetch.
     */
    orderBy?: BaileysOrderByWithRelationInput | BaileysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Baileys.
     */
    cursor?: BaileysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baileys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baileys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Baileys.
     */
    distinct?: BaileysScalarFieldEnum | BaileysScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys findMany
   */
  export type BaileysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * Filter, which Baileys to fetch.
     */
    where?: BaileysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Baileys to fetch.
     */
    orderBy?: BaileysOrderByWithRelationInput | BaileysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Baileys.
     */
    cursor?: BaileysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Baileys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Baileys.
     */
    skip?: number
    distinct?: BaileysScalarFieldEnum | BaileysScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys create
   */
  export type BaileysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * The data needed to create a Baileys.
     */
    data: XOR<BaileysCreateInput, BaileysUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys createMany
   */
  export type BaileysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Baileys.
     */
    data: BaileysCreateManyInput | BaileysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Baileys update
   */
  export type BaileysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * The data needed to update a Baileys.
     */
    data: XOR<BaileysUpdateInput, BaileysUncheckedUpdateInput>
    /**
     * Choose, which Baileys to update.
     */
    where: BaileysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys updateMany
   */
  export type BaileysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Baileys.
     */
    data: XOR<BaileysUpdateManyMutationInput, BaileysUncheckedUpdateManyInput>
    /**
     * Filter which Baileys to update
     */
    where?: BaileysWhereInput
  }

  /**
   * Baileys upsert
   */
  export type BaileysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * The filter to search for the Baileys to update in case it exists.
     */
    where: BaileysWhereUniqueInput
    /**
     * In case the Baileys found by the `where` argument doesn't exist, create a new Baileys with this data.
     */
    create: XOR<BaileysCreateInput, BaileysUncheckedCreateInput>
    /**
     * In case the Baileys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaileysUpdateInput, BaileysUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys delete
   */
  export type BaileysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    /**
     * Filter which Baileys to delete.
     */
    where: BaileysWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Baileys deleteMany
   */
  export type BaileysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Baileys to delete
     */
    where?: BaileysWhereInput
  }

  /**
   * Baileys without action
   */
  export type BaileysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
  }


  /**
   * Model BaileysChats
   */

  export type AggregateBaileysChats = {
    _count: BaileysChatsCountAggregateOutputType | null
    _avg: BaileysChatsAvgAggregateOutputType | null
    _sum: BaileysChatsSumAggregateOutputType | null
    _min: BaileysChatsMinAggregateOutputType | null
    _max: BaileysChatsMaxAggregateOutputType | null
  }

  export type BaileysChatsAvgAggregateOutputType = {
    id: number | null
    conversationTimestamp: number | null
    unreadCount: number | null
    whatsappId: number | null
  }

  export type BaileysChatsSumAggregateOutputType = {
    id: number | null
    conversationTimestamp: number | null
    unreadCount: number | null
    whatsappId: number | null
  }

  export type BaileysChatsMinAggregateOutputType = {
    id: number | null
    jid: string | null
    conversationTimestamp: number | null
    unreadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    whatsappId: number | null
  }

  export type BaileysChatsMaxAggregateOutputType = {
    id: number | null
    jid: string | null
    conversationTimestamp: number | null
    unreadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    whatsappId: number | null
  }

  export type BaileysChatsCountAggregateOutputType = {
    id: number
    jid: number
    conversationTimestamp: number
    unreadCount: number
    createdAt: number
    updatedAt: number
    whatsappId: number
    _all: number
  }


  export type BaileysChatsAvgAggregateInputType = {
    id?: true
    conversationTimestamp?: true
    unreadCount?: true
    whatsappId?: true
  }

  export type BaileysChatsSumAggregateInputType = {
    id?: true
    conversationTimestamp?: true
    unreadCount?: true
    whatsappId?: true
  }

  export type BaileysChatsMinAggregateInputType = {
    id?: true
    jid?: true
    conversationTimestamp?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    whatsappId?: true
  }

  export type BaileysChatsMaxAggregateInputType = {
    id?: true
    jid?: true
    conversationTimestamp?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    whatsappId?: true
  }

  export type BaileysChatsCountAggregateInputType = {
    id?: true
    jid?: true
    conversationTimestamp?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    whatsappId?: true
    _all?: true
  }

  export type BaileysChatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaileysChats to aggregate.
     */
    where?: BaileysChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaileysChats to fetch.
     */
    orderBy?: BaileysChatsOrderByWithRelationInput | BaileysChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BaileysChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaileysChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaileysChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BaileysChats
    **/
    _count?: true | BaileysChatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaileysChatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaileysChatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaileysChatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaileysChatsMaxAggregateInputType
  }

  export type GetBaileysChatsAggregateType<T extends BaileysChatsAggregateArgs> = {
        [P in keyof T & keyof AggregateBaileysChats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaileysChats[P]>
      : GetScalarType<T[P], AggregateBaileysChats[P]>
  }




  export type BaileysChatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BaileysChatsWhereInput
    orderBy?: BaileysChatsOrderByWithAggregationInput | BaileysChatsOrderByWithAggregationInput[]
    by: BaileysChatsScalarFieldEnum[] | BaileysChatsScalarFieldEnum
    having?: BaileysChatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaileysChatsCountAggregateInputType | true
    _avg?: BaileysChatsAvgAggregateInputType
    _sum?: BaileysChatsSumAggregateInputType
    _min?: BaileysChatsMinAggregateInputType
    _max?: BaileysChatsMaxAggregateInputType
  }

  export type BaileysChatsGroupByOutputType = {
    id: number
    jid: string
    conversationTimestamp: number
    unreadCount: number
    createdAt: Date
    updatedAt: Date
    whatsappId: number
    _count: BaileysChatsCountAggregateOutputType | null
    _avg: BaileysChatsAvgAggregateOutputType | null
    _sum: BaileysChatsSumAggregateOutputType | null
    _min: BaileysChatsMinAggregateOutputType | null
    _max: BaileysChatsMaxAggregateOutputType | null
  }

  type GetBaileysChatsGroupByPayload<T extends BaileysChatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BaileysChatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaileysChatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaileysChatsGroupByOutputType[P]>
            : GetScalarType<T[P], BaileysChatsGroupByOutputType[P]>
        }
      >
    >


  export type BaileysChatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jid?: boolean
    conversationTimestamp?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsappId?: boolean
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["baileysChats"]>


  export type BaileysChatsSelectScalar = {
    id?: boolean
    jid?: boolean
    conversationTimestamp?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsappId?: boolean
  }

  export type BaileysChatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
  }

  export type $BaileysChatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BaileysChats"
    objects: {
      whatsapp: Prisma.$WhatsappPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jid: string
      conversationTimestamp: number
      unreadCount: number
      createdAt: Date
      updatedAt: Date
      whatsappId: number
    }, ExtArgs["result"]["baileysChats"]>
    composites: {}
  }

  type BaileysChatsGetPayload<S extends boolean | null | undefined | BaileysChatsDefaultArgs> = $Result.GetResult<Prisma.$BaileysChatsPayload, S>

  type BaileysChatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BaileysChatsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: BaileysChatsCountAggregateInputType | true
    }

  export interface BaileysChatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BaileysChats'], meta: { name: 'BaileysChats' } }
    /**
     * Find zero or one BaileysChats that matches the filter.
     * @param {BaileysChatsFindUniqueArgs} args - Arguments to find a BaileysChats
     * @example
     * // Get one BaileysChats
     * const baileysChats = await prisma.baileysChats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BaileysChatsFindUniqueArgs>(args: SelectSubset<T, BaileysChatsFindUniqueArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BaileysChats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BaileysChatsFindUniqueOrThrowArgs} args - Arguments to find a BaileysChats
     * @example
     * // Get one BaileysChats
     * const baileysChats = await prisma.baileysChats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BaileysChatsFindUniqueOrThrowArgs>(args: SelectSubset<T, BaileysChatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BaileysChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsFindFirstArgs} args - Arguments to find a BaileysChats
     * @example
     * // Get one BaileysChats
     * const baileysChats = await prisma.baileysChats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BaileysChatsFindFirstArgs>(args?: SelectSubset<T, BaileysChatsFindFirstArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BaileysChats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsFindFirstOrThrowArgs} args - Arguments to find a BaileysChats
     * @example
     * // Get one BaileysChats
     * const baileysChats = await prisma.baileysChats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BaileysChatsFindFirstOrThrowArgs>(args?: SelectSubset<T, BaileysChatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BaileysChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaileysChats
     * const baileysChats = await prisma.baileysChats.findMany()
     * 
     * // Get first 10 BaileysChats
     * const baileysChats = await prisma.baileysChats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baileysChatsWithIdOnly = await prisma.baileysChats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BaileysChatsFindManyArgs>(args?: SelectSubset<T, BaileysChatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BaileysChats.
     * @param {BaileysChatsCreateArgs} args - Arguments to create a BaileysChats.
     * @example
     * // Create one BaileysChats
     * const BaileysChats = await prisma.baileysChats.create({
     *   data: {
     *     // ... data to create a BaileysChats
     *   }
     * })
     * 
     */
    create<T extends BaileysChatsCreateArgs>(args: SelectSubset<T, BaileysChatsCreateArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BaileysChats.
     * @param {BaileysChatsCreateManyArgs} args - Arguments to create many BaileysChats.
     * @example
     * // Create many BaileysChats
     * const baileysChats = await prisma.baileysChats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BaileysChatsCreateManyArgs>(args?: SelectSubset<T, BaileysChatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BaileysChats.
     * @param {BaileysChatsDeleteArgs} args - Arguments to delete one BaileysChats.
     * @example
     * // Delete one BaileysChats
     * const BaileysChats = await prisma.baileysChats.delete({
     *   where: {
     *     // ... filter to delete one BaileysChats
     *   }
     * })
     * 
     */
    delete<T extends BaileysChatsDeleteArgs>(args: SelectSubset<T, BaileysChatsDeleteArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BaileysChats.
     * @param {BaileysChatsUpdateArgs} args - Arguments to update one BaileysChats.
     * @example
     * // Update one BaileysChats
     * const baileysChats = await prisma.baileysChats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BaileysChatsUpdateArgs>(args: SelectSubset<T, BaileysChatsUpdateArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BaileysChats.
     * @param {BaileysChatsDeleteManyArgs} args - Arguments to filter BaileysChats to delete.
     * @example
     * // Delete a few BaileysChats
     * const { count } = await prisma.baileysChats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BaileysChatsDeleteManyArgs>(args?: SelectSubset<T, BaileysChatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaileysChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaileysChats
     * const baileysChats = await prisma.baileysChats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BaileysChatsUpdateManyArgs>(args: SelectSubset<T, BaileysChatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BaileysChats.
     * @param {BaileysChatsUpsertArgs} args - Arguments to update or create a BaileysChats.
     * @example
     * // Update or create a BaileysChats
     * const baileysChats = await prisma.baileysChats.upsert({
     *   create: {
     *     // ... data to create a BaileysChats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaileysChats we want to update
     *   }
     * })
     */
    upsert<T extends BaileysChatsUpsertArgs>(args: SelectSubset<T, BaileysChatsUpsertArgs<ExtArgs>>): Prisma__BaileysChatsClient<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BaileysChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsCountArgs} args - Arguments to filter BaileysChats to count.
     * @example
     * // Count the number of BaileysChats
     * const count = await prisma.baileysChats.count({
     *   where: {
     *     // ... the filter for the BaileysChats we want to count
     *   }
     * })
    **/
    count<T extends BaileysChatsCountArgs>(
      args?: Subset<T, BaileysChatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaileysChatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaileysChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaileysChatsAggregateArgs>(args: Subset<T, BaileysChatsAggregateArgs>): Prisma.PrismaPromise<GetBaileysChatsAggregateType<T>>

    /**
     * Group by BaileysChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaileysChatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaileysChatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaileysChatsGroupByArgs['orderBy'] }
        : { orderBy?: BaileysChatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaileysChatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaileysChatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BaileysChats model
   */
  readonly fields: BaileysChatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BaileysChats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BaileysChatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsapp<T extends WhatsappDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappDefaultArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BaileysChats model
   */ 
  interface BaileysChatsFieldRefs {
    readonly id: FieldRef<"BaileysChats", 'Int'>
    readonly jid: FieldRef<"BaileysChats", 'String'>
    readonly conversationTimestamp: FieldRef<"BaileysChats", 'Int'>
    readonly unreadCount: FieldRef<"BaileysChats", 'Int'>
    readonly createdAt: FieldRef<"BaileysChats", 'DateTime'>
    readonly updatedAt: FieldRef<"BaileysChats", 'DateTime'>
    readonly whatsappId: FieldRef<"BaileysChats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BaileysChats findUnique
   */
  export type BaileysChatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * Filter, which BaileysChats to fetch.
     */
    where: BaileysChatsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats findUniqueOrThrow
   */
  export type BaileysChatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * Filter, which BaileysChats to fetch.
     */
    where: BaileysChatsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats findFirst
   */
  export type BaileysChatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * Filter, which BaileysChats to fetch.
     */
    where?: BaileysChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaileysChats to fetch.
     */
    orderBy?: BaileysChatsOrderByWithRelationInput | BaileysChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaileysChats.
     */
    cursor?: BaileysChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaileysChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaileysChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaileysChats.
     */
    distinct?: BaileysChatsScalarFieldEnum | BaileysChatsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats findFirstOrThrow
   */
  export type BaileysChatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * Filter, which BaileysChats to fetch.
     */
    where?: BaileysChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaileysChats to fetch.
     */
    orderBy?: BaileysChatsOrderByWithRelationInput | BaileysChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BaileysChats.
     */
    cursor?: BaileysChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaileysChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaileysChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BaileysChats.
     */
    distinct?: BaileysChatsScalarFieldEnum | BaileysChatsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats findMany
   */
  export type BaileysChatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * Filter, which BaileysChats to fetch.
     */
    where?: BaileysChatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BaileysChats to fetch.
     */
    orderBy?: BaileysChatsOrderByWithRelationInput | BaileysChatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BaileysChats.
     */
    cursor?: BaileysChatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BaileysChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BaileysChats.
     */
    skip?: number
    distinct?: BaileysChatsScalarFieldEnum | BaileysChatsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats create
   */
  export type BaileysChatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * The data needed to create a BaileysChats.
     */
    data: XOR<BaileysChatsCreateInput, BaileysChatsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats createMany
   */
  export type BaileysChatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BaileysChats.
     */
    data: BaileysChatsCreateManyInput | BaileysChatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BaileysChats update
   */
  export type BaileysChatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * The data needed to update a BaileysChats.
     */
    data: XOR<BaileysChatsUpdateInput, BaileysChatsUncheckedUpdateInput>
    /**
     * Choose, which BaileysChats to update.
     */
    where: BaileysChatsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats updateMany
   */
  export type BaileysChatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BaileysChats.
     */
    data: XOR<BaileysChatsUpdateManyMutationInput, BaileysChatsUncheckedUpdateManyInput>
    /**
     * Filter which BaileysChats to update
     */
    where?: BaileysChatsWhereInput
  }

  /**
   * BaileysChats upsert
   */
  export type BaileysChatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * The filter to search for the BaileysChats to update in case it exists.
     */
    where: BaileysChatsWhereUniqueInput
    /**
     * In case the BaileysChats found by the `where` argument doesn't exist, create a new BaileysChats with this data.
     */
    create: XOR<BaileysChatsCreateInput, BaileysChatsUncheckedCreateInput>
    /**
     * In case the BaileysChats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BaileysChatsUpdateInput, BaileysChatsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats delete
   */
  export type BaileysChatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    /**
     * Filter which BaileysChats to delete.
     */
    where: BaileysChatsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * BaileysChats deleteMany
   */
  export type BaileysChatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BaileysChats to delete
     */
    where?: BaileysChatsWhereInput
  }

  /**
   * BaileysChats without action
   */
  export type BaileysChatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    contactListId: number | null
    whatsappId: number | null
    fileListId: number | null
  }

  export type CampaignSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    contactListId: number | null
    whatsappId: number | null
    fileListId: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: number | null
    name: string | null
    message1: string | null
    message2: string | null
    message3: string | null
    message4: string | null
    message5: string | null
    confirmationMessage1: string | null
    confirmationMessage2: string | null
    confirmationMessage3: string | null
    confirmationMessage4: string | null
    confirmationMessage5: string | null
    status: string | null
    confirmation: boolean | null
    mediaPath: string | null
    mediaName: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    contactListId: number | null
    whatsappId: number | null
    fileListId: number | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: number | null
    name: string | null
    message1: string | null
    message2: string | null
    message3: string | null
    message4: string | null
    message5: string | null
    confirmationMessage1: string | null
    confirmationMessage2: string | null
    confirmationMessage3: string | null
    confirmationMessage4: string | null
    confirmationMessage5: string | null
    status: string | null
    confirmation: boolean | null
    mediaPath: string | null
    mediaName: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    contactListId: number | null
    whatsappId: number | null
    fileListId: number | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    message1: number
    message2: number
    message3: number
    message4: number
    message5: number
    confirmationMessage1: number
    confirmationMessage2: number
    confirmationMessage3: number
    confirmationMessage4: number
    confirmationMessage5: number
    status: number
    confirmation: number
    mediaPath: number
    mediaName: number
    scheduledAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    companyId: number
    contactListId: number
    whatsappId: number
    fileListId: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    id?: true
    companyId?: true
    contactListId?: true
    whatsappId?: true
    fileListId?: true
  }

  export type CampaignSumAggregateInputType = {
    id?: true
    companyId?: true
    contactListId?: true
    whatsappId?: true
    fileListId?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    message1?: true
    message2?: true
    message3?: true
    message4?: true
    message5?: true
    confirmationMessage1?: true
    confirmationMessage2?: true
    confirmationMessage3?: true
    confirmationMessage4?: true
    confirmationMessage5?: true
    status?: true
    confirmation?: true
    mediaPath?: true
    mediaName?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    contactListId?: true
    whatsappId?: true
    fileListId?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    message1?: true
    message2?: true
    message3?: true
    message4?: true
    message5?: true
    confirmationMessage1?: true
    confirmationMessage2?: true
    confirmationMessage3?: true
    confirmationMessage4?: true
    confirmationMessage5?: true
    status?: true
    confirmation?: true
    mediaPath?: true
    mediaName?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    contactListId?: true
    whatsappId?: true
    fileListId?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    message1?: true
    message2?: true
    message3?: true
    message4?: true
    message5?: true
    confirmationMessage1?: true
    confirmationMessage2?: true
    confirmationMessage3?: true
    confirmationMessage4?: true
    confirmationMessage5?: true
    status?: true
    confirmation?: true
    mediaPath?: true
    mediaName?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    contactListId?: true
    whatsappId?: true
    fileListId?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: number
    name: string
    message1: string
    message2: string
    message3: string
    message4: string
    message5: string
    confirmationMessage1: string
    confirmationMessage2: string
    confirmationMessage3: string
    confirmationMessage4: string
    confirmationMessage5: string
    status: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    companyId: number
    contactListId: number | null
    whatsappId: number | null
    fileListId: number
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    message1?: boolean
    message2?: boolean
    message3?: boolean
    message4?: boolean
    message5?: boolean
    confirmationMessage1?: boolean
    confirmationMessage2?: boolean
    confirmationMessage3?: boolean
    confirmationMessage4?: boolean
    confirmationMessage5?: boolean
    status?: boolean
    confirmation?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    contactListId?: boolean
    whatsappId?: boolean
    fileListId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contactList?: boolean | Campaign$contactListArgs<ExtArgs>
    whatsapp?: boolean | Campaign$whatsappArgs<ExtArgs>
    fileList?: boolean | FilesDefaultArgs<ExtArgs>
    shipping?: boolean | Campaign$shippingArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>


  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    message1?: boolean
    message2?: boolean
    message3?: boolean
    message4?: boolean
    message5?: boolean
    confirmationMessage1?: boolean
    confirmationMessage2?: boolean
    confirmationMessage3?: boolean
    confirmationMessage4?: boolean
    confirmationMessage5?: boolean
    status?: boolean
    confirmation?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    contactListId?: boolean
    whatsappId?: boolean
    fileListId?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contactList?: boolean | Campaign$contactListArgs<ExtArgs>
    whatsapp?: boolean | Campaign$whatsappArgs<ExtArgs>
    fileList?: boolean | FilesDefaultArgs<ExtArgs>
    shipping?: boolean | Campaign$shippingArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      contactList: Prisma.$ContactListPayload<ExtArgs> | null
      whatsapp: Prisma.$WhatsappPayload<ExtArgs> | null
      fileList: Prisma.$FilesPayload<ExtArgs>
      shipping: Prisma.$CampaignShippingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      message1: string
      message2: string
      message3: string
      message4: string
      message5: string
      confirmationMessage1: string
      confirmationMessage2: string
      confirmationMessage3: string
      confirmationMessage4: string
      confirmationMessage5: string
      status: string
      confirmation: boolean
      mediaPath: string
      mediaName: string
      scheduledAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      companyId: number
      contactListId: number | null
      whatsappId: number | null
      fileListId: number
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contactList<T extends Campaign$contactListArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$contactListArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    whatsapp<T extends Campaign$whatsappArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$whatsappArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fileList<T extends FilesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilesDefaultArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shipping<T extends Campaign$shippingArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$shippingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'Int'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly message1: FieldRef<"Campaign", 'String'>
    readonly message2: FieldRef<"Campaign", 'String'>
    readonly message3: FieldRef<"Campaign", 'String'>
    readonly message4: FieldRef<"Campaign", 'String'>
    readonly message5: FieldRef<"Campaign", 'String'>
    readonly confirmationMessage1: FieldRef<"Campaign", 'String'>
    readonly confirmationMessage2: FieldRef<"Campaign", 'String'>
    readonly confirmationMessage3: FieldRef<"Campaign", 'String'>
    readonly confirmationMessage4: FieldRef<"Campaign", 'String'>
    readonly confirmationMessage5: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly confirmation: FieldRef<"Campaign", 'Boolean'>
    readonly mediaPath: FieldRef<"Campaign", 'String'>
    readonly mediaName: FieldRef<"Campaign", 'String'>
    readonly scheduledAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly companyId: FieldRef<"Campaign", 'Int'>
    readonly contactListId: FieldRef<"Campaign", 'Int'>
    readonly whatsappId: FieldRef<"Campaign", 'Int'>
    readonly fileListId: FieldRef<"Campaign", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.contactList
   */
  export type Campaign$contactListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    where?: ContactListWhereInput
  }

  /**
   * Campaign.whatsapp
   */
  export type Campaign$whatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
  }

  /**
   * Campaign.shipping
   */
  export type Campaign$shippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    where?: CampaignShippingWhereInput
    orderBy?: CampaignShippingOrderByWithRelationInput | CampaignShippingOrderByWithRelationInput[]
    cursor?: CampaignShippingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignShippingScalarFieldEnum | CampaignShippingScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignSetting
   */

  export type AggregateCampaignSetting = {
    _count: CampaignSettingCountAggregateOutputType | null
    _avg: CampaignSettingAvgAggregateOutputType | null
    _sum: CampaignSettingSumAggregateOutputType | null
    _min: CampaignSettingMinAggregateOutputType | null
    _max: CampaignSettingMaxAggregateOutputType | null
  }

  export type CampaignSettingAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CampaignSettingSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CampaignSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type CampaignSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type CampaignSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type CampaignSettingAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CampaignSettingSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CampaignSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CampaignSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type CampaignSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type CampaignSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignSetting to aggregate.
     */
    where?: CampaignSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSettings to fetch.
     */
    orderBy?: CampaignSettingOrderByWithRelationInput | CampaignSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignSettings
    **/
    _count?: true | CampaignSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignSettingMaxAggregateInputType
  }

  export type GetCampaignSettingAggregateType<T extends CampaignSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignSetting[P]>
      : GetScalarType<T[P], AggregateCampaignSetting[P]>
  }




  export type CampaignSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignSettingWhereInput
    orderBy?: CampaignSettingOrderByWithAggregationInput | CampaignSettingOrderByWithAggregationInput[]
    by: CampaignSettingScalarFieldEnum[] | CampaignSettingScalarFieldEnum
    having?: CampaignSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignSettingCountAggregateInputType | true
    _avg?: CampaignSettingAvgAggregateInputType
    _sum?: CampaignSettingSumAggregateInputType
    _min?: CampaignSettingMinAggregateInputType
    _max?: CampaignSettingMaxAggregateInputType
  }

  export type CampaignSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    companyId: number
    _count: CampaignSettingCountAggregateOutputType | null
    _avg: CampaignSettingAvgAggregateOutputType | null
    _sum: CampaignSettingSumAggregateOutputType | null
    _min: CampaignSettingMinAggregateOutputType | null
    _max: CampaignSettingMaxAggregateOutputType | null
  }

  type GetCampaignSettingGroupByPayload<T extends CampaignSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignSettingGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignSettingGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignSetting"]>


  export type CampaignSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type CampaignSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CampaignSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignSetting"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
      companyId: number
    }, ExtArgs["result"]["campaignSetting"]>
    composites: {}
  }

  type CampaignSettingGetPayload<S extends boolean | null | undefined | CampaignSettingDefaultArgs> = $Result.GetResult<Prisma.$CampaignSettingPayload, S>

  type CampaignSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CampaignSettingCountAggregateInputType | true
    }

  export interface CampaignSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignSetting'], meta: { name: 'CampaignSetting' } }
    /**
     * Find zero or one CampaignSetting that matches the filter.
     * @param {CampaignSettingFindUniqueArgs} args - Arguments to find a CampaignSetting
     * @example
     * // Get one CampaignSetting
     * const campaignSetting = await prisma.campaignSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignSettingFindUniqueArgs>(args: SelectSubset<T, CampaignSettingFindUniqueArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignSettingFindUniqueOrThrowArgs} args - Arguments to find a CampaignSetting
     * @example
     * // Get one CampaignSetting
     * const campaignSetting = await prisma.campaignSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingFindFirstArgs} args - Arguments to find a CampaignSetting
     * @example
     * // Get one CampaignSetting
     * const campaignSetting = await prisma.campaignSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignSettingFindFirstArgs>(args?: SelectSubset<T, CampaignSettingFindFirstArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingFindFirstOrThrowArgs} args - Arguments to find a CampaignSetting
     * @example
     * // Get one CampaignSetting
     * const campaignSetting = await prisma.campaignSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignSettings
     * const campaignSettings = await prisma.campaignSetting.findMany()
     * 
     * // Get first 10 CampaignSettings
     * const campaignSettings = await prisma.campaignSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignSettingWithIdOnly = await prisma.campaignSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignSettingFindManyArgs>(args?: SelectSubset<T, CampaignSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignSetting.
     * @param {CampaignSettingCreateArgs} args - Arguments to create a CampaignSetting.
     * @example
     * // Create one CampaignSetting
     * const CampaignSetting = await prisma.campaignSetting.create({
     *   data: {
     *     // ... data to create a CampaignSetting
     *   }
     * })
     * 
     */
    create<T extends CampaignSettingCreateArgs>(args: SelectSubset<T, CampaignSettingCreateArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignSettings.
     * @param {CampaignSettingCreateManyArgs} args - Arguments to create many CampaignSettings.
     * @example
     * // Create many CampaignSettings
     * const campaignSetting = await prisma.campaignSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignSettingCreateManyArgs>(args?: SelectSubset<T, CampaignSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignSetting.
     * @param {CampaignSettingDeleteArgs} args - Arguments to delete one CampaignSetting.
     * @example
     * // Delete one CampaignSetting
     * const CampaignSetting = await prisma.campaignSetting.delete({
     *   where: {
     *     // ... filter to delete one CampaignSetting
     *   }
     * })
     * 
     */
    delete<T extends CampaignSettingDeleteArgs>(args: SelectSubset<T, CampaignSettingDeleteArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignSetting.
     * @param {CampaignSettingUpdateArgs} args - Arguments to update one CampaignSetting.
     * @example
     * // Update one CampaignSetting
     * const campaignSetting = await prisma.campaignSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignSettingUpdateArgs>(args: SelectSubset<T, CampaignSettingUpdateArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignSettings.
     * @param {CampaignSettingDeleteManyArgs} args - Arguments to filter CampaignSettings to delete.
     * @example
     * // Delete a few CampaignSettings
     * const { count } = await prisma.campaignSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignSettingDeleteManyArgs>(args?: SelectSubset<T, CampaignSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignSettings
     * const campaignSetting = await prisma.campaignSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignSettingUpdateManyArgs>(args: SelectSubset<T, CampaignSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignSetting.
     * @param {CampaignSettingUpsertArgs} args - Arguments to update or create a CampaignSetting.
     * @example
     * // Update or create a CampaignSetting
     * const campaignSetting = await prisma.campaignSetting.upsert({
     *   create: {
     *     // ... data to create a CampaignSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignSetting we want to update
     *   }
     * })
     */
    upsert<T extends CampaignSettingUpsertArgs>(args: SelectSubset<T, CampaignSettingUpsertArgs<ExtArgs>>): Prisma__CampaignSettingClient<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingCountArgs} args - Arguments to filter CampaignSettings to count.
     * @example
     * // Count the number of CampaignSettings
     * const count = await prisma.campaignSetting.count({
     *   where: {
     *     // ... the filter for the CampaignSettings we want to count
     *   }
     * })
    **/
    count<T extends CampaignSettingCountArgs>(
      args?: Subset<T, CampaignSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignSettingAggregateArgs>(args: Subset<T, CampaignSettingAggregateArgs>): Prisma.PrismaPromise<GetCampaignSettingAggregateType<T>>

    /**
     * Group by CampaignSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignSettingGroupByArgs['orderBy'] }
        : { orderBy?: CampaignSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignSetting model
   */
  readonly fields: CampaignSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignSetting model
   */ 
  interface CampaignSettingFieldRefs {
    readonly id: FieldRef<"CampaignSetting", 'Int'>
    readonly key: FieldRef<"CampaignSetting", 'String'>
    readonly value: FieldRef<"CampaignSetting", 'String'>
    readonly createdAt: FieldRef<"CampaignSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignSetting", 'DateTime'>
    readonly companyId: FieldRef<"CampaignSetting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CampaignSetting findUnique
   */
  export type CampaignSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSetting to fetch.
     */
    where: CampaignSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting findUniqueOrThrow
   */
  export type CampaignSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSetting to fetch.
     */
    where: CampaignSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting findFirst
   */
  export type CampaignSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSetting to fetch.
     */
    where?: CampaignSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSettings to fetch.
     */
    orderBy?: CampaignSettingOrderByWithRelationInput | CampaignSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignSettings.
     */
    cursor?: CampaignSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignSettings.
     */
    distinct?: CampaignSettingScalarFieldEnum | CampaignSettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting findFirstOrThrow
   */
  export type CampaignSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSetting to fetch.
     */
    where?: CampaignSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSettings to fetch.
     */
    orderBy?: CampaignSettingOrderByWithRelationInput | CampaignSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignSettings.
     */
    cursor?: CampaignSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignSettings.
     */
    distinct?: CampaignSettingScalarFieldEnum | CampaignSettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting findMany
   */
  export type CampaignSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSettings to fetch.
     */
    where?: CampaignSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSettings to fetch.
     */
    orderBy?: CampaignSettingOrderByWithRelationInput | CampaignSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignSettings.
     */
    cursor?: CampaignSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSettings.
     */
    skip?: number
    distinct?: CampaignSettingScalarFieldEnum | CampaignSettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting create
   */
  export type CampaignSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignSetting.
     */
    data: XOR<CampaignSettingCreateInput, CampaignSettingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting createMany
   */
  export type CampaignSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignSettings.
     */
    data: CampaignSettingCreateManyInput | CampaignSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignSetting update
   */
  export type CampaignSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignSetting.
     */
    data: XOR<CampaignSettingUpdateInput, CampaignSettingUncheckedUpdateInput>
    /**
     * Choose, which CampaignSetting to update.
     */
    where: CampaignSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting updateMany
   */
  export type CampaignSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignSettings.
     */
    data: XOR<CampaignSettingUpdateManyMutationInput, CampaignSettingUncheckedUpdateManyInput>
    /**
     * Filter which CampaignSettings to update
     */
    where?: CampaignSettingWhereInput
  }

  /**
   * CampaignSetting upsert
   */
  export type CampaignSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignSetting to update in case it exists.
     */
    where: CampaignSettingWhereUniqueInput
    /**
     * In case the CampaignSetting found by the `where` argument doesn't exist, create a new CampaignSetting with this data.
     */
    create: XOR<CampaignSettingCreateInput, CampaignSettingUncheckedCreateInput>
    /**
     * In case the CampaignSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignSettingUpdateInput, CampaignSettingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting delete
   */
  export type CampaignSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    /**
     * Filter which CampaignSetting to delete.
     */
    where: CampaignSettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignSetting deleteMany
   */
  export type CampaignSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignSettings to delete
     */
    where?: CampaignSettingWhereInput
  }

  /**
   * CampaignSetting without action
   */
  export type CampaignSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
  }


  /**
   * Model CampaignShipping
   */

  export type AggregateCampaignShipping = {
    _count: CampaignShippingCountAggregateOutputType | null
    _avg: CampaignShippingAvgAggregateOutputType | null
    _sum: CampaignShippingSumAggregateOutputType | null
    _min: CampaignShippingMinAggregateOutputType | null
    _max: CampaignShippingMaxAggregateOutputType | null
  }

  export type CampaignShippingAvgAggregateOutputType = {
    id: number | null
    contactId: number | null
    campaignId: number | null
  }

  export type CampaignShippingSumAggregateOutputType = {
    id: number | null
    contactId: number | null
    campaignId: number | null
  }

  export type CampaignShippingMinAggregateOutputType = {
    id: number | null
    jobId: string | null
    number: string | null
    message: string | null
    confirmationMessage: string | null
    confirmation: boolean | null
    contactId: number | null
    campaignId: number | null
    confirmationRequestedAt: Date | null
    confirmedAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignShippingMaxAggregateOutputType = {
    id: number | null
    jobId: string | null
    number: string | null
    message: string | null
    confirmationMessage: string | null
    confirmation: boolean | null
    contactId: number | null
    campaignId: number | null
    confirmationRequestedAt: Date | null
    confirmedAt: Date | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignShippingCountAggregateOutputType = {
    id: number
    jobId: number
    number: number
    message: number
    confirmationMessage: number
    confirmation: number
    contactId: number
    campaignId: number
    confirmationRequestedAt: number
    confirmedAt: number
    deliveredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignShippingAvgAggregateInputType = {
    id?: true
    contactId?: true
    campaignId?: true
  }

  export type CampaignShippingSumAggregateInputType = {
    id?: true
    contactId?: true
    campaignId?: true
  }

  export type CampaignShippingMinAggregateInputType = {
    id?: true
    jobId?: true
    number?: true
    message?: true
    confirmationMessage?: true
    confirmation?: true
    contactId?: true
    campaignId?: true
    confirmationRequestedAt?: true
    confirmedAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignShippingMaxAggregateInputType = {
    id?: true
    jobId?: true
    number?: true
    message?: true
    confirmationMessage?: true
    confirmation?: true
    contactId?: true
    campaignId?: true
    confirmationRequestedAt?: true
    confirmedAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignShippingCountAggregateInputType = {
    id?: true
    jobId?: true
    number?: true
    message?: true
    confirmationMessage?: true
    confirmation?: true
    contactId?: true
    campaignId?: true
    confirmationRequestedAt?: true
    confirmedAt?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignShippingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignShipping to aggregate.
     */
    where?: CampaignShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignShippings to fetch.
     */
    orderBy?: CampaignShippingOrderByWithRelationInput | CampaignShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignShippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignShippings
    **/
    _count?: true | CampaignShippingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignShippingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignShippingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignShippingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignShippingMaxAggregateInputType
  }

  export type GetCampaignShippingAggregateType<T extends CampaignShippingAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignShipping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignShipping[P]>
      : GetScalarType<T[P], AggregateCampaignShipping[P]>
  }




  export type CampaignShippingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignShippingWhereInput
    orderBy?: CampaignShippingOrderByWithAggregationInput | CampaignShippingOrderByWithAggregationInput[]
    by: CampaignShippingScalarFieldEnum[] | CampaignShippingScalarFieldEnum
    having?: CampaignShippingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignShippingCountAggregateInputType | true
    _avg?: CampaignShippingAvgAggregateInputType
    _sum?: CampaignShippingSumAggregateInputType
    _min?: CampaignShippingMinAggregateInputType
    _max?: CampaignShippingMaxAggregateInputType
  }

  export type CampaignShippingGroupByOutputType = {
    id: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    contactId: number
    campaignId: number
    confirmationRequestedAt: Date | null
    confirmedAt: Date | null
    deliveredAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignShippingCountAggregateOutputType | null
    _avg: CampaignShippingAvgAggregateOutputType | null
    _sum: CampaignShippingSumAggregateOutputType | null
    _min: CampaignShippingMinAggregateOutputType | null
    _max: CampaignShippingMaxAggregateOutputType | null
  }

  type GetCampaignShippingGroupByPayload<T extends CampaignShippingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignShippingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignShippingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignShippingGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignShippingGroupByOutputType[P]>
        }
      >
    >


  export type CampaignShippingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    number?: boolean
    message?: boolean
    confirmationMessage?: boolean
    confirmation?: boolean
    contactId?: boolean
    campaignId?: boolean
    confirmationRequestedAt?: boolean
    confirmedAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactListItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignShipping"]>


  export type CampaignShippingSelectScalar = {
    id?: boolean
    jobId?: boolean
    number?: boolean
    message?: boolean
    confirmationMessage?: boolean
    confirmation?: boolean
    contactId?: boolean
    campaignId?: boolean
    confirmationRequestedAt?: boolean
    confirmedAt?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignShippingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactListItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignShippingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignShipping"
    objects: {
      contact: Prisma.$ContactListItemPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobId: string
      number: string
      message: string
      confirmationMessage: string
      confirmation: boolean
      contactId: number
      campaignId: number
      confirmationRequestedAt: Date | null
      confirmedAt: Date | null
      deliveredAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignShipping"]>
    composites: {}
  }

  type CampaignShippingGetPayload<S extends boolean | null | undefined | CampaignShippingDefaultArgs> = $Result.GetResult<Prisma.$CampaignShippingPayload, S>

  type CampaignShippingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignShippingFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CampaignShippingCountAggregateInputType | true
    }

  export interface CampaignShippingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignShipping'], meta: { name: 'CampaignShipping' } }
    /**
     * Find zero or one CampaignShipping that matches the filter.
     * @param {CampaignShippingFindUniqueArgs} args - Arguments to find a CampaignShipping
     * @example
     * // Get one CampaignShipping
     * const campaignShipping = await prisma.campaignShipping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignShippingFindUniqueArgs>(args: SelectSubset<T, CampaignShippingFindUniqueArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignShipping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignShippingFindUniqueOrThrowArgs} args - Arguments to find a CampaignShipping
     * @example
     * // Get one CampaignShipping
     * const campaignShipping = await prisma.campaignShipping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignShippingFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignShippingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignShipping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingFindFirstArgs} args - Arguments to find a CampaignShipping
     * @example
     * // Get one CampaignShipping
     * const campaignShipping = await prisma.campaignShipping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignShippingFindFirstArgs>(args?: SelectSubset<T, CampaignShippingFindFirstArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignShipping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingFindFirstOrThrowArgs} args - Arguments to find a CampaignShipping
     * @example
     * // Get one CampaignShipping
     * const campaignShipping = await prisma.campaignShipping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignShippingFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignShippingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignShippings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignShippings
     * const campaignShippings = await prisma.campaignShipping.findMany()
     * 
     * // Get first 10 CampaignShippings
     * const campaignShippings = await prisma.campaignShipping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignShippingWithIdOnly = await prisma.campaignShipping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignShippingFindManyArgs>(args?: SelectSubset<T, CampaignShippingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignShipping.
     * @param {CampaignShippingCreateArgs} args - Arguments to create a CampaignShipping.
     * @example
     * // Create one CampaignShipping
     * const CampaignShipping = await prisma.campaignShipping.create({
     *   data: {
     *     // ... data to create a CampaignShipping
     *   }
     * })
     * 
     */
    create<T extends CampaignShippingCreateArgs>(args: SelectSubset<T, CampaignShippingCreateArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignShippings.
     * @param {CampaignShippingCreateManyArgs} args - Arguments to create many CampaignShippings.
     * @example
     * // Create many CampaignShippings
     * const campaignShipping = await prisma.campaignShipping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignShippingCreateManyArgs>(args?: SelectSubset<T, CampaignShippingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignShipping.
     * @param {CampaignShippingDeleteArgs} args - Arguments to delete one CampaignShipping.
     * @example
     * // Delete one CampaignShipping
     * const CampaignShipping = await prisma.campaignShipping.delete({
     *   where: {
     *     // ... filter to delete one CampaignShipping
     *   }
     * })
     * 
     */
    delete<T extends CampaignShippingDeleteArgs>(args: SelectSubset<T, CampaignShippingDeleteArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignShipping.
     * @param {CampaignShippingUpdateArgs} args - Arguments to update one CampaignShipping.
     * @example
     * // Update one CampaignShipping
     * const campaignShipping = await prisma.campaignShipping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignShippingUpdateArgs>(args: SelectSubset<T, CampaignShippingUpdateArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignShippings.
     * @param {CampaignShippingDeleteManyArgs} args - Arguments to filter CampaignShippings to delete.
     * @example
     * // Delete a few CampaignShippings
     * const { count } = await prisma.campaignShipping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignShippingDeleteManyArgs>(args?: SelectSubset<T, CampaignShippingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignShippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignShippings
     * const campaignShipping = await prisma.campaignShipping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignShippingUpdateManyArgs>(args: SelectSubset<T, CampaignShippingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignShipping.
     * @param {CampaignShippingUpsertArgs} args - Arguments to update or create a CampaignShipping.
     * @example
     * // Update or create a CampaignShipping
     * const campaignShipping = await prisma.campaignShipping.upsert({
     *   create: {
     *     // ... data to create a CampaignShipping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignShipping we want to update
     *   }
     * })
     */
    upsert<T extends CampaignShippingUpsertArgs>(args: SelectSubset<T, CampaignShippingUpsertArgs<ExtArgs>>): Prisma__CampaignShippingClient<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignShippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingCountArgs} args - Arguments to filter CampaignShippings to count.
     * @example
     * // Count the number of CampaignShippings
     * const count = await prisma.campaignShipping.count({
     *   where: {
     *     // ... the filter for the CampaignShippings we want to count
     *   }
     * })
    **/
    count<T extends CampaignShippingCountArgs>(
      args?: Subset<T, CampaignShippingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignShippingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignShipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignShippingAggregateArgs>(args: Subset<T, CampaignShippingAggregateArgs>): Prisma.PrismaPromise<GetCampaignShippingAggregateType<T>>

    /**
     * Group by CampaignShipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignShippingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignShippingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignShippingGroupByArgs['orderBy'] }
        : { orderBy?: CampaignShippingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignShippingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignShippingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignShipping model
   */
  readonly fields: CampaignShippingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignShipping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignShippingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactListItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactListItemDefaultArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignShipping model
   */ 
  interface CampaignShippingFieldRefs {
    readonly id: FieldRef<"CampaignShipping", 'Int'>
    readonly jobId: FieldRef<"CampaignShipping", 'String'>
    readonly number: FieldRef<"CampaignShipping", 'String'>
    readonly message: FieldRef<"CampaignShipping", 'String'>
    readonly confirmationMessage: FieldRef<"CampaignShipping", 'String'>
    readonly confirmation: FieldRef<"CampaignShipping", 'Boolean'>
    readonly contactId: FieldRef<"CampaignShipping", 'Int'>
    readonly campaignId: FieldRef<"CampaignShipping", 'Int'>
    readonly confirmationRequestedAt: FieldRef<"CampaignShipping", 'DateTime'>
    readonly confirmedAt: FieldRef<"CampaignShipping", 'DateTime'>
    readonly deliveredAt: FieldRef<"CampaignShipping", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignShipping", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignShipping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignShipping findUnique
   */
  export type CampaignShippingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignShipping to fetch.
     */
    where: CampaignShippingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping findUniqueOrThrow
   */
  export type CampaignShippingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignShipping to fetch.
     */
    where: CampaignShippingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping findFirst
   */
  export type CampaignShippingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignShipping to fetch.
     */
    where?: CampaignShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignShippings to fetch.
     */
    orderBy?: CampaignShippingOrderByWithRelationInput | CampaignShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignShippings.
     */
    cursor?: CampaignShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignShippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignShippings.
     */
    distinct?: CampaignShippingScalarFieldEnum | CampaignShippingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping findFirstOrThrow
   */
  export type CampaignShippingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignShipping to fetch.
     */
    where?: CampaignShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignShippings to fetch.
     */
    orderBy?: CampaignShippingOrderByWithRelationInput | CampaignShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignShippings.
     */
    cursor?: CampaignShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignShippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignShippings.
     */
    distinct?: CampaignShippingScalarFieldEnum | CampaignShippingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping findMany
   */
  export type CampaignShippingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * Filter, which CampaignShippings to fetch.
     */
    where?: CampaignShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignShippings to fetch.
     */
    orderBy?: CampaignShippingOrderByWithRelationInput | CampaignShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignShippings.
     */
    cursor?: CampaignShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignShippings.
     */
    skip?: number
    distinct?: CampaignShippingScalarFieldEnum | CampaignShippingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping create
   */
  export type CampaignShippingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignShipping.
     */
    data: XOR<CampaignShippingCreateInput, CampaignShippingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping createMany
   */
  export type CampaignShippingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignShippings.
     */
    data: CampaignShippingCreateManyInput | CampaignShippingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignShipping update
   */
  export type CampaignShippingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignShipping.
     */
    data: XOR<CampaignShippingUpdateInput, CampaignShippingUncheckedUpdateInput>
    /**
     * Choose, which CampaignShipping to update.
     */
    where: CampaignShippingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping updateMany
   */
  export type CampaignShippingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignShippings.
     */
    data: XOR<CampaignShippingUpdateManyMutationInput, CampaignShippingUncheckedUpdateManyInput>
    /**
     * Filter which CampaignShippings to update
     */
    where?: CampaignShippingWhereInput
  }

  /**
   * CampaignShipping upsert
   */
  export type CampaignShippingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignShipping to update in case it exists.
     */
    where: CampaignShippingWhereUniqueInput
    /**
     * In case the CampaignShipping found by the `where` argument doesn't exist, create a new CampaignShipping with this data.
     */
    create: XOR<CampaignShippingCreateInput, CampaignShippingUncheckedCreateInput>
    /**
     * In case the CampaignShipping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignShippingUpdateInput, CampaignShippingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping delete
   */
  export type CampaignShippingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    /**
     * Filter which CampaignShipping to delete.
     */
    where: CampaignShippingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CampaignShipping deleteMany
   */
  export type CampaignShippingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignShippings to delete
     */
    where?: CampaignShippingWhereInput
  }

  /**
   * CampaignShipping without action
   */
  export type CampaignShippingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    companyId: number | null
  }

  export type ChatSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    companyId: number | null
  }

  export type ChatMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    title: string | null
    ownerId: number | null
    lastMessage: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    title: string | null
    ownerId: number | null
    lastMessage: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    uuid: number
    title: number
    ownerId: number
    lastMessage: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatAvgAggregateInputType = {
    id?: true
    ownerId?: true
    companyId?: true
  }

  export type ChatSumAggregateInputType = {
    id?: true
    ownerId?: true
    companyId?: true
  }

  export type ChatMinAggregateInputType = {
    id?: true
    uuid?: true
    title?: true
    ownerId?: true
    lastMessage?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    uuid?: true
    title?: true
    ownerId?: true
    lastMessage?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    uuid?: true
    title?: true
    ownerId?: true
    lastMessage?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _avg?: ChatAvgAggregateInputType
    _sum?: ChatSumAggregateInputType
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: number
    uuid: string
    title: string
    ownerId: number
    lastMessage: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    title?: boolean
    ownerId?: boolean
    lastMessage?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    users?: boolean | Chat$usersArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>


  export type ChatSelectScalar = {
    id?: boolean
    uuid?: boolean
    title?: boolean
    ownerId?: boolean
    lastMessage?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    users?: boolean | Chat$usersArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      users: Prisma.$ChatUserPayload<ExtArgs>[]
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      title: string
      ownerId: number
      lastMessage: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends Chat$usersArgs<ExtArgs> = {}>(args?: Subset<T, Chat$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'Int'>
    readonly uuid: FieldRef<"Chat", 'String'>
    readonly title: FieldRef<"Chat", 'String'>
    readonly ownerId: FieldRef<"Chat", 'Int'>
    readonly lastMessage: FieldRef<"Chat", 'String'>
    readonly companyId: FieldRef<"Chat", 'Int'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat.users
   */
  export type Chat$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    where?: ChatUserWhereInput
    orderBy?: ChatUserOrderByWithRelationInput | ChatUserOrderByWithRelationInput[]
    cursor?: ChatUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatUserScalarFieldEnum | ChatUserScalarFieldEnum[]
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    id: number | null
    chatId: number | null
    senderId: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    id: number | null
    chatId: number | null
    senderId: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: number | null
    chatId: number | null
    senderId: number | null
    message: string | null
    mediaPath: string | null
    mediaName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: number | null
    chatId: number | null
    senderId: number | null
    message: string | null
    mediaPath: string | null
    mediaName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    chatId: number
    senderId: number
    message: number
    mediaPath: number
    mediaName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
  }

  export type ChatMessageSumAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    message?: true
    mediaPath?: true
    mediaName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    message?: true
    mediaPath?: true
    mediaName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    message?: true
    mediaPath?: true
    mediaName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: number
    chatId: number
    senderId: number
    message: string
    mediaPath: string | null
    mediaName: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    message?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>


  export type ChatMessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    message?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chatId: number
      senderId: number
      message: string
      mediaPath: string | null
      mediaName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */ 
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'Int'>
    readonly chatId: FieldRef<"ChatMessage", 'Int'>
    readonly senderId: FieldRef<"ChatMessage", 'Int'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly mediaPath: FieldRef<"ChatMessage", 'String'>
    readonly mediaName: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model ChatUser
   */

  export type AggregateChatUser = {
    _count: ChatUserCountAggregateOutputType | null
    _avg: ChatUserAvgAggregateOutputType | null
    _sum: ChatUserSumAggregateOutputType | null
    _min: ChatUserMinAggregateOutputType | null
    _max: ChatUserMaxAggregateOutputType | null
  }

  export type ChatUserAvgAggregateOutputType = {
    id: number | null
    chatId: number | null
    userId: number | null
    unreads: number | null
  }

  export type ChatUserSumAggregateOutputType = {
    id: number | null
    chatId: number | null
    userId: number | null
    unreads: number | null
  }

  export type ChatUserMinAggregateOutputType = {
    id: number | null
    chatId: number | null
    userId: number | null
    unreads: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatUserMaxAggregateOutputType = {
    id: number | null
    chatId: number | null
    userId: number | null
    unreads: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatUserCountAggregateOutputType = {
    id: number
    chatId: number
    userId: number
    unreads: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatUserAvgAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    unreads?: true
  }

  export type ChatUserSumAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    unreads?: true
  }

  export type ChatUserMinAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    unreads?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatUserMaxAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    unreads?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatUserCountAggregateInputType = {
    id?: true
    chatId?: true
    userId?: true
    unreads?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatUser to aggregate.
     */
    where?: ChatUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUsers to fetch.
     */
    orderBy?: ChatUserOrderByWithRelationInput | ChatUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatUsers
    **/
    _count?: true | ChatUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatUserMaxAggregateInputType
  }

  export type GetChatUserAggregateType<T extends ChatUserAggregateArgs> = {
        [P in keyof T & keyof AggregateChatUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatUser[P]>
      : GetScalarType<T[P], AggregateChatUser[P]>
  }




  export type ChatUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatUserWhereInput
    orderBy?: ChatUserOrderByWithAggregationInput | ChatUserOrderByWithAggregationInput[]
    by: ChatUserScalarFieldEnum[] | ChatUserScalarFieldEnum
    having?: ChatUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatUserCountAggregateInputType | true
    _avg?: ChatUserAvgAggregateInputType
    _sum?: ChatUserSumAggregateInputType
    _min?: ChatUserMinAggregateInputType
    _max?: ChatUserMaxAggregateInputType
  }

  export type ChatUserGroupByOutputType = {
    id: number
    chatId: number
    userId: number
    unreads: number
    createdAt: Date
    updatedAt: Date
    _count: ChatUserCountAggregateOutputType | null
    _avg: ChatUserAvgAggregateOutputType | null
    _sum: ChatUserSumAggregateOutputType | null
    _min: ChatUserMinAggregateOutputType | null
    _max: ChatUserMaxAggregateOutputType | null
  }

  type GetChatUserGroupByPayload<T extends ChatUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatUserGroupByOutputType[P]>
            : GetScalarType<T[P], ChatUserGroupByOutputType[P]>
        }
      >
    >


  export type ChatUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    userId?: boolean
    unreads?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatUser"]>


  export type ChatUserSelectScalar = {
    id?: boolean
    chatId?: boolean
    userId?: boolean
    unreads?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatUser"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chatId: number
      userId: number
      unreads: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatUser"]>
    composites: {}
  }

  type ChatUserGetPayload<S extends boolean | null | undefined | ChatUserDefaultArgs> = $Result.GetResult<Prisma.$ChatUserPayload, S>

  type ChatUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatUserFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ChatUserCountAggregateInputType | true
    }

  export interface ChatUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatUser'], meta: { name: 'ChatUser' } }
    /**
     * Find zero or one ChatUser that matches the filter.
     * @param {ChatUserFindUniqueArgs} args - Arguments to find a ChatUser
     * @example
     * // Get one ChatUser
     * const chatUser = await prisma.chatUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatUserFindUniqueArgs>(args: SelectSubset<T, ChatUserFindUniqueArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatUserFindUniqueOrThrowArgs} args - Arguments to find a ChatUser
     * @example
     * // Get one ChatUser
     * const chatUser = await prisma.chatUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserFindFirstArgs} args - Arguments to find a ChatUser
     * @example
     * // Get one ChatUser
     * const chatUser = await prisma.chatUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatUserFindFirstArgs>(args?: SelectSubset<T, ChatUserFindFirstArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserFindFirstOrThrowArgs} args - Arguments to find a ChatUser
     * @example
     * // Get one ChatUser
     * const chatUser = await prisma.chatUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatUsers
     * const chatUsers = await prisma.chatUser.findMany()
     * 
     * // Get first 10 ChatUsers
     * const chatUsers = await prisma.chatUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatUserWithIdOnly = await prisma.chatUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatUserFindManyArgs>(args?: SelectSubset<T, ChatUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatUser.
     * @param {ChatUserCreateArgs} args - Arguments to create a ChatUser.
     * @example
     * // Create one ChatUser
     * const ChatUser = await prisma.chatUser.create({
     *   data: {
     *     // ... data to create a ChatUser
     *   }
     * })
     * 
     */
    create<T extends ChatUserCreateArgs>(args: SelectSubset<T, ChatUserCreateArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatUsers.
     * @param {ChatUserCreateManyArgs} args - Arguments to create many ChatUsers.
     * @example
     * // Create many ChatUsers
     * const chatUser = await prisma.chatUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatUserCreateManyArgs>(args?: SelectSubset<T, ChatUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatUser.
     * @param {ChatUserDeleteArgs} args - Arguments to delete one ChatUser.
     * @example
     * // Delete one ChatUser
     * const ChatUser = await prisma.chatUser.delete({
     *   where: {
     *     // ... filter to delete one ChatUser
     *   }
     * })
     * 
     */
    delete<T extends ChatUserDeleteArgs>(args: SelectSubset<T, ChatUserDeleteArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatUser.
     * @param {ChatUserUpdateArgs} args - Arguments to update one ChatUser.
     * @example
     * // Update one ChatUser
     * const chatUser = await prisma.chatUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUserUpdateArgs>(args: SelectSubset<T, ChatUserUpdateArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatUsers.
     * @param {ChatUserDeleteManyArgs} args - Arguments to filter ChatUsers to delete.
     * @example
     * // Delete a few ChatUsers
     * const { count } = await prisma.chatUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatUserDeleteManyArgs>(args?: SelectSubset<T, ChatUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatUsers
     * const chatUser = await prisma.chatUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUserUpdateManyArgs>(args: SelectSubset<T, ChatUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatUser.
     * @param {ChatUserUpsertArgs} args - Arguments to update or create a ChatUser.
     * @example
     * // Update or create a ChatUser
     * const chatUser = await prisma.chatUser.upsert({
     *   create: {
     *     // ... data to create a ChatUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatUser we want to update
     *   }
     * })
     */
    upsert<T extends ChatUserUpsertArgs>(args: SelectSubset<T, ChatUserUpsertArgs<ExtArgs>>): Prisma__ChatUserClient<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserCountArgs} args - Arguments to filter ChatUsers to count.
     * @example
     * // Count the number of ChatUsers
     * const count = await prisma.chatUser.count({
     *   where: {
     *     // ... the filter for the ChatUsers we want to count
     *   }
     * })
    **/
    count<T extends ChatUserCountArgs>(
      args?: Subset<T, ChatUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatUserAggregateArgs>(args: Subset<T, ChatUserAggregateArgs>): Prisma.PrismaPromise<GetChatUserAggregateType<T>>

    /**
     * Group by ChatUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatUserGroupByArgs['orderBy'] }
        : { orderBy?: ChatUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatUser model
   */
  readonly fields: ChatUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatUser model
   */ 
  interface ChatUserFieldRefs {
    readonly id: FieldRef<"ChatUser", 'Int'>
    readonly chatId: FieldRef<"ChatUser", 'Int'>
    readonly userId: FieldRef<"ChatUser", 'Int'>
    readonly unreads: FieldRef<"ChatUser", 'Int'>
    readonly createdAt: FieldRef<"ChatUser", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatUser findUnique
   */
  export type ChatUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * Filter, which ChatUser to fetch.
     */
    where: ChatUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser findUniqueOrThrow
   */
  export type ChatUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * Filter, which ChatUser to fetch.
     */
    where: ChatUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser findFirst
   */
  export type ChatUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * Filter, which ChatUser to fetch.
     */
    where?: ChatUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUsers to fetch.
     */
    orderBy?: ChatUserOrderByWithRelationInput | ChatUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatUsers.
     */
    cursor?: ChatUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatUsers.
     */
    distinct?: ChatUserScalarFieldEnum | ChatUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser findFirstOrThrow
   */
  export type ChatUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * Filter, which ChatUser to fetch.
     */
    where?: ChatUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUsers to fetch.
     */
    orderBy?: ChatUserOrderByWithRelationInput | ChatUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatUsers.
     */
    cursor?: ChatUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatUsers.
     */
    distinct?: ChatUserScalarFieldEnum | ChatUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser findMany
   */
  export type ChatUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * Filter, which ChatUsers to fetch.
     */
    where?: ChatUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUsers to fetch.
     */
    orderBy?: ChatUserOrderByWithRelationInput | ChatUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatUsers.
     */
    cursor?: ChatUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUsers.
     */
    skip?: number
    distinct?: ChatUserScalarFieldEnum | ChatUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser create
   */
  export type ChatUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatUser.
     */
    data: XOR<ChatUserCreateInput, ChatUserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser createMany
   */
  export type ChatUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatUsers.
     */
    data: ChatUserCreateManyInput | ChatUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatUser update
   */
  export type ChatUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatUser.
     */
    data: XOR<ChatUserUpdateInput, ChatUserUncheckedUpdateInput>
    /**
     * Choose, which ChatUser to update.
     */
    where: ChatUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser updateMany
   */
  export type ChatUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatUsers.
     */
    data: XOR<ChatUserUpdateManyMutationInput, ChatUserUncheckedUpdateManyInput>
    /**
     * Filter which ChatUsers to update
     */
    where?: ChatUserWhereInput
  }

  /**
   * ChatUser upsert
   */
  export type ChatUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatUser to update in case it exists.
     */
    where: ChatUserWhereUniqueInput
    /**
     * In case the ChatUser found by the `where` argument doesn't exist, create a new ChatUser with this data.
     */
    create: XOR<ChatUserCreateInput, ChatUserUncheckedCreateInput>
    /**
     * In case the ChatUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUserUpdateInput, ChatUserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser delete
   */
  export type ChatUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    /**
     * Filter which ChatUser to delete.
     */
    where: ChatUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ChatUser deleteMany
   */
  export type ChatUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatUsers to delete
     */
    where?: ChatUserWhereInput
  }

  /**
   * ChatUser without action
   */
  export type ChatUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
    planId: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
    planId: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    email: string | null
    status: boolean | null
    dueDate: Date | null
    recurrence: string | null
    planId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    email: string | null
    status: boolean | null
    dueDate: Date | null
    recurrence: string | null
    planId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    status: number
    dueDate: number
    recurrence: number
    planId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
    planId?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
    planId?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    status?: true
    dueDate?: true
    recurrence?: true
    planId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    status?: true
    dueDate?: true
    recurrence?: true
    planId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    status?: true
    dueDate?: true
    recurrence?: true
    planId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date
    recurrence: string
    planId: number
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    dueDate?: boolean
    recurrence?: boolean
    planId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedules?: boolean | Company$schedulesArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    userRatings?: boolean | Company$userRatingsArgs<ExtArgs>
    queues?: boolean | Company$queuesArgs<ExtArgs>
    whatsapps?: boolean | Company$whatsappsArgs<ExtArgs>
    messages?: boolean | Company$messagesArgs<ExtArgs>
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    settings?: boolean | Company$settingsArgs<ExtArgs>
    tags?: boolean | Company$tagsArgs<ExtArgs>
    tickets?: boolean | Company$ticketsArgs<ExtArgs>
    ticketTrackings?: boolean | Company$ticketTrackingsArgs<ExtArgs>
    subscriptions?: boolean | Company$subscriptionsArgs<ExtArgs>
    quickMessages?: boolean | Company$quickMessagesArgs<ExtArgs>
    queueIntegrationss?: boolean | Company$queueIntegrationssArgs<ExtArgs>
    prompts?: boolean | Company$promptsArgs<ExtArgs>
    filess?: boolean | Company$filessArgs<ExtArgs>
    contactListItems?: boolean | Company$contactListItemsArgs<ExtArgs>
    contactLists?: boolean | Company$contactListsArgs<ExtArgs>
    chats?: boolean | Company$chatsArgs<ExtArgs>
    campaignSettings?: boolean | Company$campaignSettingsArgs<ExtArgs>
    campaigns?: boolean | Company$campaignsArgs<ExtArgs>
    announcements?: boolean | Company$announcementsArgs<ExtArgs>
    queue?: boolean | Company$queueArgs<ExtArgs>
    ratings?: boolean | Company$ratingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>


  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    dueDate?: boolean
    recurrence?: boolean
    planId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | Company$schedulesArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    userRatings?: boolean | Company$userRatingsArgs<ExtArgs>
    queues?: boolean | Company$queuesArgs<ExtArgs>
    whatsapps?: boolean | Company$whatsappsArgs<ExtArgs>
    messages?: boolean | Company$messagesArgs<ExtArgs>
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    settings?: boolean | Company$settingsArgs<ExtArgs>
    tags?: boolean | Company$tagsArgs<ExtArgs>
    tickets?: boolean | Company$ticketsArgs<ExtArgs>
    ticketTrackings?: boolean | Company$ticketTrackingsArgs<ExtArgs>
    subscriptions?: boolean | Company$subscriptionsArgs<ExtArgs>
    quickMessages?: boolean | Company$quickMessagesArgs<ExtArgs>
    queueIntegrationss?: boolean | Company$queueIntegrationssArgs<ExtArgs>
    prompts?: boolean | Company$promptsArgs<ExtArgs>
    filess?: boolean | Company$filessArgs<ExtArgs>
    contactListItems?: boolean | Company$contactListItemsArgs<ExtArgs>
    contactLists?: boolean | Company$contactListsArgs<ExtArgs>
    chats?: boolean | Company$chatsArgs<ExtArgs>
    campaignSettings?: boolean | Company$campaignSettingsArgs<ExtArgs>
    campaigns?: boolean | Company$campaignsArgs<ExtArgs>
    announcements?: boolean | Company$announcementsArgs<ExtArgs>
    queue?: boolean | Company$queueArgs<ExtArgs>
    ratings?: boolean | Company$ratingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      plan: Prisma.$PlanPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      userRatings: Prisma.$UserRatingPayload<ExtArgs>[]
      queues: Prisma.$QueuePayload<ExtArgs>[]
      whatsapps: Prisma.$WhatsappPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      settings: Prisma.$SettingPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      ticketTrackings: Prisma.$TicketTrackingPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      quickMessages: Prisma.$QuickMessagePayload<ExtArgs>[]
      queueIntegrationss: Prisma.$QueueIntegrationsPayload<ExtArgs>[]
      prompts: Prisma.$PromptPayload<ExtArgs>[]
      filess: Prisma.$FilesPayload<ExtArgs>[]
      contactListItems: Prisma.$ContactListItemPayload<ExtArgs>[]
      contactLists: Prisma.$ContactListPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      campaignSettings: Prisma.$CampaignSettingPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      queue: Prisma.$QueuePayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      email: string
      status: boolean
      dueDate: Date
      recurrence: string
      planId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedules<T extends Company$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Company$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    userRatings<T extends Company$userRatingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$userRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findMany"> | Null>
    queues<T extends Company$queuesArgs<ExtArgs> = {}>(args?: Subset<T, Company$queuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany"> | Null>
    whatsapps<T extends Company$whatsappsArgs<ExtArgs> = {}>(args?: Subset<T, Company$whatsappsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Company$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Company$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    contacts<T extends Company$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends Company$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Company$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Company$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends Company$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Company$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    ticketTrackings<T extends Company$ticketTrackingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$ticketTrackingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends Company$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    quickMessages<T extends Company$quickMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Company$quickMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findMany"> | Null>
    queueIntegrationss<T extends Company$queueIntegrationssArgs<ExtArgs> = {}>(args?: Subset<T, Company$queueIntegrationssArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findMany"> | Null>
    prompts<T extends Company$promptsArgs<ExtArgs> = {}>(args?: Subset<T, Company$promptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany"> | Null>
    filess<T extends Company$filessArgs<ExtArgs> = {}>(args?: Subset<T, Company$filessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany"> | Null>
    contactListItems<T extends Company$contactListItemsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contactListItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findMany"> | Null>
    contactLists<T extends Company$contactListsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contactListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findMany"> | Null>
    chats<T extends Company$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Company$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    campaignSettings<T extends Company$campaignSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$campaignSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSettingPayload<ExtArgs>, T, "findMany"> | Null>
    campaigns<T extends Company$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Company$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    announcements<T extends Company$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Company$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany"> | Null>
    queue<T extends Company$queueArgs<ExtArgs> = {}>(args?: Subset<T, Company$queueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends Company$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly status: FieldRef<"Company", 'Boolean'>
    readonly dueDate: FieldRef<"Company", 'DateTime'>
    readonly recurrence: FieldRef<"Company", 'String'>
    readonly planId: FieldRef<"Company", 'Int'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.schedules
   */
  export type Company$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.userRatings
   */
  export type Company$userRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    where?: UserRatingWhereInput
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    cursor?: UserRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * Company.queues
   */
  export type Company$queuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    cursor?: QueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Company.whatsapps
   */
  export type Company$whatsappsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    cursor?: WhatsappWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappScalarFieldEnum | WhatsappScalarFieldEnum[]
  }

  /**
   * Company.messages
   */
  export type Company$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Company.contacts
   */
  export type Company$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Company.settings
   */
  export type Company$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    cursor?: SettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Company.tags
   */
  export type Company$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Company.tickets
   */
  export type Company$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Company.ticketTrackings
   */
  export type Company$ticketTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    where?: TicketTrackingWhereInput
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    cursor?: TicketTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
  }

  /**
   * Company.subscriptions
   */
  export type Company$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Company.quickMessages
   */
  export type Company$quickMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    where?: QuickMessageWhereInput
    orderBy?: QuickMessageOrderByWithRelationInput | QuickMessageOrderByWithRelationInput[]
    cursor?: QuickMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuickMessageScalarFieldEnum | QuickMessageScalarFieldEnum[]
  }

  /**
   * Company.queueIntegrationss
   */
  export type Company$queueIntegrationssArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    where?: QueueIntegrationsWhereInput
    orderBy?: QueueIntegrationsOrderByWithRelationInput | QueueIntegrationsOrderByWithRelationInput[]
    cursor?: QueueIntegrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueIntegrationsScalarFieldEnum | QueueIntegrationsScalarFieldEnum[]
  }

  /**
   * Company.prompts
   */
  export type Company$promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    cursor?: PromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Company.filess
   */
  export type Company$filessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    cursor?: FilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * Company.contactListItems
   */
  export type Company$contactListItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    where?: ContactListItemWhereInput
    orderBy?: ContactListItemOrderByWithRelationInput | ContactListItemOrderByWithRelationInput[]
    cursor?: ContactListItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactListItemScalarFieldEnum | ContactListItemScalarFieldEnum[]
  }

  /**
   * Company.contactLists
   */
  export type Company$contactListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    where?: ContactListWhereInput
    orderBy?: ContactListOrderByWithRelationInput | ContactListOrderByWithRelationInput[]
    cursor?: ContactListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactListScalarFieldEnum | ContactListScalarFieldEnum[]
  }

  /**
   * Company.chats
   */
  export type Company$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Company.campaignSettings
   */
  export type Company$campaignSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSetting
     */
    select?: CampaignSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSettingInclude<ExtArgs> | null
    where?: CampaignSettingWhereInput
    orderBy?: CampaignSettingOrderByWithRelationInput | CampaignSettingOrderByWithRelationInput[]
    cursor?: CampaignSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignSettingScalarFieldEnum | CampaignSettingScalarFieldEnum[]
  }

  /**
   * Company.campaigns
   */
  export type Company$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Company.announcements
   */
  export type Company$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Company.queue
   */
  export type Company$queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    cursor?: QueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Company.ratings
   */
  export type Company$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    whatsappId: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    whatsappId: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    name: string | null
    number: string | null
    email: string | null
    profilePicUrl: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    whatsappId: number | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    name: string | null
    number: string | null
    email: string | null
    profilePicUrl: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    whatsappId: number | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    number: number
    email: number
    profilePicUrl: number
    isGroup: number
    createdAt: number
    updatedAt: number
    companyId: number
    whatsappId: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    companyId?: true
    whatsappId?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    companyId?: true
    whatsappId?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    number?: true
    email?: true
    profilePicUrl?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    whatsappId?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    number?: true
    email?: true
    profilePicUrl?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    whatsappId?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    number?: true
    email?: true
    profilePicUrl?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    whatsappId?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    name: string
    number: string
    email: string
    profilePicUrl: string
    isGroup: boolean
    createdAt: Date
    updatedAt: Date
    companyId: number
    whatsappId: number | null
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    number?: boolean
    email?: boolean
    profilePicUrl?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    whatsappId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapp?: boolean | Contact$whatsappArgs<ExtArgs>
    tickets?: boolean | Contact$ticketsArgs<ExtArgs>
    extraInfo?: boolean | Contact$extraInfoArgs<ExtArgs>
    schedules?: boolean | Contact$schedulesArgs<ExtArgs>
    TicketNote?: boolean | Contact$TicketNoteArgs<ExtArgs>
    Message?: boolean | Contact$MessageArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>


  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    number?: boolean
    email?: boolean
    profilePicUrl?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    whatsappId?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapp?: boolean | Contact$whatsappArgs<ExtArgs>
    tickets?: boolean | Contact$ticketsArgs<ExtArgs>
    extraInfo?: boolean | Contact$extraInfoArgs<ExtArgs>
    schedules?: boolean | Contact$schedulesArgs<ExtArgs>
    TicketNote?: boolean | Contact$TicketNoteArgs<ExtArgs>
    Message?: boolean | Contact$MessageArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      whatsapp: Prisma.$WhatsappPayload<ExtArgs> | null
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      extraInfo: Prisma.$ContactCustomFieldPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      TicketNote: Prisma.$TicketNotePayload<ExtArgs>[]
      Message: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      number: string
      email: string
      profilePicUrl: string
      isGroup: boolean
      createdAt: Date
      updatedAt: Date
      companyId: number
      whatsappId: number | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    whatsapp<T extends Contact$whatsappArgs<ExtArgs> = {}>(args?: Subset<T, Contact$whatsappArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tickets<T extends Contact$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    extraInfo<T extends Contact$extraInfoArgs<ExtArgs> = {}>(args?: Subset<T, Contact$extraInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Contact$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    TicketNote<T extends Contact$TicketNoteArgs<ExtArgs> = {}>(args?: Subset<T, Contact$TicketNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany"> | Null>
    Message<T extends Contact$MessageArgs<ExtArgs> = {}>(args?: Subset<T, Contact$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly number: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly profilePicUrl: FieldRef<"Contact", 'String'>
    readonly isGroup: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly companyId: FieldRef<"Contact", 'Int'>
    readonly whatsappId: FieldRef<"Contact", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact.whatsapp
   */
  export type Contact$whatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
  }

  /**
   * Contact.tickets
   */
  export type Contact$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Contact.extraInfo
   */
  export type Contact$extraInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    where?: ContactCustomFieldWhereInput
    orderBy?: ContactCustomFieldOrderByWithRelationInput | ContactCustomFieldOrderByWithRelationInput[]
    cursor?: ContactCustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactCustomFieldScalarFieldEnum | ContactCustomFieldScalarFieldEnum[]
  }

  /**
   * Contact.schedules
   */
  export type Contact$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Contact.TicketNote
   */
  export type Contact$TicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    cursor?: TicketNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * Contact.Message
   */
  export type Contact$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ContactCustomField
   */

  export type AggregateContactCustomField = {
    _count: ContactCustomFieldCountAggregateOutputType | null
    _avg: ContactCustomFieldAvgAggregateOutputType | null
    _sum: ContactCustomFieldSumAggregateOutputType | null
    _min: ContactCustomFieldMinAggregateOutputType | null
    _max: ContactCustomFieldMaxAggregateOutputType | null
  }

  export type ContactCustomFieldAvgAggregateOutputType = {
    id: number | null
    contactId: number | null
  }

  export type ContactCustomFieldSumAggregateOutputType = {
    id: number | null
    contactId: number | null
  }

  export type ContactCustomFieldMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: string | null
    contactId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCustomFieldMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: string | null
    contactId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCustomFieldCountAggregateOutputType = {
    id: number
    name: number
    value: number
    contactId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactCustomFieldAvgAggregateInputType = {
    id?: true
    contactId?: true
  }

  export type ContactCustomFieldSumAggregateInputType = {
    id?: true
    contactId?: true
  }

  export type ContactCustomFieldMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    contactId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCustomFieldMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    contactId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCustomFieldCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    contactId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactCustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactCustomField to aggregate.
     */
    where?: ContactCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCustomFields to fetch.
     */
    orderBy?: ContactCustomFieldOrderByWithRelationInput | ContactCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactCustomFields
    **/
    _count?: true | ContactCustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactCustomFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactCustomFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactCustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactCustomFieldMaxAggregateInputType
  }

  export type GetContactCustomFieldAggregateType<T extends ContactCustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateContactCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactCustomField[P]>
      : GetScalarType<T[P], AggregateContactCustomField[P]>
  }




  export type ContactCustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactCustomFieldWhereInput
    orderBy?: ContactCustomFieldOrderByWithAggregationInput | ContactCustomFieldOrderByWithAggregationInput[]
    by: ContactCustomFieldScalarFieldEnum[] | ContactCustomFieldScalarFieldEnum
    having?: ContactCustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCustomFieldCountAggregateInputType | true
    _avg?: ContactCustomFieldAvgAggregateInputType
    _sum?: ContactCustomFieldSumAggregateInputType
    _min?: ContactCustomFieldMinAggregateInputType
    _max?: ContactCustomFieldMaxAggregateInputType
  }

  export type ContactCustomFieldGroupByOutputType = {
    id: number
    name: string
    value: string
    contactId: number
    createdAt: Date
    updatedAt: Date
    _count: ContactCustomFieldCountAggregateOutputType | null
    _avg: ContactCustomFieldAvgAggregateOutputType | null
    _sum: ContactCustomFieldSumAggregateOutputType | null
    _min: ContactCustomFieldMinAggregateOutputType | null
    _max: ContactCustomFieldMaxAggregateOutputType | null
  }

  type GetContactCustomFieldGroupByPayload<T extends ContactCustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactCustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactCustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactCustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], ContactCustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type ContactCustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    contactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactCustomField"]>


  export type ContactCustomFieldSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    contactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactCustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ContactCustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactCustomField"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      value: string
      contactId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactCustomField"]>
    composites: {}
  }

  type ContactCustomFieldGetPayload<S extends boolean | null | undefined | ContactCustomFieldDefaultArgs> = $Result.GetResult<Prisma.$ContactCustomFieldPayload, S>

  type ContactCustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactCustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ContactCustomFieldCountAggregateInputType | true
    }

  export interface ContactCustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactCustomField'], meta: { name: 'ContactCustomField' } }
    /**
     * Find zero or one ContactCustomField that matches the filter.
     * @param {ContactCustomFieldFindUniqueArgs} args - Arguments to find a ContactCustomField
     * @example
     * // Get one ContactCustomField
     * const contactCustomField = await prisma.contactCustomField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactCustomFieldFindUniqueArgs>(args: SelectSubset<T, ContactCustomFieldFindUniqueArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactCustomField that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactCustomFieldFindUniqueOrThrowArgs} args - Arguments to find a ContactCustomField
     * @example
     * // Get one ContactCustomField
     * const contactCustomField = await prisma.contactCustomField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactCustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactCustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactCustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldFindFirstArgs} args - Arguments to find a ContactCustomField
     * @example
     * // Get one ContactCustomField
     * const contactCustomField = await prisma.contactCustomField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactCustomFieldFindFirstArgs>(args?: SelectSubset<T, ContactCustomFieldFindFirstArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactCustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldFindFirstOrThrowArgs} args - Arguments to find a ContactCustomField
     * @example
     * // Get one ContactCustomField
     * const contactCustomField = await prisma.contactCustomField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactCustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactCustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactCustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactCustomFields
     * const contactCustomFields = await prisma.contactCustomField.findMany()
     * 
     * // Get first 10 ContactCustomFields
     * const contactCustomFields = await prisma.contactCustomField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactCustomFieldWithIdOnly = await prisma.contactCustomField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactCustomFieldFindManyArgs>(args?: SelectSubset<T, ContactCustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactCustomField.
     * @param {ContactCustomFieldCreateArgs} args - Arguments to create a ContactCustomField.
     * @example
     * // Create one ContactCustomField
     * const ContactCustomField = await prisma.contactCustomField.create({
     *   data: {
     *     // ... data to create a ContactCustomField
     *   }
     * })
     * 
     */
    create<T extends ContactCustomFieldCreateArgs>(args: SelectSubset<T, ContactCustomFieldCreateArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactCustomFields.
     * @param {ContactCustomFieldCreateManyArgs} args - Arguments to create many ContactCustomFields.
     * @example
     * // Create many ContactCustomFields
     * const contactCustomField = await prisma.contactCustomField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCustomFieldCreateManyArgs>(args?: SelectSubset<T, ContactCustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactCustomField.
     * @param {ContactCustomFieldDeleteArgs} args - Arguments to delete one ContactCustomField.
     * @example
     * // Delete one ContactCustomField
     * const ContactCustomField = await prisma.contactCustomField.delete({
     *   where: {
     *     // ... filter to delete one ContactCustomField
     *   }
     * })
     * 
     */
    delete<T extends ContactCustomFieldDeleteArgs>(args: SelectSubset<T, ContactCustomFieldDeleteArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactCustomField.
     * @param {ContactCustomFieldUpdateArgs} args - Arguments to update one ContactCustomField.
     * @example
     * // Update one ContactCustomField
     * const contactCustomField = await prisma.contactCustomField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactCustomFieldUpdateArgs>(args: SelectSubset<T, ContactCustomFieldUpdateArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactCustomFields.
     * @param {ContactCustomFieldDeleteManyArgs} args - Arguments to filter ContactCustomFields to delete.
     * @example
     * // Delete a few ContactCustomFields
     * const { count } = await prisma.contactCustomField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactCustomFieldDeleteManyArgs>(args?: SelectSubset<T, ContactCustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactCustomFields
     * const contactCustomField = await prisma.contactCustomField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactCustomFieldUpdateManyArgs>(args: SelectSubset<T, ContactCustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactCustomField.
     * @param {ContactCustomFieldUpsertArgs} args - Arguments to update or create a ContactCustomField.
     * @example
     * // Update or create a ContactCustomField
     * const contactCustomField = await prisma.contactCustomField.upsert({
     *   create: {
     *     // ... data to create a ContactCustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactCustomField we want to update
     *   }
     * })
     */
    upsert<T extends ContactCustomFieldUpsertArgs>(args: SelectSubset<T, ContactCustomFieldUpsertArgs<ExtArgs>>): Prisma__ContactCustomFieldClient<$Result.GetResult<Prisma.$ContactCustomFieldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldCountArgs} args - Arguments to filter ContactCustomFields to count.
     * @example
     * // Count the number of ContactCustomFields
     * const count = await prisma.contactCustomField.count({
     *   where: {
     *     // ... the filter for the ContactCustomFields we want to count
     *   }
     * })
    **/
    count<T extends ContactCustomFieldCountArgs>(
      args?: Subset<T, ContactCustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactCustomFieldAggregateArgs>(args: Subset<T, ContactCustomFieldAggregateArgs>): Prisma.PrismaPromise<GetContactCustomFieldAggregateType<T>>

    /**
     * Group by ContactCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactCustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactCustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: ContactCustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactCustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactCustomField model
   */
  readonly fields: ContactCustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactCustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactCustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactCustomField model
   */ 
  interface ContactCustomFieldFieldRefs {
    readonly id: FieldRef<"ContactCustomField", 'Int'>
    readonly name: FieldRef<"ContactCustomField", 'String'>
    readonly value: FieldRef<"ContactCustomField", 'String'>
    readonly contactId: FieldRef<"ContactCustomField", 'Int'>
    readonly createdAt: FieldRef<"ContactCustomField", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactCustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactCustomField findUnique
   */
  export type ContactCustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactCustomField to fetch.
     */
    where: ContactCustomFieldWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField findUniqueOrThrow
   */
  export type ContactCustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactCustomField to fetch.
     */
    where: ContactCustomFieldWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField findFirst
   */
  export type ContactCustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactCustomField to fetch.
     */
    where?: ContactCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCustomFields to fetch.
     */
    orderBy?: ContactCustomFieldOrderByWithRelationInput | ContactCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactCustomFields.
     */
    cursor?: ContactCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactCustomFields.
     */
    distinct?: ContactCustomFieldScalarFieldEnum | ContactCustomFieldScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField findFirstOrThrow
   */
  export type ContactCustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactCustomField to fetch.
     */
    where?: ContactCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCustomFields to fetch.
     */
    orderBy?: ContactCustomFieldOrderByWithRelationInput | ContactCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactCustomFields.
     */
    cursor?: ContactCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactCustomFields.
     */
    distinct?: ContactCustomFieldScalarFieldEnum | ContactCustomFieldScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField findMany
   */
  export type ContactCustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactCustomFields to fetch.
     */
    where?: ContactCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCustomFields to fetch.
     */
    orderBy?: ContactCustomFieldOrderByWithRelationInput | ContactCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactCustomFields.
     */
    cursor?: ContactCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCustomFields.
     */
    skip?: number
    distinct?: ContactCustomFieldScalarFieldEnum | ContactCustomFieldScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField create
   */
  export type ContactCustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactCustomField.
     */
    data: XOR<ContactCustomFieldCreateInput, ContactCustomFieldUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField createMany
   */
  export type ContactCustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactCustomFields.
     */
    data: ContactCustomFieldCreateManyInput | ContactCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactCustomField update
   */
  export type ContactCustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactCustomField.
     */
    data: XOR<ContactCustomFieldUpdateInput, ContactCustomFieldUncheckedUpdateInput>
    /**
     * Choose, which ContactCustomField to update.
     */
    where: ContactCustomFieldWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField updateMany
   */
  export type ContactCustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactCustomFields.
     */
    data: XOR<ContactCustomFieldUpdateManyMutationInput, ContactCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which ContactCustomFields to update
     */
    where?: ContactCustomFieldWhereInput
  }

  /**
   * ContactCustomField upsert
   */
  export type ContactCustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactCustomField to update in case it exists.
     */
    where: ContactCustomFieldWhereUniqueInput
    /**
     * In case the ContactCustomField found by the `where` argument doesn't exist, create a new ContactCustomField with this data.
     */
    create: XOR<ContactCustomFieldCreateInput, ContactCustomFieldUncheckedCreateInput>
    /**
     * In case the ContactCustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactCustomFieldUpdateInput, ContactCustomFieldUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField delete
   */
  export type ContactCustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
    /**
     * Filter which ContactCustomField to delete.
     */
    where: ContactCustomFieldWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactCustomField deleteMany
   */
  export type ContactCustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactCustomFields to delete
     */
    where?: ContactCustomFieldWhereInput
  }

  /**
   * ContactCustomField without action
   */
  export type ContactCustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCustomField
     */
    select?: ContactCustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model ContactList
   */

  export type AggregateContactList = {
    _count: ContactListCountAggregateOutputType | null
    _avg: ContactListAvgAggregateOutputType | null
    _sum: ContactListSumAggregateOutputType | null
    _min: ContactListMinAggregateOutputType | null
    _max: ContactListMaxAggregateOutputType | null
  }

  export type ContactListAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ContactListSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ContactListMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type ContactListMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type ContactListCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type ContactListAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ContactListSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ContactListMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ContactListMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type ContactListCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type ContactListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactList to aggregate.
     */
    where?: ContactListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactLists to fetch.
     */
    orderBy?: ContactListOrderByWithRelationInput | ContactListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactLists
    **/
    _count?: true | ContactListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactListMaxAggregateInputType
  }

  export type GetContactListAggregateType<T extends ContactListAggregateArgs> = {
        [P in keyof T & keyof AggregateContactList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactList[P]>
      : GetScalarType<T[P], AggregateContactList[P]>
  }




  export type ContactListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactListWhereInput
    orderBy?: ContactListOrderByWithAggregationInput | ContactListOrderByWithAggregationInput[]
    by: ContactListScalarFieldEnum[] | ContactListScalarFieldEnum
    having?: ContactListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactListCountAggregateInputType | true
    _avg?: ContactListAvgAggregateInputType
    _sum?: ContactListSumAggregateInputType
    _min?: ContactListMinAggregateInputType
    _max?: ContactListMaxAggregateInputType
  }

  export type ContactListGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    companyId: number
    _count: ContactListCountAggregateOutputType | null
    _avg: ContactListAvgAggregateOutputType | null
    _sum: ContactListSumAggregateOutputType | null
    _min: ContactListMinAggregateOutputType | null
    _max: ContactListMaxAggregateOutputType | null
  }

  type GetContactListGroupByPayload<T extends ContactListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactListGroupByOutputType[P]>
            : GetScalarType<T[P], ContactListGroupByOutputType[P]>
        }
      >
    >


  export type ContactListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | ContactList$itemsArgs<ExtArgs>
    Campaign?: boolean | ContactList$CampaignArgs<ExtArgs>
    _count?: boolean | ContactListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactList"]>


  export type ContactListSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type ContactListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | ContactList$itemsArgs<ExtArgs>
    Campaign?: boolean | ContactList$CampaignArgs<ExtArgs>
    _count?: boolean | ContactListCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactList"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      items: Prisma.$ContactListItemPayload<ExtArgs>[]
      Campaign: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
      companyId: number
    }, ExtArgs["result"]["contactList"]>
    composites: {}
  }

  type ContactListGetPayload<S extends boolean | null | undefined | ContactListDefaultArgs> = $Result.GetResult<Prisma.$ContactListPayload, S>

  type ContactListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactListFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ContactListCountAggregateInputType | true
    }

  export interface ContactListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactList'], meta: { name: 'ContactList' } }
    /**
     * Find zero or one ContactList that matches the filter.
     * @param {ContactListFindUniqueArgs} args - Arguments to find a ContactList
     * @example
     * // Get one ContactList
     * const contactList = await prisma.contactList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactListFindUniqueArgs>(args: SelectSubset<T, ContactListFindUniqueArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactListFindUniqueOrThrowArgs} args - Arguments to find a ContactList
     * @example
     * // Get one ContactList
     * const contactList = await prisma.contactList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactListFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListFindFirstArgs} args - Arguments to find a ContactList
     * @example
     * // Get one ContactList
     * const contactList = await prisma.contactList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactListFindFirstArgs>(args?: SelectSubset<T, ContactListFindFirstArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListFindFirstOrThrowArgs} args - Arguments to find a ContactList
     * @example
     * // Get one ContactList
     * const contactList = await prisma.contactList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactListFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactLists
     * const contactLists = await prisma.contactList.findMany()
     * 
     * // Get first 10 ContactLists
     * const contactLists = await prisma.contactList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactListWithIdOnly = await prisma.contactList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactListFindManyArgs>(args?: SelectSubset<T, ContactListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactList.
     * @param {ContactListCreateArgs} args - Arguments to create a ContactList.
     * @example
     * // Create one ContactList
     * const ContactList = await prisma.contactList.create({
     *   data: {
     *     // ... data to create a ContactList
     *   }
     * })
     * 
     */
    create<T extends ContactListCreateArgs>(args: SelectSubset<T, ContactListCreateArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactLists.
     * @param {ContactListCreateManyArgs} args - Arguments to create many ContactLists.
     * @example
     * // Create many ContactLists
     * const contactList = await prisma.contactList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactListCreateManyArgs>(args?: SelectSubset<T, ContactListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactList.
     * @param {ContactListDeleteArgs} args - Arguments to delete one ContactList.
     * @example
     * // Delete one ContactList
     * const ContactList = await prisma.contactList.delete({
     *   where: {
     *     // ... filter to delete one ContactList
     *   }
     * })
     * 
     */
    delete<T extends ContactListDeleteArgs>(args: SelectSubset<T, ContactListDeleteArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactList.
     * @param {ContactListUpdateArgs} args - Arguments to update one ContactList.
     * @example
     * // Update one ContactList
     * const contactList = await prisma.contactList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactListUpdateArgs>(args: SelectSubset<T, ContactListUpdateArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactLists.
     * @param {ContactListDeleteManyArgs} args - Arguments to filter ContactLists to delete.
     * @example
     * // Delete a few ContactLists
     * const { count } = await prisma.contactList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactListDeleteManyArgs>(args?: SelectSubset<T, ContactListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactLists
     * const contactList = await prisma.contactList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactListUpdateManyArgs>(args: SelectSubset<T, ContactListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactList.
     * @param {ContactListUpsertArgs} args - Arguments to update or create a ContactList.
     * @example
     * // Update or create a ContactList
     * const contactList = await prisma.contactList.upsert({
     *   create: {
     *     // ... data to create a ContactList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactList we want to update
     *   }
     * })
     */
    upsert<T extends ContactListUpsertArgs>(args: SelectSubset<T, ContactListUpsertArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListCountArgs} args - Arguments to filter ContactLists to count.
     * @example
     * // Count the number of ContactLists
     * const count = await prisma.contactList.count({
     *   where: {
     *     // ... the filter for the ContactLists we want to count
     *   }
     * })
    **/
    count<T extends ContactListCountArgs>(
      args?: Subset<T, ContactListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactListAggregateArgs>(args: Subset<T, ContactListAggregateArgs>): Prisma.PrismaPromise<GetContactListAggregateType<T>>

    /**
     * Group by ContactList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactListGroupByArgs['orderBy'] }
        : { orderBy?: ContactListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactList model
   */
  readonly fields: ContactListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends ContactList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ContactList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findMany"> | Null>
    Campaign<T extends ContactList$CampaignArgs<ExtArgs> = {}>(args?: Subset<T, ContactList$CampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactList model
   */ 
  interface ContactListFieldRefs {
    readonly id: FieldRef<"ContactList", 'Int'>
    readonly name: FieldRef<"ContactList", 'String'>
    readonly createdAt: FieldRef<"ContactList", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactList", 'DateTime'>
    readonly companyId: FieldRef<"ContactList", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContactList findUnique
   */
  export type ContactListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * Filter, which ContactList to fetch.
     */
    where: ContactListWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList findUniqueOrThrow
   */
  export type ContactListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * Filter, which ContactList to fetch.
     */
    where: ContactListWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList findFirst
   */
  export type ContactListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * Filter, which ContactList to fetch.
     */
    where?: ContactListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactLists to fetch.
     */
    orderBy?: ContactListOrderByWithRelationInput | ContactListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactLists.
     */
    cursor?: ContactListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactLists.
     */
    distinct?: ContactListScalarFieldEnum | ContactListScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList findFirstOrThrow
   */
  export type ContactListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * Filter, which ContactList to fetch.
     */
    where?: ContactListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactLists to fetch.
     */
    orderBy?: ContactListOrderByWithRelationInput | ContactListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactLists.
     */
    cursor?: ContactListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactLists.
     */
    distinct?: ContactListScalarFieldEnum | ContactListScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList findMany
   */
  export type ContactListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * Filter, which ContactLists to fetch.
     */
    where?: ContactListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactLists to fetch.
     */
    orderBy?: ContactListOrderByWithRelationInput | ContactListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactLists.
     */
    cursor?: ContactListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactLists.
     */
    skip?: number
    distinct?: ContactListScalarFieldEnum | ContactListScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList create
   */
  export type ContactListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactList.
     */
    data: XOR<ContactListCreateInput, ContactListUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList createMany
   */
  export type ContactListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactLists.
     */
    data: ContactListCreateManyInput | ContactListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactList update
   */
  export type ContactListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactList.
     */
    data: XOR<ContactListUpdateInput, ContactListUncheckedUpdateInput>
    /**
     * Choose, which ContactList to update.
     */
    where: ContactListWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList updateMany
   */
  export type ContactListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactLists.
     */
    data: XOR<ContactListUpdateManyMutationInput, ContactListUncheckedUpdateManyInput>
    /**
     * Filter which ContactLists to update
     */
    where?: ContactListWhereInput
  }

  /**
   * ContactList upsert
   */
  export type ContactListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactList to update in case it exists.
     */
    where: ContactListWhereUniqueInput
    /**
     * In case the ContactList found by the `where` argument doesn't exist, create a new ContactList with this data.
     */
    create: XOR<ContactListCreateInput, ContactListUncheckedCreateInput>
    /**
     * In case the ContactList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactListUpdateInput, ContactListUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList delete
   */
  export type ContactListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
    /**
     * Filter which ContactList to delete.
     */
    where: ContactListWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactList deleteMany
   */
  export type ContactListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactLists to delete
     */
    where?: ContactListWhereInput
  }

  /**
   * ContactList.items
   */
  export type ContactList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    where?: ContactListItemWhereInput
    orderBy?: ContactListItemOrderByWithRelationInput | ContactListItemOrderByWithRelationInput[]
    cursor?: ContactListItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactListItemScalarFieldEnum | ContactListItemScalarFieldEnum[]
  }

  /**
   * ContactList.Campaign
   */
  export type ContactList$CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * ContactList without action
   */
  export type ContactListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactList
     */
    select?: ContactListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListInclude<ExtArgs> | null
  }


  /**
   * Model ContactListItem
   */

  export type AggregateContactListItem = {
    _count: ContactListItemCountAggregateOutputType | null
    _avg: ContactListItemAvgAggregateOutputType | null
    _sum: ContactListItemSumAggregateOutputType | null
    _min: ContactListItemMinAggregateOutputType | null
    _max: ContactListItemMaxAggregateOutputType | null
  }

  export type ContactListItemAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    contactListId: number | null
  }

  export type ContactListItemSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    contactListId: number | null
  }

  export type ContactListItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    number: string | null
    email: string | null
    isWhatsappValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    contactListId: number | null
  }

  export type ContactListItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    number: string | null
    email: string | null
    isWhatsappValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    contactListId: number | null
  }

  export type ContactListItemCountAggregateOutputType = {
    id: number
    name: number
    number: number
    email: number
    isWhatsappValid: number
    createdAt: number
    updatedAt: number
    companyId: number
    contactListId: number
    _all: number
  }


  export type ContactListItemAvgAggregateInputType = {
    id?: true
    companyId?: true
    contactListId?: true
  }

  export type ContactListItemSumAggregateInputType = {
    id?: true
    companyId?: true
    contactListId?: true
  }

  export type ContactListItemMinAggregateInputType = {
    id?: true
    name?: true
    number?: true
    email?: true
    isWhatsappValid?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    contactListId?: true
  }

  export type ContactListItemMaxAggregateInputType = {
    id?: true
    name?: true
    number?: true
    email?: true
    isWhatsappValid?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    contactListId?: true
  }

  export type ContactListItemCountAggregateInputType = {
    id?: true
    name?: true
    number?: true
    email?: true
    isWhatsappValid?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    contactListId?: true
    _all?: true
  }

  export type ContactListItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactListItem to aggregate.
     */
    where?: ContactListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactListItems to fetch.
     */
    orderBy?: ContactListItemOrderByWithRelationInput | ContactListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactListItems
    **/
    _count?: true | ContactListItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactListItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactListItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactListItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactListItemMaxAggregateInputType
  }

  export type GetContactListItemAggregateType<T extends ContactListItemAggregateArgs> = {
        [P in keyof T & keyof AggregateContactListItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactListItem[P]>
      : GetScalarType<T[P], AggregateContactListItem[P]>
  }




  export type ContactListItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactListItemWhereInput
    orderBy?: ContactListItemOrderByWithAggregationInput | ContactListItemOrderByWithAggregationInput[]
    by: ContactListItemScalarFieldEnum[] | ContactListItemScalarFieldEnum
    having?: ContactListItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactListItemCountAggregateInputType | true
    _avg?: ContactListItemAvgAggregateInputType
    _sum?: ContactListItemSumAggregateInputType
    _min?: ContactListItemMinAggregateInputType
    _max?: ContactListItemMaxAggregateInputType
  }

  export type ContactListItemGroupByOutputType = {
    id: number
    name: string
    number: string
    email: string
    isWhatsappValid: boolean | null
    createdAt: Date
    updatedAt: Date
    companyId: number
    contactListId: number
    _count: ContactListItemCountAggregateOutputType | null
    _avg: ContactListItemAvgAggregateOutputType | null
    _sum: ContactListItemSumAggregateOutputType | null
    _min: ContactListItemMinAggregateOutputType | null
    _max: ContactListItemMaxAggregateOutputType | null
  }

  type GetContactListItemGroupByPayload<T extends ContactListItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactListItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactListItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactListItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContactListItemGroupByOutputType[P]>
        }
      >
    >


  export type ContactListItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    number?: boolean
    email?: boolean
    isWhatsappValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    contactListId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contactList?: boolean | ContactListDefaultArgs<ExtArgs>
    CampaignShipping?: boolean | ContactListItem$CampaignShippingArgs<ExtArgs>
    _count?: boolean | ContactListItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactListItem"]>


  export type ContactListItemSelectScalar = {
    id?: boolean
    name?: boolean
    number?: boolean
    email?: boolean
    isWhatsappValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    contactListId?: boolean
  }

  export type ContactListItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    contactList?: boolean | ContactListDefaultArgs<ExtArgs>
    CampaignShipping?: boolean | ContactListItem$CampaignShippingArgs<ExtArgs>
    _count?: boolean | ContactListItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactListItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactListItem"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      contactList: Prisma.$ContactListPayload<ExtArgs>
      CampaignShipping: Prisma.$CampaignShippingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      number: string
      email: string
      isWhatsappValid: boolean | null
      createdAt: Date
      updatedAt: Date
      companyId: number
      contactListId: number
    }, ExtArgs["result"]["contactListItem"]>
    composites: {}
  }

  type ContactListItemGetPayload<S extends boolean | null | undefined | ContactListItemDefaultArgs> = $Result.GetResult<Prisma.$ContactListItemPayload, S>

  type ContactListItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactListItemFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ContactListItemCountAggregateInputType | true
    }

  export interface ContactListItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactListItem'], meta: { name: 'ContactListItem' } }
    /**
     * Find zero or one ContactListItem that matches the filter.
     * @param {ContactListItemFindUniqueArgs} args - Arguments to find a ContactListItem
     * @example
     * // Get one ContactListItem
     * const contactListItem = await prisma.contactListItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactListItemFindUniqueArgs>(args: SelectSubset<T, ContactListItemFindUniqueArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactListItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactListItemFindUniqueOrThrowArgs} args - Arguments to find a ContactListItem
     * @example
     * // Get one ContactListItem
     * const contactListItem = await prisma.contactListItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactListItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactListItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactListItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemFindFirstArgs} args - Arguments to find a ContactListItem
     * @example
     * // Get one ContactListItem
     * const contactListItem = await prisma.contactListItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactListItemFindFirstArgs>(args?: SelectSubset<T, ContactListItemFindFirstArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactListItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemFindFirstOrThrowArgs} args - Arguments to find a ContactListItem
     * @example
     * // Get one ContactListItem
     * const contactListItem = await prisma.contactListItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactListItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactListItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactListItems
     * const contactListItems = await prisma.contactListItem.findMany()
     * 
     * // Get first 10 ContactListItems
     * const contactListItems = await prisma.contactListItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactListItemWithIdOnly = await prisma.contactListItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactListItemFindManyArgs>(args?: SelectSubset<T, ContactListItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactListItem.
     * @param {ContactListItemCreateArgs} args - Arguments to create a ContactListItem.
     * @example
     * // Create one ContactListItem
     * const ContactListItem = await prisma.contactListItem.create({
     *   data: {
     *     // ... data to create a ContactListItem
     *   }
     * })
     * 
     */
    create<T extends ContactListItemCreateArgs>(args: SelectSubset<T, ContactListItemCreateArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactListItems.
     * @param {ContactListItemCreateManyArgs} args - Arguments to create many ContactListItems.
     * @example
     * // Create many ContactListItems
     * const contactListItem = await prisma.contactListItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactListItemCreateManyArgs>(args?: SelectSubset<T, ContactListItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactListItem.
     * @param {ContactListItemDeleteArgs} args - Arguments to delete one ContactListItem.
     * @example
     * // Delete one ContactListItem
     * const ContactListItem = await prisma.contactListItem.delete({
     *   where: {
     *     // ... filter to delete one ContactListItem
     *   }
     * })
     * 
     */
    delete<T extends ContactListItemDeleteArgs>(args: SelectSubset<T, ContactListItemDeleteArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactListItem.
     * @param {ContactListItemUpdateArgs} args - Arguments to update one ContactListItem.
     * @example
     * // Update one ContactListItem
     * const contactListItem = await prisma.contactListItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactListItemUpdateArgs>(args: SelectSubset<T, ContactListItemUpdateArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactListItems.
     * @param {ContactListItemDeleteManyArgs} args - Arguments to filter ContactListItems to delete.
     * @example
     * // Delete a few ContactListItems
     * const { count } = await prisma.contactListItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactListItemDeleteManyArgs>(args?: SelectSubset<T, ContactListItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactListItems
     * const contactListItem = await prisma.contactListItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactListItemUpdateManyArgs>(args: SelectSubset<T, ContactListItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactListItem.
     * @param {ContactListItemUpsertArgs} args - Arguments to update or create a ContactListItem.
     * @example
     * // Update or create a ContactListItem
     * const contactListItem = await prisma.contactListItem.upsert({
     *   create: {
     *     // ... data to create a ContactListItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactListItem we want to update
     *   }
     * })
     */
    upsert<T extends ContactListItemUpsertArgs>(args: SelectSubset<T, ContactListItemUpsertArgs<ExtArgs>>): Prisma__ContactListItemClient<$Result.GetResult<Prisma.$ContactListItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemCountArgs} args - Arguments to filter ContactListItems to count.
     * @example
     * // Count the number of ContactListItems
     * const count = await prisma.contactListItem.count({
     *   where: {
     *     // ... the filter for the ContactListItems we want to count
     *   }
     * })
    **/
    count<T extends ContactListItemCountArgs>(
      args?: Subset<T, ContactListItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactListItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactListItemAggregateArgs>(args: Subset<T, ContactListItemAggregateArgs>): Prisma.PrismaPromise<GetContactListItemAggregateType<T>>

    /**
     * Group by ContactListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactListItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactListItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactListItemGroupByArgs['orderBy'] }
        : { orderBy?: ContactListItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactListItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactListItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactListItem model
   */
  readonly fields: ContactListItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactListItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactListItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contactList<T extends ContactListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactListDefaultArgs<ExtArgs>>): Prisma__ContactListClient<$Result.GetResult<Prisma.$ContactListPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CampaignShipping<T extends ContactListItem$CampaignShippingArgs<ExtArgs> = {}>(args?: Subset<T, ContactListItem$CampaignShippingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignShippingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactListItem model
   */ 
  interface ContactListItemFieldRefs {
    readonly id: FieldRef<"ContactListItem", 'Int'>
    readonly name: FieldRef<"ContactListItem", 'String'>
    readonly number: FieldRef<"ContactListItem", 'String'>
    readonly email: FieldRef<"ContactListItem", 'String'>
    readonly isWhatsappValid: FieldRef<"ContactListItem", 'Boolean'>
    readonly createdAt: FieldRef<"ContactListItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactListItem", 'DateTime'>
    readonly companyId: FieldRef<"ContactListItem", 'Int'>
    readonly contactListId: FieldRef<"ContactListItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContactListItem findUnique
   */
  export type ContactListItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactListItem to fetch.
     */
    where: ContactListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem findUniqueOrThrow
   */
  export type ContactListItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactListItem to fetch.
     */
    where: ContactListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem findFirst
   */
  export type ContactListItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactListItem to fetch.
     */
    where?: ContactListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactListItems to fetch.
     */
    orderBy?: ContactListItemOrderByWithRelationInput | ContactListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactListItems.
     */
    cursor?: ContactListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactListItems.
     */
    distinct?: ContactListItemScalarFieldEnum | ContactListItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem findFirstOrThrow
   */
  export type ContactListItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactListItem to fetch.
     */
    where?: ContactListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactListItems to fetch.
     */
    orderBy?: ContactListItemOrderByWithRelationInput | ContactListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactListItems.
     */
    cursor?: ContactListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactListItems.
     */
    distinct?: ContactListItemScalarFieldEnum | ContactListItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem findMany
   */
  export type ContactListItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * Filter, which ContactListItems to fetch.
     */
    where?: ContactListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactListItems to fetch.
     */
    orderBy?: ContactListItemOrderByWithRelationInput | ContactListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactListItems.
     */
    cursor?: ContactListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactListItems.
     */
    skip?: number
    distinct?: ContactListItemScalarFieldEnum | ContactListItemScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem create
   */
  export type ContactListItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactListItem.
     */
    data: XOR<ContactListItemCreateInput, ContactListItemUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem createMany
   */
  export type ContactListItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactListItems.
     */
    data: ContactListItemCreateManyInput | ContactListItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactListItem update
   */
  export type ContactListItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactListItem.
     */
    data: XOR<ContactListItemUpdateInput, ContactListItemUncheckedUpdateInput>
    /**
     * Choose, which ContactListItem to update.
     */
    where: ContactListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem updateMany
   */
  export type ContactListItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactListItems.
     */
    data: XOR<ContactListItemUpdateManyMutationInput, ContactListItemUncheckedUpdateManyInput>
    /**
     * Filter which ContactListItems to update
     */
    where?: ContactListItemWhereInput
  }

  /**
   * ContactListItem upsert
   */
  export type ContactListItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactListItem to update in case it exists.
     */
    where: ContactListItemWhereUniqueInput
    /**
     * In case the ContactListItem found by the `where` argument doesn't exist, create a new ContactListItem with this data.
     */
    create: XOR<ContactListItemCreateInput, ContactListItemUncheckedCreateInput>
    /**
     * In case the ContactListItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactListItemUpdateInput, ContactListItemUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem delete
   */
  export type ContactListItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
    /**
     * Filter which ContactListItem to delete.
     */
    where: ContactListItemWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactListItem deleteMany
   */
  export type ContactListItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactListItems to delete
     */
    where?: ContactListItemWhereInput
  }

  /**
   * ContactListItem.CampaignShipping
   */
  export type ContactListItem$CampaignShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignShipping
     */
    select?: CampaignShippingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignShippingInclude<ExtArgs> | null
    where?: CampaignShippingWhereInput
    orderBy?: CampaignShippingOrderByWithRelationInput | CampaignShippingOrderByWithRelationInput[]
    cursor?: CampaignShippingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignShippingScalarFieldEnum | CampaignShippingScalarFieldEnum[]
  }

  /**
   * ContactListItem without action
   */
  export type ContactListItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactListItem
     */
    select?: ContactListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactListItemInclude<ExtArgs> | null
  }


  /**
   * Model Files
   */

  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type FilesSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type FilesMinAggregateOutputType = {
    id: number | null
    name: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type FilesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    name: number
    message: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type FilesSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    name?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    name?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    name?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type FilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to aggregate.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type FilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesWhereInput
    orderBy?: FilesOrderByWithAggregationInput | FilesOrderByWithAggregationInput[]
    by: FilesScalarFieldEnum[] | FilesScalarFieldEnum
    having?: FilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }

  export type FilesGroupByOutputType = {
    id: number
    name: string
    message: string
    createdAt: Date
    updatedAt: Date
    companyId: number
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends FilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type FilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    options?: boolean | Files$optionsArgs<ExtArgs>
    Campaign?: boolean | Files$CampaignArgs<ExtArgs>
    _count?: boolean | FilesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["files"]>


  export type FilesSelectScalar = {
    id?: boolean
    name?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type FilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    options?: boolean | Files$optionsArgs<ExtArgs>
    Campaign?: boolean | Files$CampaignArgs<ExtArgs>
    _count?: boolean | FilesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Files"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      options: Prisma.$FilesOptionsPayload<ExtArgs>[]
      Campaign: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      message: string
      createdAt: Date
      updatedAt: Date
      companyId: number
    }, ExtArgs["result"]["files"]>
    composites: {}
  }

  type FilesGetPayload<S extends boolean | null | undefined | FilesDefaultArgs> = $Result.GetResult<Prisma.$FilesPayload, S>

  type FilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FilesFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: FilesCountAggregateInputType | true
    }

  export interface FilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Files'], meta: { name: 'Files' } }
    /**
     * Find zero or one Files that matches the filter.
     * @param {FilesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilesFindUniqueArgs>(args: SelectSubset<T, FilesFindUniqueArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Files that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FilesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilesFindUniqueOrThrowArgs>(args: SelectSubset<T, FilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilesFindFirstArgs>(args?: SelectSubset<T, FilesFindFirstArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Files that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilesFindFirstOrThrowArgs>(args?: SelectSubset<T, FilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilesFindManyArgs>(args?: SelectSubset<T, FilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Files.
     * @param {FilesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
     */
    create<T extends FilesCreateArgs>(args: SelectSubset<T, FilesCreateArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files.
     * @param {FilesCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const files = await prisma.files.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilesCreateManyArgs>(args?: SelectSubset<T, FilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {FilesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
     */
    delete<T extends FilesDeleteArgs>(args: SelectSubset<T, FilesDeleteArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Files.
     * @param {FilesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilesUpdateArgs>(args: SelectSubset<T, FilesUpdateArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {FilesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilesDeleteManyArgs>(args?: SelectSubset<T, FilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilesUpdateManyArgs>(args: SelectSubset<T, FilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {FilesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
     */
    upsert<T extends FilesUpsertArgs>(args: SelectSubset<T, FilesUpsertArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FilesCountArgs>(
      args?: Subset<T, FilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): Prisma.PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilesGroupByArgs['orderBy'] }
        : { orderBy?: FilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Files model
   */
  readonly fields: FilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    options<T extends Files$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Files$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "findMany"> | Null>
    Campaign<T extends Files$CampaignArgs<ExtArgs> = {}>(args?: Subset<T, Files$CampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Files model
   */ 
  interface FilesFieldRefs {
    readonly id: FieldRef<"Files", 'Int'>
    readonly name: FieldRef<"Files", 'String'>
    readonly message: FieldRef<"Files", 'String'>
    readonly createdAt: FieldRef<"Files", 'DateTime'>
    readonly updatedAt: FieldRef<"Files", 'DateTime'>
    readonly companyId: FieldRef<"Files", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Files findUnique
   */
  export type FilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where: FilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files findUniqueOrThrow
   */
  export type FilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where: FilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files findFirst
   */
  export type FilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files findFirstOrThrow
   */
  export type FilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files findMany
   */
  export type FilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FilesOrderByWithRelationInput | FilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files create
   */
  export type FilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * The data needed to create a Files.
     */
    data: XOR<FilesCreateInput, FilesUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files createMany
   */
  export type FilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FilesCreateManyInput | FilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Files update
   */
  export type FilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * The data needed to update a Files.
     */
    data: XOR<FilesUpdateInput, FilesUncheckedUpdateInput>
    /**
     * Choose, which Files to update.
     */
    where: FilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files updateMany
   */
  export type FilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FilesWhereInput
  }

  /**
   * Files upsert
   */
  export type FilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * The filter to search for the Files to update in case it exists.
     */
    where: FilesWhereUniqueInput
    /**
     * In case the Files found by the `where` argument doesn't exist, create a new Files with this data.
     */
    create: XOR<FilesCreateInput, FilesUncheckedCreateInput>
    /**
     * In case the Files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilesUpdateInput, FilesUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files delete
   */
  export type FilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
    /**
     * Filter which Files to delete.
     */
    where: FilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Files deleteMany
   */
  export type FilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FilesWhereInput
  }

  /**
   * Files.options
   */
  export type Files$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    where?: FilesOptionsWhereInput
    orderBy?: FilesOptionsOrderByWithRelationInput | FilesOptionsOrderByWithRelationInput[]
    cursor?: FilesOptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilesOptionsScalarFieldEnum | FilesOptionsScalarFieldEnum[]
  }

  /**
   * Files.Campaign
   */
  export type Files$CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Files without action
   */
  export type FilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Files
     */
    select?: FilesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesInclude<ExtArgs> | null
  }


  /**
   * Model FilesOptions
   */

  export type AggregateFilesOptions = {
    _count: FilesOptionsCountAggregateOutputType | null
    _avg: FilesOptionsAvgAggregateOutputType | null
    _sum: FilesOptionsSumAggregateOutputType | null
    _min: FilesOptionsMinAggregateOutputType | null
    _max: FilesOptionsMaxAggregateOutputType | null
  }

  export type FilesOptionsAvgAggregateOutputType = {
    id: number | null
    fileId: number | null
  }

  export type FilesOptionsSumAggregateOutputType = {
    id: number | null
    fileId: number | null
  }

  export type FilesOptionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    mediaType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileId: number | null
  }

  export type FilesOptionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    path: string | null
    mediaType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fileId: number | null
  }

  export type FilesOptionsCountAggregateOutputType = {
    id: number
    name: number
    path: number
    mediaType: number
    createdAt: number
    updatedAt: number
    fileId: number
    _all: number
  }


  export type FilesOptionsAvgAggregateInputType = {
    id?: true
    fileId?: true
  }

  export type FilesOptionsSumAggregateInputType = {
    id?: true
    fileId?: true
  }

  export type FilesOptionsMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
    fileId?: true
  }

  export type FilesOptionsMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
    fileId?: true
  }

  export type FilesOptionsCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
    fileId?: true
    _all?: true
  }

  export type FilesOptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilesOptions to aggregate.
     */
    where?: FilesOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilesOptions to fetch.
     */
    orderBy?: FilesOptionsOrderByWithRelationInput | FilesOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilesOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilesOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilesOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilesOptions
    **/
    _count?: true | FilesOptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesOptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesOptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesOptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesOptionsMaxAggregateInputType
  }

  export type GetFilesOptionsAggregateType<T extends FilesOptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateFilesOptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilesOptions[P]>
      : GetScalarType<T[P], AggregateFilesOptions[P]>
  }




  export type FilesOptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilesOptionsWhereInput
    orderBy?: FilesOptionsOrderByWithAggregationInput | FilesOptionsOrderByWithAggregationInput[]
    by: FilesOptionsScalarFieldEnum[] | FilesOptionsScalarFieldEnum
    having?: FilesOptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesOptionsCountAggregateInputType | true
    _avg?: FilesOptionsAvgAggregateInputType
    _sum?: FilesOptionsSumAggregateInputType
    _min?: FilesOptionsMinAggregateInputType
    _max?: FilesOptionsMaxAggregateInputType
  }

  export type FilesOptionsGroupByOutputType = {
    id: number
    name: string
    path: string
    mediaType: string
    createdAt: Date
    updatedAt: Date
    fileId: number
    _count: FilesOptionsCountAggregateOutputType | null
    _avg: FilesOptionsAvgAggregateOutputType | null
    _sum: FilesOptionsSumAggregateOutputType | null
    _min: FilesOptionsMinAggregateOutputType | null
    _max: FilesOptionsMaxAggregateOutputType | null
  }

  type GetFilesOptionsGroupByPayload<T extends FilesOptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilesOptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesOptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesOptionsGroupByOutputType[P]>
            : GetScalarType<T[P], FilesOptionsGroupByOutputType[P]>
        }
      >
    >


  export type FilesOptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileId?: boolean
    file?: boolean | FilesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filesOptions"]>


  export type FilesOptionsSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileId?: boolean
  }

  export type FilesOptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FilesDefaultArgs<ExtArgs>
  }

  export type $FilesOptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilesOptions"
    objects: {
      file: Prisma.$FilesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      path: string
      mediaType: string
      createdAt: Date
      updatedAt: Date
      fileId: number
    }, ExtArgs["result"]["filesOptions"]>
    composites: {}
  }

  type FilesOptionsGetPayload<S extends boolean | null | undefined | FilesOptionsDefaultArgs> = $Result.GetResult<Prisma.$FilesOptionsPayload, S>

  type FilesOptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FilesOptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: FilesOptionsCountAggregateInputType | true
    }

  export interface FilesOptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilesOptions'], meta: { name: 'FilesOptions' } }
    /**
     * Find zero or one FilesOptions that matches the filter.
     * @param {FilesOptionsFindUniqueArgs} args - Arguments to find a FilesOptions
     * @example
     * // Get one FilesOptions
     * const filesOptions = await prisma.filesOptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilesOptionsFindUniqueArgs>(args: SelectSubset<T, FilesOptionsFindUniqueArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FilesOptions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FilesOptionsFindUniqueOrThrowArgs} args - Arguments to find a FilesOptions
     * @example
     * // Get one FilesOptions
     * const filesOptions = await prisma.filesOptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilesOptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, FilesOptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FilesOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsFindFirstArgs} args - Arguments to find a FilesOptions
     * @example
     * // Get one FilesOptions
     * const filesOptions = await prisma.filesOptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilesOptionsFindFirstArgs>(args?: SelectSubset<T, FilesOptionsFindFirstArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FilesOptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsFindFirstOrThrowArgs} args - Arguments to find a FilesOptions
     * @example
     * // Get one FilesOptions
     * const filesOptions = await prisma.filesOptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilesOptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, FilesOptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FilesOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilesOptions
     * const filesOptions = await prisma.filesOptions.findMany()
     * 
     * // Get first 10 FilesOptions
     * const filesOptions = await prisma.filesOptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesOptionsWithIdOnly = await prisma.filesOptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilesOptionsFindManyArgs>(args?: SelectSubset<T, FilesOptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FilesOptions.
     * @param {FilesOptionsCreateArgs} args - Arguments to create a FilesOptions.
     * @example
     * // Create one FilesOptions
     * const FilesOptions = await prisma.filesOptions.create({
     *   data: {
     *     // ... data to create a FilesOptions
     *   }
     * })
     * 
     */
    create<T extends FilesOptionsCreateArgs>(args: SelectSubset<T, FilesOptionsCreateArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FilesOptions.
     * @param {FilesOptionsCreateManyArgs} args - Arguments to create many FilesOptions.
     * @example
     * // Create many FilesOptions
     * const filesOptions = await prisma.filesOptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilesOptionsCreateManyArgs>(args?: SelectSubset<T, FilesOptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FilesOptions.
     * @param {FilesOptionsDeleteArgs} args - Arguments to delete one FilesOptions.
     * @example
     * // Delete one FilesOptions
     * const FilesOptions = await prisma.filesOptions.delete({
     *   where: {
     *     // ... filter to delete one FilesOptions
     *   }
     * })
     * 
     */
    delete<T extends FilesOptionsDeleteArgs>(args: SelectSubset<T, FilesOptionsDeleteArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FilesOptions.
     * @param {FilesOptionsUpdateArgs} args - Arguments to update one FilesOptions.
     * @example
     * // Update one FilesOptions
     * const filesOptions = await prisma.filesOptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilesOptionsUpdateArgs>(args: SelectSubset<T, FilesOptionsUpdateArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FilesOptions.
     * @param {FilesOptionsDeleteManyArgs} args - Arguments to filter FilesOptions to delete.
     * @example
     * // Delete a few FilesOptions
     * const { count } = await prisma.filesOptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilesOptionsDeleteManyArgs>(args?: SelectSubset<T, FilesOptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilesOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilesOptions
     * const filesOptions = await prisma.filesOptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilesOptionsUpdateManyArgs>(args: SelectSubset<T, FilesOptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FilesOptions.
     * @param {FilesOptionsUpsertArgs} args - Arguments to update or create a FilesOptions.
     * @example
     * // Update or create a FilesOptions
     * const filesOptions = await prisma.filesOptions.upsert({
     *   create: {
     *     // ... data to create a FilesOptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilesOptions we want to update
     *   }
     * })
     */
    upsert<T extends FilesOptionsUpsertArgs>(args: SelectSubset<T, FilesOptionsUpsertArgs<ExtArgs>>): Prisma__FilesOptionsClient<$Result.GetResult<Prisma.$FilesOptionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FilesOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsCountArgs} args - Arguments to filter FilesOptions to count.
     * @example
     * // Count the number of FilesOptions
     * const count = await prisma.filesOptions.count({
     *   where: {
     *     // ... the filter for the FilesOptions we want to count
     *   }
     * })
    **/
    count<T extends FilesOptionsCountArgs>(
      args?: Subset<T, FilesOptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesOptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilesOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesOptionsAggregateArgs>(args: Subset<T, FilesOptionsAggregateArgs>): Prisma.PrismaPromise<GetFilesOptionsAggregateType<T>>

    /**
     * Group by FilesOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesOptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilesOptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilesOptionsGroupByArgs['orderBy'] }
        : { orderBy?: FilesOptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilesOptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesOptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilesOptions model
   */
  readonly fields: FilesOptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilesOptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilesOptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FilesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilesDefaultArgs<ExtArgs>>): Prisma__FilesClient<$Result.GetResult<Prisma.$FilesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilesOptions model
   */ 
  interface FilesOptionsFieldRefs {
    readonly id: FieldRef<"FilesOptions", 'Int'>
    readonly name: FieldRef<"FilesOptions", 'String'>
    readonly path: FieldRef<"FilesOptions", 'String'>
    readonly mediaType: FieldRef<"FilesOptions", 'String'>
    readonly createdAt: FieldRef<"FilesOptions", 'DateTime'>
    readonly updatedAt: FieldRef<"FilesOptions", 'DateTime'>
    readonly fileId: FieldRef<"FilesOptions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FilesOptions findUnique
   */
  export type FilesOptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * Filter, which FilesOptions to fetch.
     */
    where: FilesOptionsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions findUniqueOrThrow
   */
  export type FilesOptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * Filter, which FilesOptions to fetch.
     */
    where: FilesOptionsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions findFirst
   */
  export type FilesOptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * Filter, which FilesOptions to fetch.
     */
    where?: FilesOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilesOptions to fetch.
     */
    orderBy?: FilesOptionsOrderByWithRelationInput | FilesOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilesOptions.
     */
    cursor?: FilesOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilesOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilesOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilesOptions.
     */
    distinct?: FilesOptionsScalarFieldEnum | FilesOptionsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions findFirstOrThrow
   */
  export type FilesOptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * Filter, which FilesOptions to fetch.
     */
    where?: FilesOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilesOptions to fetch.
     */
    orderBy?: FilesOptionsOrderByWithRelationInput | FilesOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilesOptions.
     */
    cursor?: FilesOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilesOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilesOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilesOptions.
     */
    distinct?: FilesOptionsScalarFieldEnum | FilesOptionsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions findMany
   */
  export type FilesOptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * Filter, which FilesOptions to fetch.
     */
    where?: FilesOptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilesOptions to fetch.
     */
    orderBy?: FilesOptionsOrderByWithRelationInput | FilesOptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilesOptions.
     */
    cursor?: FilesOptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilesOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilesOptions.
     */
    skip?: number
    distinct?: FilesOptionsScalarFieldEnum | FilesOptionsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions create
   */
  export type FilesOptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a FilesOptions.
     */
    data: XOR<FilesOptionsCreateInput, FilesOptionsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions createMany
   */
  export type FilesOptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilesOptions.
     */
    data: FilesOptionsCreateManyInput | FilesOptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilesOptions update
   */
  export type FilesOptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a FilesOptions.
     */
    data: XOR<FilesOptionsUpdateInput, FilesOptionsUncheckedUpdateInput>
    /**
     * Choose, which FilesOptions to update.
     */
    where: FilesOptionsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions updateMany
   */
  export type FilesOptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilesOptions.
     */
    data: XOR<FilesOptionsUpdateManyMutationInput, FilesOptionsUncheckedUpdateManyInput>
    /**
     * Filter which FilesOptions to update
     */
    where?: FilesOptionsWhereInput
  }

  /**
   * FilesOptions upsert
   */
  export type FilesOptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the FilesOptions to update in case it exists.
     */
    where: FilesOptionsWhereUniqueInput
    /**
     * In case the FilesOptions found by the `where` argument doesn't exist, create a new FilesOptions with this data.
     */
    create: XOR<FilesOptionsCreateInput, FilesOptionsUncheckedCreateInput>
    /**
     * In case the FilesOptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilesOptionsUpdateInput, FilesOptionsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions delete
   */
  export type FilesOptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
    /**
     * Filter which FilesOptions to delete.
     */
    where: FilesOptionsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FilesOptions deleteMany
   */
  export type FilesOptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilesOptions to delete
     */
    where?: FilesOptionsWhereInput
  }

  /**
   * FilesOptions without action
   */
  export type FilesOptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilesOptions
     */
    select?: FilesOptionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilesOptionsInclude<ExtArgs> | null
  }


  /**
   * Model Help
   */

  export type AggregateHelp = {
    _count: HelpCountAggregateOutputType | null
    _avg: HelpAvgAggregateOutputType | null
    _sum: HelpSumAggregateOutputType | null
    _min: HelpMinAggregateOutputType | null
    _max: HelpMaxAggregateOutputType | null
  }

  export type HelpAvgAggregateOutputType = {
    id: number | null
  }

  export type HelpSumAggregateOutputType = {
    id: number | null
  }

  export type HelpMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    video: string | null
    link: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    video: string | null
    link: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCountAggregateOutputType = {
    id: number
    title: number
    description: number
    video: number
    link: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpAvgAggregateInputType = {
    id?: true
  }

  export type HelpSumAggregateInputType = {
    id?: true
  }

  export type HelpMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    video?: true
    link?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    video?: true
    link?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    video?: true
    link?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Help to aggregate.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Helps
    **/
    _count?: true | HelpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpMaxAggregateInputType
  }

  export type GetHelpAggregateType<T extends HelpAggregateArgs> = {
        [P in keyof T & keyof AggregateHelp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelp[P]>
      : GetScalarType<T[P], AggregateHelp[P]>
  }




  export type HelpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpWhereInput
    orderBy?: HelpOrderByWithAggregationInput | HelpOrderByWithAggregationInput[]
    by: HelpScalarFieldEnum[] | HelpScalarFieldEnum
    having?: HelpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCountAggregateInputType | true
    _avg?: HelpAvgAggregateInputType
    _sum?: HelpSumAggregateInputType
    _min?: HelpMinAggregateInputType
    _max?: HelpMaxAggregateInputType
  }

  export type HelpGroupByOutputType = {
    id: number
    title: string
    description: string
    video: string
    link: string
    createdAt: Date
    updatedAt: Date
    _count: HelpCountAggregateOutputType | null
    _avg: HelpAvgAggregateOutputType | null
    _sum: HelpSumAggregateOutputType | null
    _min: HelpMinAggregateOutputType | null
    _max: HelpMaxAggregateOutputType | null
  }

  type GetHelpGroupByPayload<T extends HelpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpGroupByOutputType[P]>
            : GetScalarType<T[P], HelpGroupByOutputType[P]>
        }
      >
    >


  export type HelpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    video?: boolean
    link?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["help"]>


  export type HelpSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    video?: boolean
    link?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $HelpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Help"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      video: string
      link: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["help"]>
    composites: {}
  }

  type HelpGetPayload<S extends boolean | null | undefined | HelpDefaultArgs> = $Result.GetResult<Prisma.$HelpPayload, S>

  type HelpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: HelpCountAggregateInputType | true
    }

  export interface HelpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Help'], meta: { name: 'Help' } }
    /**
     * Find zero or one Help that matches the filter.
     * @param {HelpFindUniqueArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpFindUniqueArgs>(args: SelectSubset<T, HelpFindUniqueArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Help that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpFindUniqueOrThrowArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Help that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpFindFirstArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpFindFirstArgs>(args?: SelectSubset<T, HelpFindFirstArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Help that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpFindFirstOrThrowArgs} args - Arguments to find a Help
     * @example
     * // Get one Help
     * const help = await prisma.help.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Helps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Helps
     * const helps = await prisma.help.findMany()
     * 
     * // Get first 10 Helps
     * const helps = await prisma.help.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpWithIdOnly = await prisma.help.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpFindManyArgs>(args?: SelectSubset<T, HelpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Help.
     * @param {HelpCreateArgs} args - Arguments to create a Help.
     * @example
     * // Create one Help
     * const Help = await prisma.help.create({
     *   data: {
     *     // ... data to create a Help
     *   }
     * })
     * 
     */
    create<T extends HelpCreateArgs>(args: SelectSubset<T, HelpCreateArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Helps.
     * @param {HelpCreateManyArgs} args - Arguments to create many Helps.
     * @example
     * // Create many Helps
     * const help = await prisma.help.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCreateManyArgs>(args?: SelectSubset<T, HelpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Help.
     * @param {HelpDeleteArgs} args - Arguments to delete one Help.
     * @example
     * // Delete one Help
     * const Help = await prisma.help.delete({
     *   where: {
     *     // ... filter to delete one Help
     *   }
     * })
     * 
     */
    delete<T extends HelpDeleteArgs>(args: SelectSubset<T, HelpDeleteArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Help.
     * @param {HelpUpdateArgs} args - Arguments to update one Help.
     * @example
     * // Update one Help
     * const help = await prisma.help.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpUpdateArgs>(args: SelectSubset<T, HelpUpdateArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Helps.
     * @param {HelpDeleteManyArgs} args - Arguments to filter Helps to delete.
     * @example
     * // Delete a few Helps
     * const { count } = await prisma.help.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpDeleteManyArgs>(args?: SelectSubset<T, HelpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Helps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Helps
     * const help = await prisma.help.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpUpdateManyArgs>(args: SelectSubset<T, HelpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Help.
     * @param {HelpUpsertArgs} args - Arguments to update or create a Help.
     * @example
     * // Update or create a Help
     * const help = await prisma.help.upsert({
     *   create: {
     *     // ... data to create a Help
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Help we want to update
     *   }
     * })
     */
    upsert<T extends HelpUpsertArgs>(args: SelectSubset<T, HelpUpsertArgs<ExtArgs>>): Prisma__HelpClient<$Result.GetResult<Prisma.$HelpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Helps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCountArgs} args - Arguments to filter Helps to count.
     * @example
     * // Count the number of Helps
     * const count = await prisma.help.count({
     *   where: {
     *     // ... the filter for the Helps we want to count
     *   }
     * })
    **/
    count<T extends HelpCountArgs>(
      args?: Subset<T, HelpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Help.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpAggregateArgs>(args: Subset<T, HelpAggregateArgs>): Prisma.PrismaPromise<GetHelpAggregateType<T>>

    /**
     * Group by Help.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpGroupByArgs['orderBy'] }
        : { orderBy?: HelpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Help model
   */
  readonly fields: HelpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Help.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Help model
   */ 
  interface HelpFieldRefs {
    readonly id: FieldRef<"Help", 'Int'>
    readonly title: FieldRef<"Help", 'String'>
    readonly description: FieldRef<"Help", 'String'>
    readonly video: FieldRef<"Help", 'String'>
    readonly link: FieldRef<"Help", 'String'>
    readonly createdAt: FieldRef<"Help", 'DateTime'>
    readonly updatedAt: FieldRef<"Help", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Help findUnique
   */
  export type HelpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where: HelpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help findUniqueOrThrow
   */
  export type HelpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where: HelpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help findFirst
   */
  export type HelpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helps.
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helps.
     */
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help findFirstOrThrow
   */
  export type HelpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Filter, which Help to fetch.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Helps.
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Helps.
     */
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help findMany
   */
  export type HelpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Filter, which Helps to fetch.
     */
    where?: HelpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Helps to fetch.
     */
    orderBy?: HelpOrderByWithRelationInput | HelpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Helps.
     */
    cursor?: HelpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Helps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Helps.
     */
    skip?: number
    distinct?: HelpScalarFieldEnum | HelpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help create
   */
  export type HelpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * The data needed to create a Help.
     */
    data: XOR<HelpCreateInput, HelpUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help createMany
   */
  export type HelpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Helps.
     */
    data: HelpCreateManyInput | HelpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Help update
   */
  export type HelpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * The data needed to update a Help.
     */
    data: XOR<HelpUpdateInput, HelpUncheckedUpdateInput>
    /**
     * Choose, which Help to update.
     */
    where: HelpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help updateMany
   */
  export type HelpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Helps.
     */
    data: XOR<HelpUpdateManyMutationInput, HelpUncheckedUpdateManyInput>
    /**
     * Filter which Helps to update
     */
    where?: HelpWhereInput
  }

  /**
   * Help upsert
   */
  export type HelpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * The filter to search for the Help to update in case it exists.
     */
    where: HelpWhereUniqueInput
    /**
     * In case the Help found by the `where` argument doesn't exist, create a new Help with this data.
     */
    create: XOR<HelpCreateInput, HelpUncheckedCreateInput>
    /**
     * In case the Help was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpUpdateInput, HelpUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help delete
   */
  export type HelpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
    /**
     * Filter which Help to delete.
     */
    where: HelpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Help deleteMany
   */
  export type HelpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Helps to delete
     */
    where?: HelpWhereInput
  }

  /**
   * Help without action
   */
  export type HelpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Help
     */
    select?: HelpSelect<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    value: number | null
    companyId: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    value: number | null
    companyId: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    detail: string | null
    status: string | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: string | null
    companyId: number | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    detail: string | null
    status: string | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
    dueDate: string | null
    companyId: number | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    detail: number
    status: number
    value: number
    createdAt: number
    updatedAt: number
    dueDate: number
    companyId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    value?: true
    companyId?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    value?: true
    companyId?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    detail?: true
    status?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    companyId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    detail?: true
    status?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    companyId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    detail?: true
    status?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    dueDate?: true
    companyId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    detail: string
    status: string
    value: number
    createdAt: Date
    updatedAt: Date
    dueDate: string
    companyId: number
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    detail?: boolean
    status?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    companyId?: boolean
  }, ExtArgs["result"]["invoice"]>


  export type InvoiceSelectScalar = {
    id?: boolean
    detail?: boolean
    status?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dueDate?: boolean
    companyId?: boolean
  }


  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      detail: string
      status: string
      value: number
      createdAt: Date
      updatedAt: Date
      dueDate: string
      companyId: number
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly detail: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly value: FieldRef<"Invoice", 'Float'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'String'>
    readonly companyId: FieldRef<"Invoice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
  }


  /**
   * Model System_Logs
   */

  export type AggregateSystem_Logs = {
    _count: System_LogsCountAggregateOutputType | null
    _avg: System_LogsAvgAggregateOutputType | null
    _sum: System_LogsSumAggregateOutputType | null
    _min: System_LogsMinAggregateOutputType | null
    _max: System_LogsMaxAggregateOutputType | null
  }

  export type System_LogsAvgAggregateOutputType = {
    id: number | null
    actionLogId: number | null
  }

  export type System_LogsSumAggregateOutputType = {
    id: number | null
    actionLogId: number | null
  }

  export type System_LogsMinAggregateOutputType = {
    id: number | null
    level: string | null
    message: string | null
    createdAt: Date | null
    actionLogId: number | null
  }

  export type System_LogsMaxAggregateOutputType = {
    id: number | null
    level: string | null
    message: string | null
    createdAt: Date | null
    actionLogId: number | null
  }

  export type System_LogsCountAggregateOutputType = {
    id: number
    level: number
    message: number
    createdAt: number
    actionLogId: number
    _all: number
  }


  export type System_LogsAvgAggregateInputType = {
    id?: true
    actionLogId?: true
  }

  export type System_LogsSumAggregateInputType = {
    id?: true
    actionLogId?: true
  }

  export type System_LogsMinAggregateInputType = {
    id?: true
    level?: true
    message?: true
    createdAt?: true
    actionLogId?: true
  }

  export type System_LogsMaxAggregateInputType = {
    id?: true
    level?: true
    message?: true
    createdAt?: true
    actionLogId?: true
  }

  export type System_LogsCountAggregateInputType = {
    id?: true
    level?: true
    message?: true
    createdAt?: true
    actionLogId?: true
    _all?: true
  }

  export type System_LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which System_Logs to aggregate.
     */
    where?: System_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of System_Logs to fetch.
     */
    orderBy?: System_LogsOrderByWithRelationInput | System_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: System_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` System_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` System_Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned System_Logs
    **/
    _count?: true | System_LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: System_LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: System_LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: System_LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: System_LogsMaxAggregateInputType
  }

  export type GetSystem_LogsAggregateType<T extends System_LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystem_Logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystem_Logs[P]>
      : GetScalarType<T[P], AggregateSystem_Logs[P]>
  }




  export type System_LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: System_LogsWhereInput
    orderBy?: System_LogsOrderByWithAggregationInput | System_LogsOrderByWithAggregationInput[]
    by: System_LogsScalarFieldEnum[] | System_LogsScalarFieldEnum
    having?: System_LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: System_LogsCountAggregateInputType | true
    _avg?: System_LogsAvgAggregateInputType
    _sum?: System_LogsSumAggregateInputType
    _min?: System_LogsMinAggregateInputType
    _max?: System_LogsMaxAggregateInputType
  }

  export type System_LogsGroupByOutputType = {
    id: number
    level: string
    message: string
    createdAt: Date
    actionLogId: number | null
    _count: System_LogsCountAggregateOutputType | null
    _avg: System_LogsAvgAggregateOutputType | null
    _sum: System_LogsSumAggregateOutputType | null
    _min: System_LogsMinAggregateOutputType | null
    _max: System_LogsMaxAggregateOutputType | null
  }

  type GetSystem_LogsGroupByPayload<T extends System_LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<System_LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof System_LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], System_LogsGroupByOutputType[P]>
            : GetScalarType<T[P], System_LogsGroupByOutputType[P]>
        }
      >
    >


  export type System_LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    message?: boolean
    createdAt?: boolean
    actionLogId?: boolean
    actionLog?: boolean | System_Logs$actionLogArgs<ExtArgs>
  }, ExtArgs["result"]["system_Logs"]>


  export type System_LogsSelectScalar = {
    id?: boolean
    level?: boolean
    message?: boolean
    createdAt?: boolean
    actionLogId?: boolean
  }

  export type System_LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionLog?: boolean | System_Logs$actionLogArgs<ExtArgs>
  }

  export type $System_LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "System_Logs"
    objects: {
      actionLog: Prisma.$Action_LogsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: string
      message: string
      createdAt: Date
      actionLogId: number | null
    }, ExtArgs["result"]["system_Logs"]>
    composites: {}
  }

  type System_LogsGetPayload<S extends boolean | null | undefined | System_LogsDefaultArgs> = $Result.GetResult<Prisma.$System_LogsPayload, S>

  type System_LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<System_LogsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: System_LogsCountAggregateInputType | true
    }

  export interface System_LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['System_Logs'], meta: { name: 'System_Logs' } }
    /**
     * Find zero or one System_Logs that matches the filter.
     * @param {System_LogsFindUniqueArgs} args - Arguments to find a System_Logs
     * @example
     * // Get one System_Logs
     * const system_Logs = await prisma.system_Logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends System_LogsFindUniqueArgs>(args: SelectSubset<T, System_LogsFindUniqueArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one System_Logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {System_LogsFindUniqueOrThrowArgs} args - Arguments to find a System_Logs
     * @example
     * // Get one System_Logs
     * const system_Logs = await prisma.system_Logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends System_LogsFindUniqueOrThrowArgs>(args: SelectSubset<T, System_LogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first System_Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsFindFirstArgs} args - Arguments to find a System_Logs
     * @example
     * // Get one System_Logs
     * const system_Logs = await prisma.system_Logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends System_LogsFindFirstArgs>(args?: SelectSubset<T, System_LogsFindFirstArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first System_Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsFindFirstOrThrowArgs} args - Arguments to find a System_Logs
     * @example
     * // Get one System_Logs
     * const system_Logs = await prisma.system_Logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends System_LogsFindFirstOrThrowArgs>(args?: SelectSubset<T, System_LogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more System_Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all System_Logs
     * const system_Logs = await prisma.system_Logs.findMany()
     * 
     * // Get first 10 System_Logs
     * const system_Logs = await prisma.system_Logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const system_LogsWithIdOnly = await prisma.system_Logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends System_LogsFindManyArgs>(args?: SelectSubset<T, System_LogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a System_Logs.
     * @param {System_LogsCreateArgs} args - Arguments to create a System_Logs.
     * @example
     * // Create one System_Logs
     * const System_Logs = await prisma.system_Logs.create({
     *   data: {
     *     // ... data to create a System_Logs
     *   }
     * })
     * 
     */
    create<T extends System_LogsCreateArgs>(args: SelectSubset<T, System_LogsCreateArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many System_Logs.
     * @param {System_LogsCreateManyArgs} args - Arguments to create many System_Logs.
     * @example
     * // Create many System_Logs
     * const system_Logs = await prisma.system_Logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends System_LogsCreateManyArgs>(args?: SelectSubset<T, System_LogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a System_Logs.
     * @param {System_LogsDeleteArgs} args - Arguments to delete one System_Logs.
     * @example
     * // Delete one System_Logs
     * const System_Logs = await prisma.system_Logs.delete({
     *   where: {
     *     // ... filter to delete one System_Logs
     *   }
     * })
     * 
     */
    delete<T extends System_LogsDeleteArgs>(args: SelectSubset<T, System_LogsDeleteArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one System_Logs.
     * @param {System_LogsUpdateArgs} args - Arguments to update one System_Logs.
     * @example
     * // Update one System_Logs
     * const system_Logs = await prisma.system_Logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends System_LogsUpdateArgs>(args: SelectSubset<T, System_LogsUpdateArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more System_Logs.
     * @param {System_LogsDeleteManyArgs} args - Arguments to filter System_Logs to delete.
     * @example
     * // Delete a few System_Logs
     * const { count } = await prisma.system_Logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends System_LogsDeleteManyArgs>(args?: SelectSubset<T, System_LogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many System_Logs
     * const system_Logs = await prisma.system_Logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends System_LogsUpdateManyArgs>(args: SelectSubset<T, System_LogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one System_Logs.
     * @param {System_LogsUpsertArgs} args - Arguments to update or create a System_Logs.
     * @example
     * // Update or create a System_Logs
     * const system_Logs = await prisma.system_Logs.upsert({
     *   create: {
     *     // ... data to create a System_Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the System_Logs we want to update
     *   }
     * })
     */
    upsert<T extends System_LogsUpsertArgs>(args: SelectSubset<T, System_LogsUpsertArgs<ExtArgs>>): Prisma__System_LogsClient<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of System_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsCountArgs} args - Arguments to filter System_Logs to count.
     * @example
     * // Count the number of System_Logs
     * const count = await prisma.system_Logs.count({
     *   where: {
     *     // ... the filter for the System_Logs we want to count
     *   }
     * })
    **/
    count<T extends System_LogsCountArgs>(
      args?: Subset<T, System_LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], System_LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a System_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends System_LogsAggregateArgs>(args: Subset<T, System_LogsAggregateArgs>): Prisma.PrismaPromise<GetSystem_LogsAggregateType<T>>

    /**
     * Group by System_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends System_LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: System_LogsGroupByArgs['orderBy'] }
        : { orderBy?: System_LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, System_LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystem_LogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the System_Logs model
   */
  readonly fields: System_LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for System_Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__System_LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionLog<T extends System_Logs$actionLogArgs<ExtArgs> = {}>(args?: Subset<T, System_Logs$actionLogArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the System_Logs model
   */ 
  interface System_LogsFieldRefs {
    readonly id: FieldRef<"System_Logs", 'Int'>
    readonly level: FieldRef<"System_Logs", 'String'>
    readonly message: FieldRef<"System_Logs", 'String'>
    readonly createdAt: FieldRef<"System_Logs", 'DateTime'>
    readonly actionLogId: FieldRef<"System_Logs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * System_Logs findUnique
   */
  export type System_LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * Filter, which System_Logs to fetch.
     */
    where: System_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs findUniqueOrThrow
   */
  export type System_LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * Filter, which System_Logs to fetch.
     */
    where: System_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs findFirst
   */
  export type System_LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * Filter, which System_Logs to fetch.
     */
    where?: System_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of System_Logs to fetch.
     */
    orderBy?: System_LogsOrderByWithRelationInput | System_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for System_Logs.
     */
    cursor?: System_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` System_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` System_Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of System_Logs.
     */
    distinct?: System_LogsScalarFieldEnum | System_LogsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs findFirstOrThrow
   */
  export type System_LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * Filter, which System_Logs to fetch.
     */
    where?: System_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of System_Logs to fetch.
     */
    orderBy?: System_LogsOrderByWithRelationInput | System_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for System_Logs.
     */
    cursor?: System_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` System_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` System_Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of System_Logs.
     */
    distinct?: System_LogsScalarFieldEnum | System_LogsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs findMany
   */
  export type System_LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * Filter, which System_Logs to fetch.
     */
    where?: System_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of System_Logs to fetch.
     */
    orderBy?: System_LogsOrderByWithRelationInput | System_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing System_Logs.
     */
    cursor?: System_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` System_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` System_Logs.
     */
    skip?: number
    distinct?: System_LogsScalarFieldEnum | System_LogsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs create
   */
  export type System_LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a System_Logs.
     */
    data: XOR<System_LogsCreateInput, System_LogsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs createMany
   */
  export type System_LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many System_Logs.
     */
    data: System_LogsCreateManyInput | System_LogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * System_Logs update
   */
  export type System_LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a System_Logs.
     */
    data: XOR<System_LogsUpdateInput, System_LogsUncheckedUpdateInput>
    /**
     * Choose, which System_Logs to update.
     */
    where: System_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs updateMany
   */
  export type System_LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update System_Logs.
     */
    data: XOR<System_LogsUpdateManyMutationInput, System_LogsUncheckedUpdateManyInput>
    /**
     * Filter which System_Logs to update
     */
    where?: System_LogsWhereInput
  }

  /**
   * System_Logs upsert
   */
  export type System_LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the System_Logs to update in case it exists.
     */
    where: System_LogsWhereUniqueInput
    /**
     * In case the System_Logs found by the `where` argument doesn't exist, create a new System_Logs with this data.
     */
    create: XOR<System_LogsCreateInput, System_LogsUncheckedCreateInput>
    /**
     * In case the System_Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<System_LogsUpdateInput, System_LogsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs delete
   */
  export type System_LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    /**
     * Filter which System_Logs to delete.
     */
    where: System_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * System_Logs deleteMany
   */
  export type System_LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which System_Logs to delete
     */
    where?: System_LogsWhereInput
  }

  /**
   * System_Logs.actionLog
   */
  export type System_Logs$actionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    where?: Action_LogsWhereInput
  }

  /**
   * System_Logs without action
   */
  export type System_LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
  }


  /**
   * Model Action_Logs
   */

  export type AggregateAction_Logs = {
    _count: Action_LogsCountAggregateOutputType | null
    _avg: Action_LogsAvgAggregateOutputType | null
    _sum: Action_LogsSumAggregateOutputType | null
    _min: Action_LogsMinAggregateOutputType | null
    _max: Action_LogsMaxAggregateOutputType | null
  }

  export type Action_LogsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    ticketId: number | null
  }

  export type Action_LogsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    ticketId: number | null
  }

  export type Action_LogsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    ticketId: number | null
    action: string | null
    message: string | null
    createdAt: Date | null
  }

  export type Action_LogsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    ticketId: number | null
    action: string | null
    message: string | null
    createdAt: Date | null
  }

  export type Action_LogsCountAggregateOutputType = {
    id: number
    userId: number
    ticketId: number
    action: number
    message: number
    createdAt: number
    _all: number
  }


  export type Action_LogsAvgAggregateInputType = {
    id?: true
    userId?: true
    ticketId?: true
  }

  export type Action_LogsSumAggregateInputType = {
    id?: true
    userId?: true
    ticketId?: true
  }

  export type Action_LogsMinAggregateInputType = {
    id?: true
    userId?: true
    ticketId?: true
    action?: true
    message?: true
    createdAt?: true
  }

  export type Action_LogsMaxAggregateInputType = {
    id?: true
    userId?: true
    ticketId?: true
    action?: true
    message?: true
    createdAt?: true
  }

  export type Action_LogsCountAggregateInputType = {
    id?: true
    userId?: true
    ticketId?: true
    action?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type Action_LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action_Logs to aggregate.
     */
    where?: Action_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Action_Logs to fetch.
     */
    orderBy?: Action_LogsOrderByWithRelationInput | Action_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Action_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Action_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Action_Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Action_Logs
    **/
    _count?: true | Action_LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Action_LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Action_LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Action_LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Action_LogsMaxAggregateInputType
  }

  export type GetAction_LogsAggregateType<T extends Action_LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateAction_Logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction_Logs[P]>
      : GetScalarType<T[P], AggregateAction_Logs[P]>
  }




  export type Action_LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Action_LogsWhereInput
    orderBy?: Action_LogsOrderByWithAggregationInput | Action_LogsOrderByWithAggregationInput[]
    by: Action_LogsScalarFieldEnum[] | Action_LogsScalarFieldEnum
    having?: Action_LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Action_LogsCountAggregateInputType | true
    _avg?: Action_LogsAvgAggregateInputType
    _sum?: Action_LogsSumAggregateInputType
    _min?: Action_LogsMinAggregateInputType
    _max?: Action_LogsMaxAggregateInputType
  }

  export type Action_LogsGroupByOutputType = {
    id: number
    userId: number
    ticketId: number | null
    action: string
    message: string | null
    createdAt: Date
    _count: Action_LogsCountAggregateOutputType | null
    _avg: Action_LogsAvgAggregateOutputType | null
    _sum: Action_LogsSumAggregateOutputType | null
    _min: Action_LogsMinAggregateOutputType | null
    _max: Action_LogsMaxAggregateOutputType | null
  }

  type GetAction_LogsGroupByPayload<T extends Action_LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Action_LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Action_LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Action_LogsGroupByOutputType[P]>
            : GetScalarType<T[P], Action_LogsGroupByOutputType[P]>
        }
      >
    >


  export type Action_LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ticketId?: boolean
    action?: boolean
    message?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | Action_Logs$ticketArgs<ExtArgs>
    System_Logs?: boolean | Action_Logs$System_LogsArgs<ExtArgs>
    _count?: boolean | Action_LogsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action_Logs"]>


  export type Action_LogsSelectScalar = {
    id?: boolean
    userId?: boolean
    ticketId?: boolean
    action?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type Action_LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | Action_Logs$ticketArgs<ExtArgs>
    System_Logs?: boolean | Action_Logs$System_LogsArgs<ExtArgs>
    _count?: boolean | Action_LogsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Action_LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action_Logs"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs> | null
      System_Logs: Prisma.$System_LogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      ticketId: number | null
      action: string
      message: string | null
      createdAt: Date
    }, ExtArgs["result"]["action_Logs"]>
    composites: {}
  }

  type Action_LogsGetPayload<S extends boolean | null | undefined | Action_LogsDefaultArgs> = $Result.GetResult<Prisma.$Action_LogsPayload, S>

  type Action_LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Action_LogsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: Action_LogsCountAggregateInputType | true
    }

  export interface Action_LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action_Logs'], meta: { name: 'Action_Logs' } }
    /**
     * Find zero or one Action_Logs that matches the filter.
     * @param {Action_LogsFindUniqueArgs} args - Arguments to find a Action_Logs
     * @example
     * // Get one Action_Logs
     * const action_Logs = await prisma.action_Logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Action_LogsFindUniqueArgs>(args: SelectSubset<T, Action_LogsFindUniqueArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Action_Logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Action_LogsFindUniqueOrThrowArgs} args - Arguments to find a Action_Logs
     * @example
     * // Get one Action_Logs
     * const action_Logs = await prisma.action_Logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Action_LogsFindUniqueOrThrowArgs>(args: SelectSubset<T, Action_LogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Action_Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsFindFirstArgs} args - Arguments to find a Action_Logs
     * @example
     * // Get one Action_Logs
     * const action_Logs = await prisma.action_Logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Action_LogsFindFirstArgs>(args?: SelectSubset<T, Action_LogsFindFirstArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Action_Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsFindFirstOrThrowArgs} args - Arguments to find a Action_Logs
     * @example
     * // Get one Action_Logs
     * const action_Logs = await prisma.action_Logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Action_LogsFindFirstOrThrowArgs>(args?: SelectSubset<T, Action_LogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Action_Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Action_Logs
     * const action_Logs = await prisma.action_Logs.findMany()
     * 
     * // Get first 10 Action_Logs
     * const action_Logs = await prisma.action_Logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const action_LogsWithIdOnly = await prisma.action_Logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Action_LogsFindManyArgs>(args?: SelectSubset<T, Action_LogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Action_Logs.
     * @param {Action_LogsCreateArgs} args - Arguments to create a Action_Logs.
     * @example
     * // Create one Action_Logs
     * const Action_Logs = await prisma.action_Logs.create({
     *   data: {
     *     // ... data to create a Action_Logs
     *   }
     * })
     * 
     */
    create<T extends Action_LogsCreateArgs>(args: SelectSubset<T, Action_LogsCreateArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Action_Logs.
     * @param {Action_LogsCreateManyArgs} args - Arguments to create many Action_Logs.
     * @example
     * // Create many Action_Logs
     * const action_Logs = await prisma.action_Logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Action_LogsCreateManyArgs>(args?: SelectSubset<T, Action_LogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Action_Logs.
     * @param {Action_LogsDeleteArgs} args - Arguments to delete one Action_Logs.
     * @example
     * // Delete one Action_Logs
     * const Action_Logs = await prisma.action_Logs.delete({
     *   where: {
     *     // ... filter to delete one Action_Logs
     *   }
     * })
     * 
     */
    delete<T extends Action_LogsDeleteArgs>(args: SelectSubset<T, Action_LogsDeleteArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Action_Logs.
     * @param {Action_LogsUpdateArgs} args - Arguments to update one Action_Logs.
     * @example
     * // Update one Action_Logs
     * const action_Logs = await prisma.action_Logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Action_LogsUpdateArgs>(args: SelectSubset<T, Action_LogsUpdateArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Action_Logs.
     * @param {Action_LogsDeleteManyArgs} args - Arguments to filter Action_Logs to delete.
     * @example
     * // Delete a few Action_Logs
     * const { count } = await prisma.action_Logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Action_LogsDeleteManyArgs>(args?: SelectSubset<T, Action_LogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Action_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Action_Logs
     * const action_Logs = await prisma.action_Logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Action_LogsUpdateManyArgs>(args: SelectSubset<T, Action_LogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Action_Logs.
     * @param {Action_LogsUpsertArgs} args - Arguments to update or create a Action_Logs.
     * @example
     * // Update or create a Action_Logs
     * const action_Logs = await prisma.action_Logs.upsert({
     *   create: {
     *     // ... data to create a Action_Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action_Logs we want to update
     *   }
     * })
     */
    upsert<T extends Action_LogsUpsertArgs>(args: SelectSubset<T, Action_LogsUpsertArgs<ExtArgs>>): Prisma__Action_LogsClient<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Action_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsCountArgs} args - Arguments to filter Action_Logs to count.
     * @example
     * // Count the number of Action_Logs
     * const count = await prisma.action_Logs.count({
     *   where: {
     *     // ... the filter for the Action_Logs we want to count
     *   }
     * })
    **/
    count<T extends Action_LogsCountArgs>(
      args?: Subset<T, Action_LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Action_LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Action_LogsAggregateArgs>(args: Subset<T, Action_LogsAggregateArgs>): Prisma.PrismaPromise<GetAction_LogsAggregateType<T>>

    /**
     * Group by Action_Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Action_LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Action_LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Action_LogsGroupByArgs['orderBy'] }
        : { orderBy?: Action_LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Action_LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAction_LogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action_Logs model
   */
  readonly fields: Action_LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action_Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Action_LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ticket<T extends Action_Logs$ticketArgs<ExtArgs> = {}>(args?: Subset<T, Action_Logs$ticketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    System_Logs<T extends Action_Logs$System_LogsArgs<ExtArgs> = {}>(args?: Subset<T, Action_Logs$System_LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$System_LogsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action_Logs model
   */ 
  interface Action_LogsFieldRefs {
    readonly id: FieldRef<"Action_Logs", 'Int'>
    readonly userId: FieldRef<"Action_Logs", 'Int'>
    readonly ticketId: FieldRef<"Action_Logs", 'Int'>
    readonly action: FieldRef<"Action_Logs", 'String'>
    readonly message: FieldRef<"Action_Logs", 'String'>
    readonly createdAt: FieldRef<"Action_Logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Action_Logs findUnique
   */
  export type Action_LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * Filter, which Action_Logs to fetch.
     */
    where: Action_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs findUniqueOrThrow
   */
  export type Action_LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * Filter, which Action_Logs to fetch.
     */
    where: Action_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs findFirst
   */
  export type Action_LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * Filter, which Action_Logs to fetch.
     */
    where?: Action_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Action_Logs to fetch.
     */
    orderBy?: Action_LogsOrderByWithRelationInput | Action_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Action_Logs.
     */
    cursor?: Action_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Action_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Action_Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Action_Logs.
     */
    distinct?: Action_LogsScalarFieldEnum | Action_LogsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs findFirstOrThrow
   */
  export type Action_LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * Filter, which Action_Logs to fetch.
     */
    where?: Action_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Action_Logs to fetch.
     */
    orderBy?: Action_LogsOrderByWithRelationInput | Action_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Action_Logs.
     */
    cursor?: Action_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Action_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Action_Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Action_Logs.
     */
    distinct?: Action_LogsScalarFieldEnum | Action_LogsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs findMany
   */
  export type Action_LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * Filter, which Action_Logs to fetch.
     */
    where?: Action_LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Action_Logs to fetch.
     */
    orderBy?: Action_LogsOrderByWithRelationInput | Action_LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Action_Logs.
     */
    cursor?: Action_LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Action_Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Action_Logs.
     */
    skip?: number
    distinct?: Action_LogsScalarFieldEnum | Action_LogsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs create
   */
  export type Action_LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a Action_Logs.
     */
    data: XOR<Action_LogsCreateInput, Action_LogsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs createMany
   */
  export type Action_LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Action_Logs.
     */
    data: Action_LogsCreateManyInput | Action_LogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action_Logs update
   */
  export type Action_LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a Action_Logs.
     */
    data: XOR<Action_LogsUpdateInput, Action_LogsUncheckedUpdateInput>
    /**
     * Choose, which Action_Logs to update.
     */
    where: Action_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs updateMany
   */
  export type Action_LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Action_Logs.
     */
    data: XOR<Action_LogsUpdateManyMutationInput, Action_LogsUncheckedUpdateManyInput>
    /**
     * Filter which Action_Logs to update
     */
    where?: Action_LogsWhereInput
  }

  /**
   * Action_Logs upsert
   */
  export type Action_LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the Action_Logs to update in case it exists.
     */
    where: Action_LogsWhereUniqueInput
    /**
     * In case the Action_Logs found by the `where` argument doesn't exist, create a new Action_Logs with this data.
     */
    create: XOR<Action_LogsCreateInput, Action_LogsUncheckedCreateInput>
    /**
     * In case the Action_Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Action_LogsUpdateInput, Action_LogsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs delete
   */
  export type Action_LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    /**
     * Filter which Action_Logs to delete.
     */
    where: Action_LogsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Action_Logs deleteMany
   */
  export type Action_LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action_Logs to delete
     */
    where?: Action_LogsWhereInput
  }

  /**
   * Action_Logs.ticket
   */
  export type Action_Logs$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * Action_Logs.System_Logs
   */
  export type Action_Logs$System_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the System_Logs
     */
    select?: System_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: System_LogsInclude<ExtArgs> | null
    where?: System_LogsWhereInput
    orderBy?: System_LogsOrderByWithRelationInput | System_LogsOrderByWithRelationInput[]
    cursor?: System_LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: System_LogsScalarFieldEnum | System_LogsScalarFieldEnum[]
  }

  /**
   * Action_Logs without action
   */
  export type Action_LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    ack: number | null
    ticketId: number | null
    contactId: number | null
    companyId: number | null
    queueId: number | null
  }

  export type MessageSumAggregateOutputType = {
    ack: number | null
    ticketId: number | null
    contactId: number | null
    companyId: number | null
    queueId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    participant: string | null
    dataJson: string | null
    ack: number | null
    read: boolean | null
    fromMe: boolean | null
    body: string | null
    mediaUrl: string | null
    mediaType: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    quotedMsgId: string | null
    ticketId: number | null
    contactId: number | null
    companyId: number | null
    queueId: number | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    participant: string | null
    dataJson: string | null
    ack: number | null
    read: boolean | null
    fromMe: boolean | null
    body: string | null
    mediaUrl: string | null
    mediaType: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    quotedMsgId: string | null
    ticketId: number | null
    contactId: number | null
    companyId: number | null
    queueId: number | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    remoteJid: number
    participant: number
    dataJson: number
    ack: number
    read: number
    fromMe: number
    body: number
    mediaUrl: number
    mediaType: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    quotedMsgId: number
    ticketId: number
    contactId: number
    companyId: number
    queueId: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    ack?: true
    ticketId?: true
    contactId?: true
    companyId?: true
    queueId?: true
  }

  export type MessageSumAggregateInputType = {
    ack?: true
    ticketId?: true
    contactId?: true
    companyId?: true
    queueId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    remoteJid?: true
    participant?: true
    dataJson?: true
    ack?: true
    read?: true
    fromMe?: true
    body?: true
    mediaUrl?: true
    mediaType?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    quotedMsgId?: true
    ticketId?: true
    contactId?: true
    companyId?: true
    queueId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    remoteJid?: true
    participant?: true
    dataJson?: true
    ack?: true
    read?: true
    fromMe?: true
    body?: true
    mediaUrl?: true
    mediaType?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    quotedMsgId?: true
    ticketId?: true
    contactId?: true
    companyId?: true
    queueId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    remoteJid?: true
    participant?: true
    dataJson?: true
    ack?: true
    read?: true
    fromMe?: true
    body?: true
    mediaUrl?: true
    mediaType?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    quotedMsgId?: true
    ticketId?: true
    contactId?: true
    companyId?: true
    queueId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    remoteJid: string
    participant: string
    dataJson: string
    ack: number
    read: boolean
    fromMe: boolean
    body: string
    mediaUrl: string | null
    mediaType: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    quotedMsgId: string | null
    ticketId: number | null
    contactId: number | null
    companyId: number
    queueId: number | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    remoteJid?: boolean
    participant?: boolean
    dataJson?: boolean
    ack?: boolean
    read?: boolean
    fromMe?: boolean
    body?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotedMsgId?: boolean
    ticketId?: boolean
    contactId?: boolean
    companyId?: boolean
    queueId?: boolean
    quotedMsg?: boolean | Message$quotedMsgArgs<ExtArgs>
    ticket?: boolean | Message$ticketArgs<ExtArgs>
    contact?: boolean | Message$contactArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    queue?: boolean | Message$queueArgs<ExtArgs>
    Message?: boolean | Message$MessageArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>


  export type MessageSelectScalar = {
    id?: boolean
    remoteJid?: boolean
    participant?: boolean
    dataJson?: boolean
    ack?: boolean
    read?: boolean
    fromMe?: boolean
    body?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotedMsgId?: boolean
    ticketId?: boolean
    contactId?: boolean
    companyId?: boolean
    queueId?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotedMsg?: boolean | Message$quotedMsgArgs<ExtArgs>
    ticket?: boolean | Message$ticketArgs<ExtArgs>
    contact?: boolean | Message$contactArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    queue?: boolean | Message$queueArgs<ExtArgs>
    Message?: boolean | Message$MessageArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      quotedMsg: Prisma.$MessagePayload<ExtArgs> | null
      ticket: Prisma.$TicketPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      queue: Prisma.$QueuePayload<ExtArgs> | null
      Message: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      remoteJid: string
      participant: string
      dataJson: string
      ack: number
      read: boolean
      fromMe: boolean
      body: string
      mediaUrl: string | null
      mediaType: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      quotedMsgId: string | null
      ticketId: number | null
      contactId: number | null
      companyId: number
      queueId: number | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotedMsg<T extends Message$quotedMsgArgs<ExtArgs> = {}>(args?: Subset<T, Message$quotedMsgArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ticket<T extends Message$ticketArgs<ExtArgs> = {}>(args?: Subset<T, Message$ticketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contact<T extends Message$contactArgs<ExtArgs> = {}>(args?: Subset<T, Message$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    queue<T extends Message$queueArgs<ExtArgs> = {}>(args?: Subset<T, Message$queueArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Message<T extends Message$MessageArgs<ExtArgs> = {}>(args?: Subset<T, Message$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly remoteJid: FieldRef<"Message", 'String'>
    readonly participant: FieldRef<"Message", 'String'>
    readonly dataJson: FieldRef<"Message", 'String'>
    readonly ack: FieldRef<"Message", 'Int'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly fromMe: FieldRef<"Message", 'Boolean'>
    readonly body: FieldRef<"Message", 'String'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly mediaType: FieldRef<"Message", 'String'>
    readonly isDeleted: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly quotedMsgId: FieldRef<"Message", 'String'>
    readonly ticketId: FieldRef<"Message", 'Int'>
    readonly contactId: FieldRef<"Message", 'Int'>
    readonly companyId: FieldRef<"Message", 'Int'>
    readonly queueId: FieldRef<"Message", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.quotedMsg
   */
  export type Message$quotedMsgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.ticket
   */
  export type Message$ticketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * Message.contact
   */
  export type Message$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Message.queue
   */
  export type Message$queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
  }

  /**
   * Message.Message
   */
  export type Message$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    id: number | null
    users: number | null
    connections: number | null
    queues: number | null
    value: number | null
  }

  export type PlanSumAggregateOutputType = {
    id: number | null
    users: number | null
    connections: number | null
    queues: number | null
    value: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    users: number | null
    connections: number | null
    queues: number | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
    useSchedules: boolean | null
    useCampaigns: boolean | null
    useInternalChat: boolean | null
    useExternalApi: boolean | null
    useKanban: boolean | null
    useOpenAi: boolean | null
    useIntegrations: boolean | null
  }

  export type PlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    users: number | null
    connections: number | null
    queues: number | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
    useSchedules: boolean | null
    useCampaigns: boolean | null
    useInternalChat: boolean | null
    useExternalApi: boolean | null
    useKanban: boolean | null
    useOpenAi: boolean | null
    useIntegrations: boolean | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    users: number
    connections: number
    queues: number
    value: number
    createdAt: number
    updatedAt: number
    useSchedules: number
    useCampaigns: number
    useInternalChat: number
    useExternalApi: number
    useKanban: number
    useOpenAi: number
    useIntegrations: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    id?: true
    users?: true
    connections?: true
    queues?: true
    value?: true
  }

  export type PlanSumAggregateInputType = {
    id?: true
    users?: true
    connections?: true
    queues?: true
    value?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    users?: true
    connections?: true
    queues?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    useSchedules?: true
    useCampaigns?: true
    useInternalChat?: true
    useExternalApi?: true
    useKanban?: true
    useOpenAi?: true
    useIntegrations?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    users?: true
    connections?: true
    queues?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    useSchedules?: true
    useCampaigns?: true
    useInternalChat?: true
    useExternalApi?: true
    useKanban?: true
    useOpenAi?: true
    useIntegrations?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    users?: true
    connections?: true
    queues?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    useSchedules?: true
    useCampaigns?: true
    useInternalChat?: true
    useExternalApi?: true
    useKanban?: true
    useOpenAi?: true
    useIntegrations?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: number
    name: string
    users: number | null
    connections: number | null
    queues: number | null
    value: number | null
    createdAt: Date
    updatedAt: Date
    useSchedules: boolean
    useCampaigns: boolean
    useInternalChat: boolean
    useExternalApi: boolean
    useKanban: boolean
    useOpenAi: boolean
    useIntegrations: boolean
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean
    connections?: boolean
    queues?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    useSchedules?: boolean
    useCampaigns?: boolean
    useInternalChat?: boolean
    useExternalApi?: boolean
    useKanban?: boolean
    useOpenAi?: boolean
    useIntegrations?: boolean
    Company?: boolean | Plan$CompanyArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>


  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    users?: boolean
    connections?: boolean
    queues?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    useSchedules?: boolean
    useCampaigns?: boolean
    useInternalChat?: boolean
    useExternalApi?: boolean
    useKanban?: boolean
    useOpenAi?: boolean
    useIntegrations?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | Plan$CompanyArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      Company: Prisma.$CompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      users: number | null
      connections: number | null
      queues: number | null
      value: number | null
      createdAt: Date
      updatedAt: Date
      useSchedules: boolean
      useCampaigns: boolean
      useInternalChat: boolean
      useExternalApi: boolean
      useKanban: boolean
      useOpenAi: boolean
      useIntegrations: boolean
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Company<T extends Plan$CompanyArgs<ExtArgs> = {}>(args?: Subset<T, Plan$CompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'Int'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly users: FieldRef<"Plan", 'Int'>
    readonly connections: FieldRef<"Plan", 'Int'>
    readonly queues: FieldRef<"Plan", 'Int'>
    readonly value: FieldRef<"Plan", 'Float'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
    readonly useSchedules: FieldRef<"Plan", 'Boolean'>
    readonly useCampaigns: FieldRef<"Plan", 'Boolean'>
    readonly useInternalChat: FieldRef<"Plan", 'Boolean'>
    readonly useExternalApi: FieldRef<"Plan", 'Boolean'>
    readonly useKanban: FieldRef<"Plan", 'Boolean'>
    readonly useOpenAi: FieldRef<"Plan", 'Boolean'>
    readonly useIntegrations: FieldRef<"Plan", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.Company
   */
  export type Plan$CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Prompt
   */

  export type AggregatePrompt = {
    _count: PromptCountAggregateOutputType | null
    _avg: PromptAvgAggregateOutputType | null
    _sum: PromptSumAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  export type PromptAvgAggregateOutputType = {
    id: number | null
    maxMessages: number | null
    maxTokens: number | null
    temperature: number | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    queueId: number | null
    companyId: number | null
  }

  export type PromptSumAggregateOutputType = {
    id: number | null
    maxMessages: number | null
    maxTokens: number | null
    temperature: number | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    queueId: number | null
    companyId: number | null
  }

  export type PromptMinAggregateOutputType = {
    id: number | null
    name: string | null
    prompt: string | null
    apiKey: string | null
    maxMessages: number | null
    maxTokens: number | null
    temperature: number | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    voice: string | null
    voiceKey: string | null
    voiceRegion: string | null
    queueId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptMaxAggregateOutputType = {
    id: number | null
    name: string | null
    prompt: string | null
    apiKey: string | null
    maxMessages: number | null
    maxTokens: number | null
    temperature: number | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    voice: string | null
    voiceKey: string | null
    voiceRegion: string | null
    queueId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptCountAggregateOutputType = {
    id: number
    name: number
    prompt: number
    apiKey: number
    maxMessages: number
    maxTokens: number
    temperature: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    voice: number
    voiceKey: number
    voiceRegion: number
    queueId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromptAvgAggregateInputType = {
    id?: true
    maxMessages?: true
    maxTokens?: true
    temperature?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    queueId?: true
    companyId?: true
  }

  export type PromptSumAggregateInputType = {
    id?: true
    maxMessages?: true
    maxTokens?: true
    temperature?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    queueId?: true
    companyId?: true
  }

  export type PromptMinAggregateInputType = {
    id?: true
    name?: true
    prompt?: true
    apiKey?: true
    maxMessages?: true
    maxTokens?: true
    temperature?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    voice?: true
    voiceKey?: true
    voiceRegion?: true
    queueId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptMaxAggregateInputType = {
    id?: true
    name?: true
    prompt?: true
    apiKey?: true
    maxMessages?: true
    maxTokens?: true
    temperature?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    voice?: true
    voiceKey?: true
    voiceRegion?: true
    queueId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptCountAggregateInputType = {
    id?: true
    name?: true
    prompt?: true
    apiKey?: true
    maxMessages?: true
    maxTokens?: true
    temperature?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    voice?: true
    voiceKey?: true
    voiceRegion?: true
    queueId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompt to aggregate.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prompts
    **/
    _count?: true | PromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptMaxAggregateInputType
  }

  export type GetPromptAggregateType<T extends PromptAggregateArgs> = {
        [P in keyof T & keyof AggregatePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrompt[P]>
      : GetScalarType<T[P], AggregatePrompt[P]>
  }




  export type PromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithAggregationInput | PromptOrderByWithAggregationInput[]
    by: PromptScalarFieldEnum[] | PromptScalarFieldEnum
    having?: PromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptCountAggregateInputType | true
    _avg?: PromptAvgAggregateInputType
    _sum?: PromptSumAggregateInputType
    _min?: PromptMinAggregateInputType
    _max?: PromptMaxAggregateInputType
  }

  export type PromptGroupByOutputType = {
    id: number
    name: string
    prompt: string
    apiKey: string
    maxMessages: number
    maxTokens: number
    temperature: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    voice: string
    voiceKey: string | null
    voiceRegion: string | null
    queueId: number | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: PromptCountAggregateOutputType | null
    _avg: PromptAvgAggregateOutputType | null
    _sum: PromptSumAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  type GetPromptGroupByPayload<T extends PromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptGroupByOutputType[P]>
            : GetScalarType<T[P], PromptGroupByOutputType[P]>
        }
      >
    >


  export type PromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    prompt?: boolean
    apiKey?: boolean
    maxMessages?: boolean
    maxTokens?: boolean
    temperature?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    voice?: boolean
    voiceKey?: boolean
    voiceRegion?: boolean
    queueId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    queue?: boolean | Prompt$queueArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    Whatsapp?: boolean | Prompt$WhatsappArgs<ExtArgs>
    Ticket?: boolean | Prompt$TicketArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>


  export type PromptSelectScalar = {
    id?: boolean
    name?: boolean
    prompt?: boolean
    apiKey?: boolean
    maxMessages?: boolean
    maxTokens?: boolean
    temperature?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    voice?: boolean
    voiceKey?: boolean
    voiceRegion?: boolean
    queueId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queue?: boolean | Prompt$queueArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    Whatsapp?: boolean | Prompt$WhatsappArgs<ExtArgs>
    Ticket?: boolean | Prompt$TicketArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prompt"
    objects: {
      queue: Prisma.$QueuePayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      Whatsapp: Prisma.$WhatsappPayload<ExtArgs>[]
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      prompt: string
      apiKey: string
      maxMessages: number
      maxTokens: number
      temperature: number
      promptTokens: number
      completionTokens: number
      totalTokens: number
      voice: string
      voiceKey: string | null
      voiceRegion: string | null
      queueId: number | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prompt"]>
    composites: {}
  }

  type PromptGetPayload<S extends boolean | null | undefined | PromptDefaultArgs> = $Result.GetResult<Prisma.$PromptPayload, S>

  type PromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromptFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: PromptCountAggregateInputType | true
    }

  export interface PromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prompt'], meta: { name: 'Prompt' } }
    /**
     * Find zero or one Prompt that matches the filter.
     * @param {PromptFindUniqueArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptFindUniqueArgs>(args: SelectSubset<T, PromptFindUniqueArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromptFindUniqueOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptFindFirstArgs>(args?: SelectSubset<T, PromptFindFirstArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prompts
     * const prompts = await prisma.prompt.findMany()
     * 
     * // Get first 10 Prompts
     * const prompts = await prisma.prompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptWithIdOnly = await prisma.prompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptFindManyArgs>(args?: SelectSubset<T, PromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prompt.
     * @param {PromptCreateArgs} args - Arguments to create a Prompt.
     * @example
     * // Create one Prompt
     * const Prompt = await prisma.prompt.create({
     *   data: {
     *     // ... data to create a Prompt
     *   }
     * })
     * 
     */
    create<T extends PromptCreateArgs>(args: SelectSubset<T, PromptCreateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prompts.
     * @param {PromptCreateManyArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptCreateManyArgs>(args?: SelectSubset<T, PromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prompt.
     * @param {PromptDeleteArgs} args - Arguments to delete one Prompt.
     * @example
     * // Delete one Prompt
     * const Prompt = await prisma.prompt.delete({
     *   where: {
     *     // ... filter to delete one Prompt
     *   }
     * })
     * 
     */
    delete<T extends PromptDeleteArgs>(args: SelectSubset<T, PromptDeleteArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prompt.
     * @param {PromptUpdateArgs} args - Arguments to update one Prompt.
     * @example
     * // Update one Prompt
     * const prompt = await prisma.prompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptUpdateArgs>(args: SelectSubset<T, PromptUpdateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prompts.
     * @param {PromptDeleteManyArgs} args - Arguments to filter Prompts to delete.
     * @example
     * // Delete a few Prompts
     * const { count } = await prisma.prompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptDeleteManyArgs>(args?: SelectSubset<T, PromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prompts
     * const prompt = await prisma.prompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptUpdateManyArgs>(args: SelectSubset<T, PromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prompt.
     * @param {PromptUpsertArgs} args - Arguments to update or create a Prompt.
     * @example
     * // Update or create a Prompt
     * const prompt = await prisma.prompt.upsert({
     *   create: {
     *     // ... data to create a Prompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prompt we want to update
     *   }
     * })
     */
    upsert<T extends PromptUpsertArgs>(args: SelectSubset<T, PromptUpsertArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCountArgs} args - Arguments to filter Prompts to count.
     * @example
     * // Count the number of Prompts
     * const count = await prisma.prompt.count({
     *   where: {
     *     // ... the filter for the Prompts we want to count
     *   }
     * })
    **/
    count<T extends PromptCountArgs>(
      args?: Subset<T, PromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptAggregateArgs>(args: Subset<T, PromptAggregateArgs>): Prisma.PrismaPromise<GetPromptAggregateType<T>>

    /**
     * Group by Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptGroupByArgs['orderBy'] }
        : { orderBy?: PromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prompt model
   */
  readonly fields: PromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    queue<T extends Prompt$queueArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$queueArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Whatsapp<T extends Prompt$WhatsappArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$WhatsappArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findMany"> | Null>
    Ticket<T extends Prompt$TicketArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prompt model
   */ 
  interface PromptFieldRefs {
    readonly id: FieldRef<"Prompt", 'Int'>
    readonly name: FieldRef<"Prompt", 'String'>
    readonly prompt: FieldRef<"Prompt", 'String'>
    readonly apiKey: FieldRef<"Prompt", 'String'>
    readonly maxMessages: FieldRef<"Prompt", 'Int'>
    readonly maxTokens: FieldRef<"Prompt", 'Int'>
    readonly temperature: FieldRef<"Prompt", 'Int'>
    readonly promptTokens: FieldRef<"Prompt", 'Int'>
    readonly completionTokens: FieldRef<"Prompt", 'Int'>
    readonly totalTokens: FieldRef<"Prompt", 'Int'>
    readonly voice: FieldRef<"Prompt", 'String'>
    readonly voiceKey: FieldRef<"Prompt", 'String'>
    readonly voiceRegion: FieldRef<"Prompt", 'String'>
    readonly queueId: FieldRef<"Prompt", 'Int'>
    readonly companyId: FieldRef<"Prompt", 'Int'>
    readonly createdAt: FieldRef<"Prompt", 'DateTime'>
    readonly updatedAt: FieldRef<"Prompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prompt findUnique
   */
  export type PromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findUniqueOrThrow
   */
  export type PromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findFirst
   */
  export type PromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findFirstOrThrow
   */
  export type PromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt findMany
   */
  export type PromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompts to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt create
   */
  export type PromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to create a Prompt.
     */
    data: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt createMany
   */
  export type PromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prompt update
   */
  export type PromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to update a Prompt.
     */
    data: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    /**
     * Choose, which Prompt to update.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt updateMany
   */
  export type PromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prompts.
     */
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyInput>
    /**
     * Filter which Prompts to update
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt upsert
   */
  export type PromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The filter to search for the Prompt to update in case it exists.
     */
    where: PromptWhereUniqueInput
    /**
     * In case the Prompt found by the `where` argument doesn't exist, create a new Prompt with this data.
     */
    create: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    /**
     * In case the Prompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt delete
   */
  export type PromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter which Prompt to delete.
     */
    where: PromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Prompt deleteMany
   */
  export type PromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompts to delete
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt.queue
   */
  export type Prompt$queueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
  }

  /**
   * Prompt.Whatsapp
   */
  export type Prompt$WhatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    cursor?: WhatsappWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappScalarFieldEnum | WhatsappScalarFieldEnum[]
  }

  /**
   * Prompt.Ticket
   */
  export type Prompt$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Prompt without action
   */
  export type PromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
  }


  /**
   * Model Queue
   */

  export type AggregateQueue = {
    _count: QueueCountAggregateOutputType | null
    _avg: QueueAvgAggregateOutputType | null
    _sum: QueueSumAggregateOutputType | null
    _min: QueueMinAggregateOutputType | null
    _max: QueueMaxAggregateOutputType | null
  }

  export type QueueAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    orderQueue: number | null
    integrationId: number | null
    promptId: number | null
  }

  export type QueueSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    orderQueue: number | null
    integrationId: number | null
    promptId: number | null
  }

  export type QueueMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    greetingMessage: string | null
    outOfHoursMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    orderQueue: number | null
    integrationId: number | null
    promptId: number | null
  }

  export type QueueMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    greetingMessage: string | null
    outOfHoursMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    orderQueue: number | null
    integrationId: number | null
    promptId: number | null
  }

  export type QueueCountAggregateOutputType = {
    id: number
    name: number
    color: number
    greetingMessage: number
    outOfHoursMessage: number
    schedules: number
    createdAt: number
    updatedAt: number
    companyId: number
    orderQueue: number
    integrationId: number
    promptId: number
    _all: number
  }


  export type QueueAvgAggregateInputType = {
    id?: true
    companyId?: true
    orderQueue?: true
    integrationId?: true
    promptId?: true
  }

  export type QueueSumAggregateInputType = {
    id?: true
    companyId?: true
    orderQueue?: true
    integrationId?: true
    promptId?: true
  }

  export type QueueMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    greetingMessage?: true
    outOfHoursMessage?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    orderQueue?: true
    integrationId?: true
    promptId?: true
  }

  export type QueueMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    greetingMessage?: true
    outOfHoursMessage?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    orderQueue?: true
    integrationId?: true
    promptId?: true
  }

  export type QueueCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    greetingMessage?: true
    outOfHoursMessage?: true
    schedules?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    orderQueue?: true
    integrationId?: true
    promptId?: true
    _all?: true
  }

  export type QueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queue to aggregate.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queues
    **/
    _count?: true | QueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueMaxAggregateInputType
  }

  export type GetQueueAggregateType<T extends QueueAggregateArgs> = {
        [P in keyof T & keyof AggregateQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueue[P]>
      : GetScalarType<T[P], AggregateQueue[P]>
  }




  export type QueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithAggregationInput | QueueOrderByWithAggregationInput[]
    by: QueueScalarFieldEnum[] | QueueScalarFieldEnum
    having?: QueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueCountAggregateInputType | true
    _avg?: QueueAvgAggregateInputType
    _sum?: QueueSumAggregateInputType
    _min?: QueueMinAggregateInputType
    _max?: QueueMaxAggregateInputType
  }

  export type QueueGroupByOutputType = {
    id: number
    name: string
    color: string
    greetingMessage: string
    outOfHoursMessage: string
    schedules: JsonValue | null
    createdAt: Date
    updatedAt: Date
    companyId: number
    orderQueue: number
    integrationId: number | null
    promptId: number | null
    _count: QueueCountAggregateOutputType | null
    _avg: QueueAvgAggregateOutputType | null
    _sum: QueueSumAggregateOutputType | null
    _min: QueueMinAggregateOutputType | null
    _max: QueueMaxAggregateOutputType | null
  }

  type GetQueueGroupByPayload<T extends QueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueGroupByOutputType[P]>
            : GetScalarType<T[P], QueueGroupByOutputType[P]>
        }
      >
    >


  export type QueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    greetingMessage?: boolean
    outOfHoursMessage?: boolean
    schedules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    orderQueue?: boolean
    integrationId?: boolean
    promptId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapps?: boolean | Queue$whatsappsArgs<ExtArgs>
    users?: boolean | Queue$usersArgs<ExtArgs>
    options?: boolean | Queue$optionsArgs<ExtArgs>
    queueIntegrations?: boolean | Queue$queueIntegrationsArgs<ExtArgs>
    prompt?: boolean | Queue$promptArgs<ExtArgs>
    UserQueue?: boolean | Queue$UserQueueArgs<ExtArgs>
    WhatsappQueue?: boolean | Queue$WhatsappQueueArgs<ExtArgs>
    Ticket?: boolean | Queue$TicketArgs<ExtArgs>
    Message?: boolean | Queue$MessageArgs<ExtArgs>
    Company?: boolean | Queue$CompanyArgs<ExtArgs>
    _count?: boolean | QueueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queue"]>


  export type QueueSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    greetingMessage?: boolean
    outOfHoursMessage?: boolean
    schedules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    orderQueue?: boolean
    integrationId?: boolean
    promptId?: boolean
  }

  export type QueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapps?: boolean | Queue$whatsappsArgs<ExtArgs>
    users?: boolean | Queue$usersArgs<ExtArgs>
    options?: boolean | Queue$optionsArgs<ExtArgs>
    queueIntegrations?: boolean | Queue$queueIntegrationsArgs<ExtArgs>
    prompt?: boolean | Queue$promptArgs<ExtArgs>
    UserQueue?: boolean | Queue$UserQueueArgs<ExtArgs>
    WhatsappQueue?: boolean | Queue$WhatsappQueueArgs<ExtArgs>
    Ticket?: boolean | Queue$TicketArgs<ExtArgs>
    Message?: boolean | Queue$MessageArgs<ExtArgs>
    Company?: boolean | Queue$CompanyArgs<ExtArgs>
    _count?: boolean | QueueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Queue"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      whatsapps: Prisma.$WhatsappPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      options: Prisma.$QueueOptionPayload<ExtArgs>[]
      queueIntegrations: Prisma.$QueueIntegrationsPayload<ExtArgs> | null
      prompt: Prisma.$PromptPayload<ExtArgs>[]
      UserQueue: Prisma.$UserQueuePayload<ExtArgs>[]
      WhatsappQueue: Prisma.$WhatsappQueuePayload<ExtArgs>[]
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
      Message: Prisma.$MessagePayload<ExtArgs>[]
      Company: Prisma.$CompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
      greetingMessage: string
      outOfHoursMessage: string
      schedules: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      companyId: number
      orderQueue: number
      integrationId: number | null
      promptId: number | null
    }, ExtArgs["result"]["queue"]>
    composites: {}
  }

  type QueueGetPayload<S extends boolean | null | undefined | QueueDefaultArgs> = $Result.GetResult<Prisma.$QueuePayload, S>

  type QueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QueueFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: QueueCountAggregateInputType | true
    }

  export interface QueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Queue'], meta: { name: 'Queue' } }
    /**
     * Find zero or one Queue that matches the filter.
     * @param {QueueFindUniqueArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueFindUniqueArgs>(args: SelectSubset<T, QueueFindUniqueArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Queue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QueueFindUniqueOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueFindFirstArgs>(args?: SelectSubset<T, QueueFindFirstArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Queue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queues
     * const queues = await prisma.queue.findMany()
     * 
     * // Get first 10 Queues
     * const queues = await prisma.queue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueWithIdOnly = await prisma.queue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueFindManyArgs>(args?: SelectSubset<T, QueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Queue.
     * @param {QueueCreateArgs} args - Arguments to create a Queue.
     * @example
     * // Create one Queue
     * const Queue = await prisma.queue.create({
     *   data: {
     *     // ... data to create a Queue
     *   }
     * })
     * 
     */
    create<T extends QueueCreateArgs>(args: SelectSubset<T, QueueCreateArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Queues.
     * @param {QueueCreateManyArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueCreateManyArgs>(args?: SelectSubset<T, QueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Queue.
     * @param {QueueDeleteArgs} args - Arguments to delete one Queue.
     * @example
     * // Delete one Queue
     * const Queue = await prisma.queue.delete({
     *   where: {
     *     // ... filter to delete one Queue
     *   }
     * })
     * 
     */
    delete<T extends QueueDeleteArgs>(args: SelectSubset<T, QueueDeleteArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Queue.
     * @param {QueueUpdateArgs} args - Arguments to update one Queue.
     * @example
     * // Update one Queue
     * const queue = await prisma.queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueUpdateArgs>(args: SelectSubset<T, QueueUpdateArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Queues.
     * @param {QueueDeleteManyArgs} args - Arguments to filter Queues to delete.
     * @example
     * // Delete a few Queues
     * const { count } = await prisma.queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueDeleteManyArgs>(args?: SelectSubset<T, QueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueUpdateManyArgs>(args: SelectSubset<T, QueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Queue.
     * @param {QueueUpsertArgs} args - Arguments to update or create a Queue.
     * @example
     * // Update or create a Queue
     * const queue = await prisma.queue.upsert({
     *   create: {
     *     // ... data to create a Queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queue we want to update
     *   }
     * })
     */
    upsert<T extends QueueUpsertArgs>(args: SelectSubset<T, QueueUpsertArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueCountArgs} args - Arguments to filter Queues to count.
     * @example
     * // Count the number of Queues
     * const count = await prisma.queue.count({
     *   where: {
     *     // ... the filter for the Queues we want to count
     *   }
     * })
    **/
    count<T extends QueueCountArgs>(
      args?: Subset<T, QueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueAggregateArgs>(args: Subset<T, QueueAggregateArgs>): Prisma.PrismaPromise<GetQueueAggregateType<T>>

    /**
     * Group by Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueGroupByArgs['orderBy'] }
        : { orderBy?: QueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Queue model
   */
  readonly fields: QueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    whatsapps<T extends Queue$whatsappsArgs<ExtArgs> = {}>(args?: Subset<T, Queue$whatsappsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Queue$usersArgs<ExtArgs> = {}>(args?: Subset<T, Queue$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    options<T extends Queue$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Queue$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findMany"> | Null>
    queueIntegrations<T extends Queue$queueIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, Queue$queueIntegrationsArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prompt<T extends Queue$promptArgs<ExtArgs> = {}>(args?: Subset<T, Queue$promptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany"> | Null>
    UserQueue<T extends Queue$UserQueueArgs<ExtArgs> = {}>(args?: Subset<T, Queue$UserQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findMany"> | Null>
    WhatsappQueue<T extends Queue$WhatsappQueueArgs<ExtArgs> = {}>(args?: Subset<T, Queue$WhatsappQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findMany"> | Null>
    Ticket<T extends Queue$TicketArgs<ExtArgs> = {}>(args?: Subset<T, Queue$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    Message<T extends Queue$MessageArgs<ExtArgs> = {}>(args?: Subset<T, Queue$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    Company<T extends Queue$CompanyArgs<ExtArgs> = {}>(args?: Subset<T, Queue$CompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Queue model
   */ 
  interface QueueFieldRefs {
    readonly id: FieldRef<"Queue", 'Int'>
    readonly name: FieldRef<"Queue", 'String'>
    readonly color: FieldRef<"Queue", 'String'>
    readonly greetingMessage: FieldRef<"Queue", 'String'>
    readonly outOfHoursMessage: FieldRef<"Queue", 'String'>
    readonly schedules: FieldRef<"Queue", 'Json'>
    readonly createdAt: FieldRef<"Queue", 'DateTime'>
    readonly updatedAt: FieldRef<"Queue", 'DateTime'>
    readonly companyId: FieldRef<"Queue", 'Int'>
    readonly orderQueue: FieldRef<"Queue", 'Int'>
    readonly integrationId: FieldRef<"Queue", 'Int'>
    readonly promptId: FieldRef<"Queue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Queue findUnique
   */
  export type QueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue findUniqueOrThrow
   */
  export type QueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue findFirst
   */
  export type QueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue findFirstOrThrow
   */
  export type QueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue findMany
   */
  export type QueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queues to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue create
   */
  export type QueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The data needed to create a Queue.
     */
    data: XOR<QueueCreateInput, QueueUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue createMany
   */
  export type QueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Queue update
   */
  export type QueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The data needed to update a Queue.
     */
    data: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>
    /**
     * Choose, which Queue to update.
     */
    where: QueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue updateMany
   */
  export type QueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput
  }

  /**
   * Queue upsert
   */
  export type QueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The filter to search for the Queue to update in case it exists.
     */
    where: QueueWhereUniqueInput
    /**
     * In case the Queue found by the `where` argument doesn't exist, create a new Queue with this data.
     */
    create: XOR<QueueCreateInput, QueueUncheckedCreateInput>
    /**
     * In case the Queue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue delete
   */
  export type QueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter which Queue to delete.
     */
    where: QueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Queue deleteMany
   */
  export type QueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queues to delete
     */
    where?: QueueWhereInput
  }

  /**
   * Queue.whatsapps
   */
  export type Queue$whatsappsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    cursor?: WhatsappWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappScalarFieldEnum | WhatsappScalarFieldEnum[]
  }

  /**
   * Queue.users
   */
  export type Queue$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Queue.options
   */
  export type Queue$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    where?: QueueOptionWhereInput
    orderBy?: QueueOptionOrderByWithRelationInput | QueueOptionOrderByWithRelationInput[]
    cursor?: QueueOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueOptionScalarFieldEnum | QueueOptionScalarFieldEnum[]
  }

  /**
   * Queue.queueIntegrations
   */
  export type Queue$queueIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    where?: QueueIntegrationsWhereInput
  }

  /**
   * Queue.prompt
   */
  export type Queue$promptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    cursor?: PromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Queue.UserQueue
   */
  export type Queue$UserQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    where?: UserQueueWhereInput
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    cursor?: UserQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
  }

  /**
   * Queue.WhatsappQueue
   */
  export type Queue$WhatsappQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    where?: WhatsappQueueWhereInput
    orderBy?: WhatsappQueueOrderByWithRelationInput | WhatsappQueueOrderByWithRelationInput[]
    cursor?: WhatsappQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappQueueScalarFieldEnum | WhatsappQueueScalarFieldEnum[]
  }

  /**
   * Queue.Ticket
   */
  export type Queue$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Queue.Message
   */
  export type Queue$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Queue.Company
   */
  export type Queue$CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Queue without action
   */
  export type QueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
  }


  /**
   * Model QueueIntegrations
   */

  export type AggregateQueueIntegrations = {
    _count: QueueIntegrationsCountAggregateOutputType | null
    _avg: QueueIntegrationsAvgAggregateOutputType | null
    _sum: QueueIntegrationsSumAggregateOutputType | null
    _min: QueueIntegrationsMinAggregateOutputType | null
    _max: QueueIntegrationsMaxAggregateOutputType | null
  }

  export type QueueIntegrationsAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    typebotExpires: number | null
    typebotDelayMessage: number | null
  }

  export type QueueIntegrationsSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    typebotExpires: number | null
    typebotDelayMessage: number | null
  }

  export type QueueIntegrationsMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    projectName: string | null
    jsonContent: string | null
    language: string | null
    urlN8N: string | null
    companyId: number | null
    typebotSlug: string | null
    typebotExpires: number | null
    typebotKeywordFinish: string | null
    typebotUnknownMessage: string | null
    typebotDelayMessage: number | null
    typebotKeywordRestart: string | null
    typebotRestartMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueueIntegrationsMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    projectName: string | null
    jsonContent: string | null
    language: string | null
    urlN8N: string | null
    companyId: number | null
    typebotSlug: string | null
    typebotExpires: number | null
    typebotKeywordFinish: string | null
    typebotUnknownMessage: string | null
    typebotDelayMessage: number | null
    typebotKeywordRestart: string | null
    typebotRestartMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueueIntegrationsCountAggregateOutputType = {
    id: number
    type: number
    name: number
    projectName: number
    jsonContent: number
    language: number
    urlN8N: number
    companyId: number
    typebotSlug: number
    typebotExpires: number
    typebotKeywordFinish: number
    typebotUnknownMessage: number
    typebotDelayMessage: number
    typebotKeywordRestart: number
    typebotRestartMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QueueIntegrationsAvgAggregateInputType = {
    id?: true
    companyId?: true
    typebotExpires?: true
    typebotDelayMessage?: true
  }

  export type QueueIntegrationsSumAggregateInputType = {
    id?: true
    companyId?: true
    typebotExpires?: true
    typebotDelayMessage?: true
  }

  export type QueueIntegrationsMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    projectName?: true
    jsonContent?: true
    language?: true
    urlN8N?: true
    companyId?: true
    typebotSlug?: true
    typebotExpires?: true
    typebotKeywordFinish?: true
    typebotUnknownMessage?: true
    typebotDelayMessage?: true
    typebotKeywordRestart?: true
    typebotRestartMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueueIntegrationsMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    projectName?: true
    jsonContent?: true
    language?: true
    urlN8N?: true
    companyId?: true
    typebotSlug?: true
    typebotExpires?: true
    typebotKeywordFinish?: true
    typebotUnknownMessage?: true
    typebotDelayMessage?: true
    typebotKeywordRestart?: true
    typebotRestartMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueueIntegrationsCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    projectName?: true
    jsonContent?: true
    language?: true
    urlN8N?: true
    companyId?: true
    typebotSlug?: true
    typebotExpires?: true
    typebotKeywordFinish?: true
    typebotUnknownMessage?: true
    typebotDelayMessage?: true
    typebotKeywordRestart?: true
    typebotRestartMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QueueIntegrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueIntegrations to aggregate.
     */
    where?: QueueIntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueIntegrations to fetch.
     */
    orderBy?: QueueIntegrationsOrderByWithRelationInput | QueueIntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueIntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueIntegrations
    **/
    _count?: true | QueueIntegrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueIntegrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueIntegrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueIntegrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueIntegrationsMaxAggregateInputType
  }

  export type GetQueueIntegrationsAggregateType<T extends QueueIntegrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueIntegrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueIntegrations[P]>
      : GetScalarType<T[P], AggregateQueueIntegrations[P]>
  }




  export type QueueIntegrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueIntegrationsWhereInput
    orderBy?: QueueIntegrationsOrderByWithAggregationInput | QueueIntegrationsOrderByWithAggregationInput[]
    by: QueueIntegrationsScalarFieldEnum[] | QueueIntegrationsScalarFieldEnum
    having?: QueueIntegrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueIntegrationsCountAggregateInputType | true
    _avg?: QueueIntegrationsAvgAggregateInputType
    _sum?: QueueIntegrationsSumAggregateInputType
    _min?: QueueIntegrationsMinAggregateInputType
    _max?: QueueIntegrationsMaxAggregateInputType
  }

  export type QueueIntegrationsGroupByOutputType = {
    id: number
    type: string
    name: string
    projectName: string
    jsonContent: string | null
    language: string | null
    urlN8N: string | null
    companyId: number
    typebotSlug: string | null
    typebotExpires: number | null
    typebotKeywordFinish: string | null
    typebotUnknownMessage: string | null
    typebotDelayMessage: number | null
    typebotKeywordRestart: string | null
    typebotRestartMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: QueueIntegrationsCountAggregateOutputType | null
    _avg: QueueIntegrationsAvgAggregateOutputType | null
    _sum: QueueIntegrationsSumAggregateOutputType | null
    _min: QueueIntegrationsMinAggregateOutputType | null
    _max: QueueIntegrationsMaxAggregateOutputType | null
  }

  type GetQueueIntegrationsGroupByPayload<T extends QueueIntegrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueIntegrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueIntegrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueIntegrationsGroupByOutputType[P]>
            : GetScalarType<T[P], QueueIntegrationsGroupByOutputType[P]>
        }
      >
    >


  export type QueueIntegrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    projectName?: boolean
    jsonContent?: boolean
    language?: boolean
    urlN8N?: boolean
    companyId?: boolean
    typebotSlug?: boolean
    typebotExpires?: boolean
    typebotKeywordFinish?: boolean
    typebotUnknownMessage?: boolean
    typebotDelayMessage?: boolean
    typebotKeywordRestart?: boolean
    typebotRestartMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    Ticket?: boolean | QueueIntegrations$TicketArgs<ExtArgs>
    Queue?: boolean | QueueIntegrations$QueueArgs<ExtArgs>
    _count?: boolean | QueueIntegrationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueIntegrations"]>


  export type QueueIntegrationsSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    projectName?: boolean
    jsonContent?: boolean
    language?: boolean
    urlN8N?: boolean
    companyId?: boolean
    typebotSlug?: boolean
    typebotExpires?: boolean
    typebotKeywordFinish?: boolean
    typebotUnknownMessage?: boolean
    typebotDelayMessage?: boolean
    typebotKeywordRestart?: boolean
    typebotRestartMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QueueIntegrationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    Ticket?: boolean | QueueIntegrations$TicketArgs<ExtArgs>
    Queue?: boolean | QueueIntegrations$QueueArgs<ExtArgs>
    _count?: boolean | QueueIntegrationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QueueIntegrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueIntegrations"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
      Queue: Prisma.$QueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      name: string
      projectName: string
      jsonContent: string | null
      language: string | null
      urlN8N: string | null
      companyId: number
      typebotSlug: string | null
      typebotExpires: number | null
      typebotKeywordFinish: string | null
      typebotUnknownMessage: string | null
      typebotDelayMessage: number | null
      typebotKeywordRestart: string | null
      typebotRestartMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["queueIntegrations"]>
    composites: {}
  }

  type QueueIntegrationsGetPayload<S extends boolean | null | undefined | QueueIntegrationsDefaultArgs> = $Result.GetResult<Prisma.$QueueIntegrationsPayload, S>

  type QueueIntegrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QueueIntegrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: QueueIntegrationsCountAggregateInputType | true
    }

  export interface QueueIntegrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueIntegrations'], meta: { name: 'QueueIntegrations' } }
    /**
     * Find zero or one QueueIntegrations that matches the filter.
     * @param {QueueIntegrationsFindUniqueArgs} args - Arguments to find a QueueIntegrations
     * @example
     * // Get one QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueIntegrationsFindUniqueArgs>(args: SelectSubset<T, QueueIntegrationsFindUniqueArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QueueIntegrations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QueueIntegrationsFindUniqueOrThrowArgs} args - Arguments to find a QueueIntegrations
     * @example
     * // Get one QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueIntegrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueIntegrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QueueIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsFindFirstArgs} args - Arguments to find a QueueIntegrations
     * @example
     * // Get one QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueIntegrationsFindFirstArgs>(args?: SelectSubset<T, QueueIntegrationsFindFirstArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QueueIntegrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsFindFirstOrThrowArgs} args - Arguments to find a QueueIntegrations
     * @example
     * // Get one QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueIntegrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueIntegrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QueueIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.findMany()
     * 
     * // Get first 10 QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueIntegrationsWithIdOnly = await prisma.queueIntegrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueIntegrationsFindManyArgs>(args?: SelectSubset<T, QueueIntegrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QueueIntegrations.
     * @param {QueueIntegrationsCreateArgs} args - Arguments to create a QueueIntegrations.
     * @example
     * // Create one QueueIntegrations
     * const QueueIntegrations = await prisma.queueIntegrations.create({
     *   data: {
     *     // ... data to create a QueueIntegrations
     *   }
     * })
     * 
     */
    create<T extends QueueIntegrationsCreateArgs>(args: SelectSubset<T, QueueIntegrationsCreateArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QueueIntegrations.
     * @param {QueueIntegrationsCreateManyArgs} args - Arguments to create many QueueIntegrations.
     * @example
     * // Create many QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueIntegrationsCreateManyArgs>(args?: SelectSubset<T, QueueIntegrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QueueIntegrations.
     * @param {QueueIntegrationsDeleteArgs} args - Arguments to delete one QueueIntegrations.
     * @example
     * // Delete one QueueIntegrations
     * const QueueIntegrations = await prisma.queueIntegrations.delete({
     *   where: {
     *     // ... filter to delete one QueueIntegrations
     *   }
     * })
     * 
     */
    delete<T extends QueueIntegrationsDeleteArgs>(args: SelectSubset<T, QueueIntegrationsDeleteArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QueueIntegrations.
     * @param {QueueIntegrationsUpdateArgs} args - Arguments to update one QueueIntegrations.
     * @example
     * // Update one QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueIntegrationsUpdateArgs>(args: SelectSubset<T, QueueIntegrationsUpdateArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QueueIntegrations.
     * @param {QueueIntegrationsDeleteManyArgs} args - Arguments to filter QueueIntegrations to delete.
     * @example
     * // Delete a few QueueIntegrations
     * const { count } = await prisma.queueIntegrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueIntegrationsDeleteManyArgs>(args?: SelectSubset<T, QueueIntegrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueIntegrationsUpdateManyArgs>(args: SelectSubset<T, QueueIntegrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QueueIntegrations.
     * @param {QueueIntegrationsUpsertArgs} args - Arguments to update or create a QueueIntegrations.
     * @example
     * // Update or create a QueueIntegrations
     * const queueIntegrations = await prisma.queueIntegrations.upsert({
     *   create: {
     *     // ... data to create a QueueIntegrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueIntegrations we want to update
     *   }
     * })
     */
    upsert<T extends QueueIntegrationsUpsertArgs>(args: SelectSubset<T, QueueIntegrationsUpsertArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QueueIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsCountArgs} args - Arguments to filter QueueIntegrations to count.
     * @example
     * // Count the number of QueueIntegrations
     * const count = await prisma.queueIntegrations.count({
     *   where: {
     *     // ... the filter for the QueueIntegrations we want to count
     *   }
     * })
    **/
    count<T extends QueueIntegrationsCountArgs>(
      args?: Subset<T, QueueIntegrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueIntegrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueIntegrationsAggregateArgs>(args: Subset<T, QueueIntegrationsAggregateArgs>): Prisma.PrismaPromise<GetQueueIntegrationsAggregateType<T>>

    /**
     * Group by QueueIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueIntegrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueIntegrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueIntegrationsGroupByArgs['orderBy'] }
        : { orderBy?: QueueIntegrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueIntegrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueIntegrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueIntegrations model
   */
  readonly fields: QueueIntegrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueIntegrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueIntegrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Ticket<T extends QueueIntegrations$TicketArgs<ExtArgs> = {}>(args?: Subset<T, QueueIntegrations$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    Queue<T extends QueueIntegrations$QueueArgs<ExtArgs> = {}>(args?: Subset<T, QueueIntegrations$QueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueIntegrations model
   */ 
  interface QueueIntegrationsFieldRefs {
    readonly id: FieldRef<"QueueIntegrations", 'Int'>
    readonly type: FieldRef<"QueueIntegrations", 'String'>
    readonly name: FieldRef<"QueueIntegrations", 'String'>
    readonly projectName: FieldRef<"QueueIntegrations", 'String'>
    readonly jsonContent: FieldRef<"QueueIntegrations", 'String'>
    readonly language: FieldRef<"QueueIntegrations", 'String'>
    readonly urlN8N: FieldRef<"QueueIntegrations", 'String'>
    readonly companyId: FieldRef<"QueueIntegrations", 'Int'>
    readonly typebotSlug: FieldRef<"QueueIntegrations", 'String'>
    readonly typebotExpires: FieldRef<"QueueIntegrations", 'Int'>
    readonly typebotKeywordFinish: FieldRef<"QueueIntegrations", 'String'>
    readonly typebotUnknownMessage: FieldRef<"QueueIntegrations", 'String'>
    readonly typebotDelayMessage: FieldRef<"QueueIntegrations", 'Int'>
    readonly typebotKeywordRestart: FieldRef<"QueueIntegrations", 'String'>
    readonly typebotRestartMessage: FieldRef<"QueueIntegrations", 'String'>
    readonly createdAt: FieldRef<"QueueIntegrations", 'DateTime'>
    readonly updatedAt: FieldRef<"QueueIntegrations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueueIntegrations findUnique
   */
  export type QueueIntegrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which QueueIntegrations to fetch.
     */
    where: QueueIntegrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations findUniqueOrThrow
   */
  export type QueueIntegrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which QueueIntegrations to fetch.
     */
    where: QueueIntegrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations findFirst
   */
  export type QueueIntegrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which QueueIntegrations to fetch.
     */
    where?: QueueIntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueIntegrations to fetch.
     */
    orderBy?: QueueIntegrationsOrderByWithRelationInput | QueueIntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueIntegrations.
     */
    cursor?: QueueIntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueIntegrations.
     */
    distinct?: QueueIntegrationsScalarFieldEnum | QueueIntegrationsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations findFirstOrThrow
   */
  export type QueueIntegrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which QueueIntegrations to fetch.
     */
    where?: QueueIntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueIntegrations to fetch.
     */
    orderBy?: QueueIntegrationsOrderByWithRelationInput | QueueIntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueIntegrations.
     */
    cursor?: QueueIntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueIntegrations.
     */
    distinct?: QueueIntegrationsScalarFieldEnum | QueueIntegrationsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations findMany
   */
  export type QueueIntegrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which QueueIntegrations to fetch.
     */
    where?: QueueIntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueIntegrations to fetch.
     */
    orderBy?: QueueIntegrationsOrderByWithRelationInput | QueueIntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueIntegrations.
     */
    cursor?: QueueIntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueIntegrations.
     */
    skip?: number
    distinct?: QueueIntegrationsScalarFieldEnum | QueueIntegrationsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations create
   */
  export type QueueIntegrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * The data needed to create a QueueIntegrations.
     */
    data: XOR<QueueIntegrationsCreateInput, QueueIntegrationsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations createMany
   */
  export type QueueIntegrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueIntegrations.
     */
    data: QueueIntegrationsCreateManyInput | QueueIntegrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueIntegrations update
   */
  export type QueueIntegrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * The data needed to update a QueueIntegrations.
     */
    data: XOR<QueueIntegrationsUpdateInput, QueueIntegrationsUncheckedUpdateInput>
    /**
     * Choose, which QueueIntegrations to update.
     */
    where: QueueIntegrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations updateMany
   */
  export type QueueIntegrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueIntegrations.
     */
    data: XOR<QueueIntegrationsUpdateManyMutationInput, QueueIntegrationsUncheckedUpdateManyInput>
    /**
     * Filter which QueueIntegrations to update
     */
    where?: QueueIntegrationsWhereInput
  }

  /**
   * QueueIntegrations upsert
   */
  export type QueueIntegrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * The filter to search for the QueueIntegrations to update in case it exists.
     */
    where: QueueIntegrationsWhereUniqueInput
    /**
     * In case the QueueIntegrations found by the `where` argument doesn't exist, create a new QueueIntegrations with this data.
     */
    create: XOR<QueueIntegrationsCreateInput, QueueIntegrationsUncheckedCreateInput>
    /**
     * In case the QueueIntegrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueIntegrationsUpdateInput, QueueIntegrationsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations delete
   */
  export type QueueIntegrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    /**
     * Filter which QueueIntegrations to delete.
     */
    where: QueueIntegrationsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueIntegrations deleteMany
   */
  export type QueueIntegrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueIntegrations to delete
     */
    where?: QueueIntegrationsWhereInput
  }

  /**
   * QueueIntegrations.Ticket
   */
  export type QueueIntegrations$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * QueueIntegrations.Queue
   */
  export type QueueIntegrations$QueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    cursor?: QueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * QueueIntegrations without action
   */
  export type QueueIntegrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
  }


  /**
   * Model QueueOption
   */

  export type AggregateQueueOption = {
    _count: QueueOptionCountAggregateOutputType | null
    _avg: QueueOptionAvgAggregateOutputType | null
    _sum: QueueOptionSumAggregateOutputType | null
    _min: QueueOptionMinAggregateOutputType | null
    _max: QueueOptionMaxAggregateOutputType | null
  }

  export type QueueOptionAvgAggregateOutputType = {
    id: number | null
    queueId: number | null
    parentId: number | null
  }

  export type QueueOptionSumAggregateOutputType = {
    id: number | null
    queueId: number | null
    parentId: number | null
  }

  export type QueueOptionMinAggregateOutputType = {
    id: number | null
    title: string | null
    message: string | null
    option: string | null
    queueId: number | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueueOptionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    message: string | null
    option: string | null
    queueId: number | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueueOptionCountAggregateOutputType = {
    id: number
    title: number
    message: number
    option: number
    queueId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QueueOptionAvgAggregateInputType = {
    id?: true
    queueId?: true
    parentId?: true
  }

  export type QueueOptionSumAggregateInputType = {
    id?: true
    queueId?: true
    parentId?: true
  }

  export type QueueOptionMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    option?: true
    queueId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueueOptionMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    option?: true
    queueId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueueOptionCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    option?: true
    queueId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QueueOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueOption to aggregate.
     */
    where?: QueueOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueOptions to fetch.
     */
    orderBy?: QueueOptionOrderByWithRelationInput | QueueOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueOptions
    **/
    _count?: true | QueueOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueOptionMaxAggregateInputType
  }

  export type GetQueueOptionAggregateType<T extends QueueOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueOption[P]>
      : GetScalarType<T[P], AggregateQueueOption[P]>
  }




  export type QueueOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueOptionWhereInput
    orderBy?: QueueOptionOrderByWithAggregationInput | QueueOptionOrderByWithAggregationInput[]
    by: QueueOptionScalarFieldEnum[] | QueueOptionScalarFieldEnum
    having?: QueueOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueOptionCountAggregateInputType | true
    _avg?: QueueOptionAvgAggregateInputType
    _sum?: QueueOptionSumAggregateInputType
    _min?: QueueOptionMinAggregateInputType
    _max?: QueueOptionMaxAggregateInputType
  }

  export type QueueOptionGroupByOutputType = {
    id: number
    title: string
    message: string | null
    option: string | null
    queueId: number
    parentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: QueueOptionCountAggregateOutputType | null
    _avg: QueueOptionAvgAggregateOutputType | null
    _sum: QueueOptionSumAggregateOutputType | null
    _min: QueueOptionMinAggregateOutputType | null
    _max: QueueOptionMaxAggregateOutputType | null
  }

  type GetQueueOptionGroupByPayload<T extends QueueOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueOptionGroupByOutputType[P]>
            : GetScalarType<T[P], QueueOptionGroupByOutputType[P]>
        }
      >
    >


  export type QueueOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    option?: boolean
    queueId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    queue?: boolean | QueueDefaultArgs<ExtArgs>
    parent?: boolean | QueueOption$parentArgs<ExtArgs>
    Ticket?: boolean | QueueOption$TicketArgs<ExtArgs>
    QueueOption?: boolean | QueueOption$QueueOptionArgs<ExtArgs>
    _count?: boolean | QueueOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueOption"]>


  export type QueueOptionSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    option?: boolean
    queueId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QueueOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queue?: boolean | QueueDefaultArgs<ExtArgs>
    parent?: boolean | QueueOption$parentArgs<ExtArgs>
    Ticket?: boolean | QueueOption$TicketArgs<ExtArgs>
    QueueOption?: boolean | QueueOption$QueueOptionArgs<ExtArgs>
    _count?: boolean | QueueOptionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QueueOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueOption"
    objects: {
      queue: Prisma.$QueuePayload<ExtArgs>
      parent: Prisma.$QueueOptionPayload<ExtArgs> | null
      Ticket: Prisma.$TicketPayload<ExtArgs>[]
      QueueOption: Prisma.$QueueOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      message: string | null
      option: string | null
      queueId: number
      parentId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["queueOption"]>
    composites: {}
  }

  type QueueOptionGetPayload<S extends boolean | null | undefined | QueueOptionDefaultArgs> = $Result.GetResult<Prisma.$QueueOptionPayload, S>

  type QueueOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QueueOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: QueueOptionCountAggregateInputType | true
    }

  export interface QueueOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueOption'], meta: { name: 'QueueOption' } }
    /**
     * Find zero or one QueueOption that matches the filter.
     * @param {QueueOptionFindUniqueArgs} args - Arguments to find a QueueOption
     * @example
     * // Get one QueueOption
     * const queueOption = await prisma.queueOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueOptionFindUniqueArgs>(args: SelectSubset<T, QueueOptionFindUniqueArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QueueOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QueueOptionFindUniqueOrThrowArgs} args - Arguments to find a QueueOption
     * @example
     * // Get one QueueOption
     * const queueOption = await prisma.queueOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QueueOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionFindFirstArgs} args - Arguments to find a QueueOption
     * @example
     * // Get one QueueOption
     * const queueOption = await prisma.queueOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueOptionFindFirstArgs>(args?: SelectSubset<T, QueueOptionFindFirstArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QueueOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionFindFirstOrThrowArgs} args - Arguments to find a QueueOption
     * @example
     * // Get one QueueOption
     * const queueOption = await prisma.queueOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QueueOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueOptions
     * const queueOptions = await prisma.queueOption.findMany()
     * 
     * // Get first 10 QueueOptions
     * const queueOptions = await prisma.queueOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueOptionWithIdOnly = await prisma.queueOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueOptionFindManyArgs>(args?: SelectSubset<T, QueueOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QueueOption.
     * @param {QueueOptionCreateArgs} args - Arguments to create a QueueOption.
     * @example
     * // Create one QueueOption
     * const QueueOption = await prisma.queueOption.create({
     *   data: {
     *     // ... data to create a QueueOption
     *   }
     * })
     * 
     */
    create<T extends QueueOptionCreateArgs>(args: SelectSubset<T, QueueOptionCreateArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QueueOptions.
     * @param {QueueOptionCreateManyArgs} args - Arguments to create many QueueOptions.
     * @example
     * // Create many QueueOptions
     * const queueOption = await prisma.queueOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueOptionCreateManyArgs>(args?: SelectSubset<T, QueueOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QueueOption.
     * @param {QueueOptionDeleteArgs} args - Arguments to delete one QueueOption.
     * @example
     * // Delete one QueueOption
     * const QueueOption = await prisma.queueOption.delete({
     *   where: {
     *     // ... filter to delete one QueueOption
     *   }
     * })
     * 
     */
    delete<T extends QueueOptionDeleteArgs>(args: SelectSubset<T, QueueOptionDeleteArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QueueOption.
     * @param {QueueOptionUpdateArgs} args - Arguments to update one QueueOption.
     * @example
     * // Update one QueueOption
     * const queueOption = await prisma.queueOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueOptionUpdateArgs>(args: SelectSubset<T, QueueOptionUpdateArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QueueOptions.
     * @param {QueueOptionDeleteManyArgs} args - Arguments to filter QueueOptions to delete.
     * @example
     * // Delete a few QueueOptions
     * const { count } = await prisma.queueOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueOptionDeleteManyArgs>(args?: SelectSubset<T, QueueOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueOptions
     * const queueOption = await prisma.queueOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueOptionUpdateManyArgs>(args: SelectSubset<T, QueueOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QueueOption.
     * @param {QueueOptionUpsertArgs} args - Arguments to update or create a QueueOption.
     * @example
     * // Update or create a QueueOption
     * const queueOption = await prisma.queueOption.upsert({
     *   create: {
     *     // ... data to create a QueueOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueOption we want to update
     *   }
     * })
     */
    upsert<T extends QueueOptionUpsertArgs>(args: SelectSubset<T, QueueOptionUpsertArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QueueOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionCountArgs} args - Arguments to filter QueueOptions to count.
     * @example
     * // Count the number of QueueOptions
     * const count = await prisma.queueOption.count({
     *   where: {
     *     // ... the filter for the QueueOptions we want to count
     *   }
     * })
    **/
    count<T extends QueueOptionCountArgs>(
      args?: Subset<T, QueueOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueOptionAggregateArgs>(args: Subset<T, QueueOptionAggregateArgs>): Prisma.PrismaPromise<GetQueueOptionAggregateType<T>>

    /**
     * Group by QueueOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueOptionGroupByArgs['orderBy'] }
        : { orderBy?: QueueOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueOption model
   */
  readonly fields: QueueOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    queue<T extends QueueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueDefaultArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends QueueOption$parentArgs<ExtArgs> = {}>(args?: Subset<T, QueueOption$parentArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Ticket<T extends QueueOption$TicketArgs<ExtArgs> = {}>(args?: Subset<T, QueueOption$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    QueueOption<T extends QueueOption$QueueOptionArgs<ExtArgs> = {}>(args?: Subset<T, QueueOption$QueueOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueOption model
   */ 
  interface QueueOptionFieldRefs {
    readonly id: FieldRef<"QueueOption", 'Int'>
    readonly title: FieldRef<"QueueOption", 'String'>
    readonly message: FieldRef<"QueueOption", 'String'>
    readonly option: FieldRef<"QueueOption", 'String'>
    readonly queueId: FieldRef<"QueueOption", 'Int'>
    readonly parentId: FieldRef<"QueueOption", 'Int'>
    readonly createdAt: FieldRef<"QueueOption", 'DateTime'>
    readonly updatedAt: FieldRef<"QueueOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueueOption findUnique
   */
  export type QueueOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * Filter, which QueueOption to fetch.
     */
    where: QueueOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption findUniqueOrThrow
   */
  export type QueueOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * Filter, which QueueOption to fetch.
     */
    where: QueueOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption findFirst
   */
  export type QueueOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * Filter, which QueueOption to fetch.
     */
    where?: QueueOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueOptions to fetch.
     */
    orderBy?: QueueOptionOrderByWithRelationInput | QueueOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueOptions.
     */
    cursor?: QueueOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueOptions.
     */
    distinct?: QueueOptionScalarFieldEnum | QueueOptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption findFirstOrThrow
   */
  export type QueueOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * Filter, which QueueOption to fetch.
     */
    where?: QueueOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueOptions to fetch.
     */
    orderBy?: QueueOptionOrderByWithRelationInput | QueueOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueOptions.
     */
    cursor?: QueueOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueOptions.
     */
    distinct?: QueueOptionScalarFieldEnum | QueueOptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption findMany
   */
  export type QueueOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * Filter, which QueueOptions to fetch.
     */
    where?: QueueOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueOptions to fetch.
     */
    orderBy?: QueueOptionOrderByWithRelationInput | QueueOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueOptions.
     */
    cursor?: QueueOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueOptions.
     */
    skip?: number
    distinct?: QueueOptionScalarFieldEnum | QueueOptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption create
   */
  export type QueueOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a QueueOption.
     */
    data: XOR<QueueOptionCreateInput, QueueOptionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption createMany
   */
  export type QueueOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueOptions.
     */
    data: QueueOptionCreateManyInput | QueueOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueOption update
   */
  export type QueueOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a QueueOption.
     */
    data: XOR<QueueOptionUpdateInput, QueueOptionUncheckedUpdateInput>
    /**
     * Choose, which QueueOption to update.
     */
    where: QueueOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption updateMany
   */
  export type QueueOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueOptions.
     */
    data: XOR<QueueOptionUpdateManyMutationInput, QueueOptionUncheckedUpdateManyInput>
    /**
     * Filter which QueueOptions to update
     */
    where?: QueueOptionWhereInput
  }

  /**
   * QueueOption upsert
   */
  export type QueueOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the QueueOption to update in case it exists.
     */
    where: QueueOptionWhereUniqueInput
    /**
     * In case the QueueOption found by the `where` argument doesn't exist, create a new QueueOption with this data.
     */
    create: XOR<QueueOptionCreateInput, QueueOptionUncheckedCreateInput>
    /**
     * In case the QueueOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueOptionUpdateInput, QueueOptionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption delete
   */
  export type QueueOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    /**
     * Filter which QueueOption to delete.
     */
    where: QueueOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QueueOption deleteMany
   */
  export type QueueOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueOptions to delete
     */
    where?: QueueOptionWhereInput
  }

  /**
   * QueueOption.parent
   */
  export type QueueOption$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    where?: QueueOptionWhereInput
  }

  /**
   * QueueOption.Ticket
   */
  export type QueueOption$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * QueueOption.QueueOption
   */
  export type QueueOption$QueueOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
    where?: QueueOptionWhereInput
    orderBy?: QueueOptionOrderByWithRelationInput | QueueOptionOrderByWithRelationInput[]
    cursor?: QueueOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueOptionScalarFieldEnum | QueueOptionScalarFieldEnum[]
  }

  /**
   * QueueOption without action
   */
  export type QueueOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueOption
     */
    select?: QueueOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueOptionInclude<ExtArgs> | null
  }


  /**
   * Model QuickMessage
   */

  export type AggregateQuickMessage = {
    _count: QuickMessageCountAggregateOutputType | null
    _avg: QuickMessageAvgAggregateOutputType | null
    _sum: QuickMessageSumAggregateOutputType | null
    _min: QuickMessageMinAggregateOutputType | null
    _max: QuickMessageMaxAggregateOutputType | null
  }

  export type QuickMessageAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    userId: number | null
  }

  export type QuickMessageSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    userId: number | null
  }

  export type QuickMessageMinAggregateOutputType = {
    id: number | null
    shortcode: string | null
    message: string | null
    mediaName: string | null
    mediaPath: string | null
    companyId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuickMessageMaxAggregateOutputType = {
    id: number | null
    shortcode: string | null
    message: string | null
    mediaName: string | null
    mediaPath: string | null
    companyId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuickMessageCountAggregateOutputType = {
    id: number
    shortcode: number
    message: number
    mediaName: number
    mediaPath: number
    companyId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuickMessageAvgAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
  }

  export type QuickMessageSumAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
  }

  export type QuickMessageMinAggregateInputType = {
    id?: true
    shortcode?: true
    message?: true
    mediaName?: true
    mediaPath?: true
    companyId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuickMessageMaxAggregateInputType = {
    id?: true
    shortcode?: true
    message?: true
    mediaName?: true
    mediaPath?: true
    companyId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuickMessageCountAggregateInputType = {
    id?: true
    shortcode?: true
    message?: true
    mediaName?: true
    mediaPath?: true
    companyId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuickMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickMessage to aggregate.
     */
    where?: QuickMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickMessages to fetch.
     */
    orderBy?: QuickMessageOrderByWithRelationInput | QuickMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuickMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuickMessages
    **/
    _count?: true | QuickMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuickMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuickMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuickMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuickMessageMaxAggregateInputType
  }

  export type GetQuickMessageAggregateType<T extends QuickMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateQuickMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuickMessage[P]>
      : GetScalarType<T[P], AggregateQuickMessage[P]>
  }




  export type QuickMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuickMessageWhereInput
    orderBy?: QuickMessageOrderByWithAggregationInput | QuickMessageOrderByWithAggregationInput[]
    by: QuickMessageScalarFieldEnum[] | QuickMessageScalarFieldEnum
    having?: QuickMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuickMessageCountAggregateInputType | true
    _avg?: QuickMessageAvgAggregateInputType
    _sum?: QuickMessageSumAggregateInputType
    _min?: QuickMessageMinAggregateInputType
    _max?: QuickMessageMaxAggregateInputType
  }

  export type QuickMessageGroupByOutputType = {
    id: number
    shortcode: string
    message: string
    mediaName: string | null
    mediaPath: string | null
    companyId: number
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: QuickMessageCountAggregateOutputType | null
    _avg: QuickMessageAvgAggregateOutputType | null
    _sum: QuickMessageSumAggregateOutputType | null
    _min: QuickMessageMinAggregateOutputType | null
    _max: QuickMessageMaxAggregateOutputType | null
  }

  type GetQuickMessageGroupByPayload<T extends QuickMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuickMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuickMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuickMessageGroupByOutputType[P]>
            : GetScalarType<T[P], QuickMessageGroupByOutputType[P]>
        }
      >
    >


  export type QuickMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shortcode?: boolean
    message?: boolean
    mediaName?: boolean
    mediaPath?: boolean
    companyId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quickMessage"]>


  export type QuickMessageSelectScalar = {
    id?: boolean
    shortcode?: boolean
    message?: boolean
    mediaName?: boolean
    mediaPath?: boolean
    companyId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuickMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuickMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuickMessage"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shortcode: string
      message: string
      mediaName: string | null
      mediaPath: string | null
      companyId: number
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quickMessage"]>
    composites: {}
  }

  type QuickMessageGetPayload<S extends boolean | null | undefined | QuickMessageDefaultArgs> = $Result.GetResult<Prisma.$QuickMessagePayload, S>

  type QuickMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuickMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: QuickMessageCountAggregateInputType | true
    }

  export interface QuickMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuickMessage'], meta: { name: 'QuickMessage' } }
    /**
     * Find zero or one QuickMessage that matches the filter.
     * @param {QuickMessageFindUniqueArgs} args - Arguments to find a QuickMessage
     * @example
     * // Get one QuickMessage
     * const quickMessage = await prisma.quickMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuickMessageFindUniqueArgs>(args: SelectSubset<T, QuickMessageFindUniqueArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuickMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuickMessageFindUniqueOrThrowArgs} args - Arguments to find a QuickMessage
     * @example
     * // Get one QuickMessage
     * const quickMessage = await prisma.quickMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuickMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, QuickMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuickMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageFindFirstArgs} args - Arguments to find a QuickMessage
     * @example
     * // Get one QuickMessage
     * const quickMessage = await prisma.quickMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuickMessageFindFirstArgs>(args?: SelectSubset<T, QuickMessageFindFirstArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuickMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageFindFirstOrThrowArgs} args - Arguments to find a QuickMessage
     * @example
     * // Get one QuickMessage
     * const quickMessage = await prisma.quickMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuickMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, QuickMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuickMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuickMessages
     * const quickMessages = await prisma.quickMessage.findMany()
     * 
     * // Get first 10 QuickMessages
     * const quickMessages = await prisma.quickMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quickMessageWithIdOnly = await prisma.quickMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuickMessageFindManyArgs>(args?: SelectSubset<T, QuickMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuickMessage.
     * @param {QuickMessageCreateArgs} args - Arguments to create a QuickMessage.
     * @example
     * // Create one QuickMessage
     * const QuickMessage = await prisma.quickMessage.create({
     *   data: {
     *     // ... data to create a QuickMessage
     *   }
     * })
     * 
     */
    create<T extends QuickMessageCreateArgs>(args: SelectSubset<T, QuickMessageCreateArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuickMessages.
     * @param {QuickMessageCreateManyArgs} args - Arguments to create many QuickMessages.
     * @example
     * // Create many QuickMessages
     * const quickMessage = await prisma.quickMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuickMessageCreateManyArgs>(args?: SelectSubset<T, QuickMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuickMessage.
     * @param {QuickMessageDeleteArgs} args - Arguments to delete one QuickMessage.
     * @example
     * // Delete one QuickMessage
     * const QuickMessage = await prisma.quickMessage.delete({
     *   where: {
     *     // ... filter to delete one QuickMessage
     *   }
     * })
     * 
     */
    delete<T extends QuickMessageDeleteArgs>(args: SelectSubset<T, QuickMessageDeleteArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuickMessage.
     * @param {QuickMessageUpdateArgs} args - Arguments to update one QuickMessage.
     * @example
     * // Update one QuickMessage
     * const quickMessage = await prisma.quickMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuickMessageUpdateArgs>(args: SelectSubset<T, QuickMessageUpdateArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuickMessages.
     * @param {QuickMessageDeleteManyArgs} args - Arguments to filter QuickMessages to delete.
     * @example
     * // Delete a few QuickMessages
     * const { count } = await prisma.quickMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuickMessageDeleteManyArgs>(args?: SelectSubset<T, QuickMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuickMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuickMessages
     * const quickMessage = await prisma.quickMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuickMessageUpdateManyArgs>(args: SelectSubset<T, QuickMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuickMessage.
     * @param {QuickMessageUpsertArgs} args - Arguments to update or create a QuickMessage.
     * @example
     * // Update or create a QuickMessage
     * const quickMessage = await prisma.quickMessage.upsert({
     *   create: {
     *     // ... data to create a QuickMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuickMessage we want to update
     *   }
     * })
     */
    upsert<T extends QuickMessageUpsertArgs>(args: SelectSubset<T, QuickMessageUpsertArgs<ExtArgs>>): Prisma__QuickMessageClient<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuickMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageCountArgs} args - Arguments to filter QuickMessages to count.
     * @example
     * // Count the number of QuickMessages
     * const count = await prisma.quickMessage.count({
     *   where: {
     *     // ... the filter for the QuickMessages we want to count
     *   }
     * })
    **/
    count<T extends QuickMessageCountArgs>(
      args?: Subset<T, QuickMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuickMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuickMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuickMessageAggregateArgs>(args: Subset<T, QuickMessageAggregateArgs>): Prisma.PrismaPromise<GetQuickMessageAggregateType<T>>

    /**
     * Group by QuickMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuickMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuickMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuickMessageGroupByArgs['orderBy'] }
        : { orderBy?: QuickMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuickMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuickMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuickMessage model
   */
  readonly fields: QuickMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuickMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuickMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuickMessage model
   */ 
  interface QuickMessageFieldRefs {
    readonly id: FieldRef<"QuickMessage", 'Int'>
    readonly shortcode: FieldRef<"QuickMessage", 'String'>
    readonly message: FieldRef<"QuickMessage", 'String'>
    readonly mediaName: FieldRef<"QuickMessage", 'String'>
    readonly mediaPath: FieldRef<"QuickMessage", 'String'>
    readonly companyId: FieldRef<"QuickMessage", 'Int'>
    readonly userId: FieldRef<"QuickMessage", 'Int'>
    readonly createdAt: FieldRef<"QuickMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"QuickMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuickMessage findUnique
   */
  export type QuickMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * Filter, which QuickMessage to fetch.
     */
    where: QuickMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage findUniqueOrThrow
   */
  export type QuickMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * Filter, which QuickMessage to fetch.
     */
    where: QuickMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage findFirst
   */
  export type QuickMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * Filter, which QuickMessage to fetch.
     */
    where?: QuickMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickMessages to fetch.
     */
    orderBy?: QuickMessageOrderByWithRelationInput | QuickMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickMessages.
     */
    cursor?: QuickMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickMessages.
     */
    distinct?: QuickMessageScalarFieldEnum | QuickMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage findFirstOrThrow
   */
  export type QuickMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * Filter, which QuickMessage to fetch.
     */
    where?: QuickMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickMessages to fetch.
     */
    orderBy?: QuickMessageOrderByWithRelationInput | QuickMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuickMessages.
     */
    cursor?: QuickMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuickMessages.
     */
    distinct?: QuickMessageScalarFieldEnum | QuickMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage findMany
   */
  export type QuickMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * Filter, which QuickMessages to fetch.
     */
    where?: QuickMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuickMessages to fetch.
     */
    orderBy?: QuickMessageOrderByWithRelationInput | QuickMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuickMessages.
     */
    cursor?: QuickMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuickMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuickMessages.
     */
    skip?: number
    distinct?: QuickMessageScalarFieldEnum | QuickMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage create
   */
  export type QuickMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a QuickMessage.
     */
    data: XOR<QuickMessageCreateInput, QuickMessageUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage createMany
   */
  export type QuickMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuickMessages.
     */
    data: QuickMessageCreateManyInput | QuickMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuickMessage update
   */
  export type QuickMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a QuickMessage.
     */
    data: XOR<QuickMessageUpdateInput, QuickMessageUncheckedUpdateInput>
    /**
     * Choose, which QuickMessage to update.
     */
    where: QuickMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage updateMany
   */
  export type QuickMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuickMessages.
     */
    data: XOR<QuickMessageUpdateManyMutationInput, QuickMessageUncheckedUpdateManyInput>
    /**
     * Filter which QuickMessages to update
     */
    where?: QuickMessageWhereInput
  }

  /**
   * QuickMessage upsert
   */
  export type QuickMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the QuickMessage to update in case it exists.
     */
    where: QuickMessageWhereUniqueInput
    /**
     * In case the QuickMessage found by the `where` argument doesn't exist, create a new QuickMessage with this data.
     */
    create: XOR<QuickMessageCreateInput, QuickMessageUncheckedCreateInput>
    /**
     * In case the QuickMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuickMessageUpdateInput, QuickMessageUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage delete
   */
  export type QuickMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    /**
     * Filter which QuickMessage to delete.
     */
    where: QuickMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QuickMessage deleteMany
   */
  export type QuickMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuickMessages to delete
     */
    where?: QuickMessageWhereInput
  }

  /**
   * QuickMessage without action
   */
  export type QuickMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type RatingSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: number | null
    name: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: number | null
    name: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    name: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type RatingSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    name?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: number
    name: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>


  export type RatingSelectScalar = {
    id?: boolean
    name?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      Company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */ 
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'Int'>
    readonly name: FieldRef<"Rating", 'String'>
    readonly companyId: FieldRef<"Rating", 'Int'>
    readonly createdAt: FieldRef<"Rating", 'DateTime'>
    readonly updatedAt: FieldRef<"Rating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    id: number | null
    contactId: number | null
    ticketId: number | null
    userId: number | null
    companyId: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    id: number | null
    contactId: number | null
    ticketId: number | null
    userId: number | null
    companyId: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: number | null
    body: string | null
    sendAt: Date | null
    sentAt: Date | null
    status: string | null
    mediaPath: string | null
    mediaName: string | null
    contactId: number | null
    ticketId: number | null
    userId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: number | null
    body: string | null
    sendAt: Date | null
    sentAt: Date | null
    status: string | null
    mediaPath: string | null
    mediaName: string | null
    contactId: number | null
    ticketId: number | null
    userId: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    body: number
    sendAt: number
    sentAt: number
    status: number
    mediaPath: number
    mediaName: number
    contactId: number
    ticketId: number
    userId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    id?: true
    contactId?: true
    ticketId?: true
    userId?: true
    companyId?: true
  }

  export type ScheduleSumAggregateInputType = {
    id?: true
    contactId?: true
    ticketId?: true
    userId?: true
    companyId?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    body?: true
    sendAt?: true
    sentAt?: true
    status?: true
    mediaPath?: true
    mediaName?: true
    contactId?: true
    ticketId?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    body?: true
    sendAt?: true
    sentAt?: true
    status?: true
    mediaPath?: true
    mediaName?: true
    contactId?: true
    ticketId?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    body?: true
    sendAt?: true
    sentAt?: true
    status?: true
    mediaPath?: true
    mediaName?: true
    contactId?: true
    ticketId?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: number
    body: string
    sendAt: Date
    sentAt: Date | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    userId: number
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    sendAt?: boolean
    sentAt?: boolean
    status?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    contactId?: boolean
    ticketId?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>


  export type ScheduleSelectScalar = {
    id?: boolean
    body?: boolean
    sendAt?: boolean
    sentAt?: boolean
    status?: boolean
    mediaPath?: boolean
    mediaName?: boolean
    contactId?: boolean
    ticketId?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      body: string
      sendAt: Date
      sentAt: Date | null
      status: string
      mediaPath: string
      mediaName: string
      contactId: number
      ticketId: number
      userId: number
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */ 
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'Int'>
    readonly body: FieldRef<"Schedule", 'String'>
    readonly sendAt: FieldRef<"Schedule", 'DateTime'>
    readonly sentAt: FieldRef<"Schedule", 'DateTime'>
    readonly status: FieldRef<"Schedule", 'String'>
    readonly mediaPath: FieldRef<"Schedule", 'String'>
    readonly mediaName: FieldRef<"Schedule", 'String'>
    readonly contactId: FieldRef<"Schedule", 'Int'>
    readonly ticketId: FieldRef<"Schedule", 'Int'>
    readonly userId: FieldRef<"Schedule", 'Int'>
    readonly companyId: FieldRef<"Schedule", 'Int'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type SettingSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type SettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type SettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type SettingSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: number
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    companyId: number
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["setting"]>


  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type SettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
      companyId: number
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'Int'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
    readonly companyId: FieldRef<"Setting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    userPriceCents: number | null
    whatsPriceCents: number | null
    companyId: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    userPriceCents: number | null
    whatsPriceCents: number | null
    companyId: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    userPriceCents: number | null
    whatsPriceCents: number | null
    lastInvoiceUrl: string | null
    lastPlanChange: Date | null
    expiresAt: Date | null
    providerSubscriptionId: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    userPriceCents: number | null
    whatsPriceCents: number | null
    lastInvoiceUrl: string | null
    lastPlanChange: Date | null
    expiresAt: Date | null
    providerSubscriptionId: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    isActive: number
    userPriceCents: number
    whatsPriceCents: number
    lastInvoiceUrl: number
    lastPlanChange: number
    expiresAt: number
    providerSubscriptionId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    userPriceCents?: true
    whatsPriceCents?: true
    companyId?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    userPriceCents?: true
    whatsPriceCents?: true
    companyId?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    isActive?: true
    userPriceCents?: true
    whatsPriceCents?: true
    lastInvoiceUrl?: true
    lastPlanChange?: true
    expiresAt?: true
    providerSubscriptionId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    isActive?: true
    userPriceCents?: true
    whatsPriceCents?: true
    lastInvoiceUrl?: true
    lastPlanChange?: true
    expiresAt?: true
    providerSubscriptionId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    isActive?: true
    userPriceCents?: true
    whatsPriceCents?: true
    lastInvoiceUrl?: true
    lastPlanChange?: true
    expiresAt?: true
    providerSubscriptionId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    isActive: boolean
    userPriceCents: number | null
    whatsPriceCents: number | null
    lastInvoiceUrl: string | null
    lastPlanChange: Date | null
    expiresAt: Date | null
    providerSubscriptionId: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    userPriceCents?: boolean
    whatsPriceCents?: boolean
    lastInvoiceUrl?: boolean
    lastPlanChange?: boolean
    expiresAt?: boolean
    providerSubscriptionId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>


  export type SubscriptionSelectScalar = {
    id?: boolean
    isActive?: boolean
    userPriceCents?: boolean
    whatsPriceCents?: boolean
    lastInvoiceUrl?: boolean
    lastPlanChange?: boolean
    expiresAt?: boolean
    providerSubscriptionId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isActive: boolean
      userPriceCents: number | null
      whatsPriceCents: number | null
      lastInvoiceUrl: string | null
      lastPlanChange: Date | null
      expiresAt: Date | null
      providerSubscriptionId: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly isActive: FieldRef<"Subscription", 'Boolean'>
    readonly userPriceCents: FieldRef<"Subscription", 'Int'>
    readonly whatsPriceCents: FieldRef<"Subscription", 'Int'>
    readonly lastInvoiceUrl: FieldRef<"Subscription", 'String'>
    readonly lastPlanChange: FieldRef<"Subscription", 'DateTime'>
    readonly expiresAt: FieldRef<"Subscription", 'DateTime'>
    readonly providerSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly companyId: FieldRef<"Subscription", 'Int'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    kanban: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    kanban: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    companyId: number | null
    kanban: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    companyId: number | null
    kanban: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    companyId: number
    kanban: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    companyId?: true
    kanban?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    companyId?: true
    kanban?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    companyId?: true
    kanban?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    companyId?: true
    kanban?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    companyId?: true
    kanban?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    color: string
    companyId: number
    kanban: number
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    companyId?: boolean
    kanban?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ticketTags?: boolean | Tag$ticketTagsArgs<ExtArgs>
    tickets?: boolean | Tag$ticketsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>


  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    companyId?: boolean
    kanban?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    ticketTags?: boolean | Tag$ticketTagsArgs<ExtArgs>
    tickets?: boolean | Tag$ticketsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      ticketTags: Prisma.$TicketTagPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
      companyId: number
      kanban: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ticketTags<T extends Tag$ticketTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$ticketTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends Tag$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly companyId: FieldRef<"Tag", 'Int'>
    readonly kanban: FieldRef<"Tag", 'Int'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }

  /**
   * Tag.ticketTags
   */
  export type Tag$ticketTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    cursor?: TicketTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * Tag.tickets
   */
  export type Tag$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    id: number | null
    unreadMessages: number | null
    userId: number | null
    contactId: number | null
    whatsappId: number | null
    queueId: number | null
    queueOptionId: number | null
    companyId: number | null
    integrationId: number | null
    promptId: number | null
    amountUsedBotQueues: number | null
  }

  export type TicketSumAggregateOutputType = {
    id: number | null
    unreadMessages: number | null
    userId: number | null
    contactId: number | null
    whatsappId: number | null
    queueId: number | null
    queueOptionId: number | null
    companyId: number | null
    integrationId: number | null
    promptId: number | null
    amountUsedBotQueues: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: number | null
    status: string | null
    unreadMessages: number | null
    lastMessage: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    contactId: number | null
    whatsappId: number | null
    queueId: number | null
    chatbot: boolean | null
    queueOptionId: number | null
    companyId: number | null
    uuid: string | null
    useIntegration: boolean | null
    integrationId: number | null
    typebotSessionId: string | null
    typebotStatus: boolean | null
    promptId: number | null
    fromMe: boolean | null
    amountUsedBotQueues: number | null
    isBot: boolean | null
  }

  export type TicketMaxAggregateOutputType = {
    id: number | null
    status: string | null
    unreadMessages: number | null
    lastMessage: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    contactId: number | null
    whatsappId: number | null
    queueId: number | null
    chatbot: boolean | null
    queueOptionId: number | null
    companyId: number | null
    uuid: string | null
    useIntegration: boolean | null
    integrationId: number | null
    typebotSessionId: string | null
    typebotStatus: boolean | null
    promptId: number | null
    fromMe: boolean | null
    amountUsedBotQueues: number | null
    isBot: boolean | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    status: number
    unreadMessages: number
    lastMessage: number
    isGroup: number
    createdAt: number
    updatedAt: number
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot: number
    queueOptionId: number
    companyId: number
    uuid: number
    useIntegration: number
    integrationId: number
    typebotSessionId: number
    typebotStatus: number
    promptId: number
    fromMe: number
    amountUsedBotQueues: number
    isBot: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    id?: true
    unreadMessages?: true
    userId?: true
    contactId?: true
    whatsappId?: true
    queueId?: true
    queueOptionId?: true
    companyId?: true
    integrationId?: true
    promptId?: true
    amountUsedBotQueues?: true
  }

  export type TicketSumAggregateInputType = {
    id?: true
    unreadMessages?: true
    userId?: true
    contactId?: true
    whatsappId?: true
    queueId?: true
    queueOptionId?: true
    companyId?: true
    integrationId?: true
    promptId?: true
    amountUsedBotQueues?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    status?: true
    unreadMessages?: true
    lastMessage?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    contactId?: true
    whatsappId?: true
    queueId?: true
    chatbot?: true
    queueOptionId?: true
    companyId?: true
    uuid?: true
    useIntegration?: true
    integrationId?: true
    typebotSessionId?: true
    typebotStatus?: true
    promptId?: true
    fromMe?: true
    amountUsedBotQueues?: true
    isBot?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    status?: true
    unreadMessages?: true
    lastMessage?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    contactId?: true
    whatsappId?: true
    queueId?: true
    chatbot?: true
    queueOptionId?: true
    companyId?: true
    uuid?: true
    useIntegration?: true
    integrationId?: true
    typebotSessionId?: true
    typebotStatus?: true
    promptId?: true
    fromMe?: true
    amountUsedBotQueues?: true
    isBot?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    status?: true
    unreadMessages?: true
    lastMessage?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    contactId?: true
    whatsappId?: true
    queueId?: true
    chatbot?: true
    queueOptionId?: true
    companyId?: true
    uuid?: true
    useIntegration?: true
    integrationId?: true
    typebotSessionId?: true
    typebotStatus?: true
    promptId?: true
    fromMe?: true
    amountUsedBotQueues?: true
    isBot?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: number
    status: string
    unreadMessages: number | null
    lastMessage: string | null
    isGroup: boolean
    createdAt: Date
    updatedAt: Date
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot: boolean | null
    queueOptionId: number
    companyId: number
    uuid: string
    useIntegration: boolean | null
    integrationId: number | null
    typebotSessionId: string | null
    typebotStatus: boolean
    promptId: number | null
    fromMe: boolean | null
    amountUsedBotQueues: number
    isBot: boolean | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    unreadMessages?: boolean
    lastMessage?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contactId?: boolean
    whatsappId?: boolean
    queueId?: boolean
    chatbot?: boolean
    queueOptionId?: boolean
    companyId?: boolean
    uuid?: boolean
    useIntegration?: boolean
    integrationId?: boolean
    typebotSessionId?: boolean
    typebotStatus?: boolean
    promptId?: boolean
    fromMe?: boolean
    amountUsedBotQueues?: boolean
    isBot?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
    queueOption?: boolean | QueueOptionDefaultArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    ticketTags?: boolean | Ticket$ticketTagsArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    queueIntegration?: boolean | Ticket$queueIntegrationArgs<ExtArgs>
    prompt?: boolean | Ticket$promptArgs<ExtArgs>
    UserRating?: boolean | Ticket$UserRatingArgs<ExtArgs>
    TicketTracking?: boolean | Ticket$TicketTrackingArgs<ExtArgs>
    TicketNote?: boolean | Ticket$TicketNoteArgs<ExtArgs>
    Schedule?: boolean | Ticket$ScheduleArgs<ExtArgs>
    Action_Logs?: boolean | Ticket$Action_LogsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>


  export type TicketSelectScalar = {
    id?: boolean
    status?: boolean
    unreadMessages?: boolean
    lastMessage?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contactId?: boolean
    whatsappId?: boolean
    queueId?: boolean
    chatbot?: boolean
    queueOptionId?: boolean
    companyId?: boolean
    uuid?: boolean
    useIntegration?: boolean
    integrationId?: boolean
    typebotSessionId?: boolean
    typebotStatus?: boolean
    promptId?: boolean
    fromMe?: boolean
    amountUsedBotQueues?: boolean
    isBot?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
    queueOption?: boolean | QueueOptionDefaultArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    ticketTags?: boolean | Ticket$ticketTagsArgs<ExtArgs>
    tags?: boolean | Ticket$tagsArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    queueIntegration?: boolean | Ticket$queueIntegrationArgs<ExtArgs>
    prompt?: boolean | Ticket$promptArgs<ExtArgs>
    UserRating?: boolean | Ticket$UserRatingArgs<ExtArgs>
    TicketTracking?: boolean | Ticket$TicketTrackingArgs<ExtArgs>
    TicketNote?: boolean | Ticket$TicketNoteArgs<ExtArgs>
    Schedule?: boolean | Ticket$ScheduleArgs<ExtArgs>
    Action_Logs?: boolean | Ticket$Action_LogsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      whatsapp: Prisma.$WhatsappPayload<ExtArgs>
      queue: Prisma.$QueuePayload<ExtArgs>
      queueOption: Prisma.$QueueOptionPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      ticketTags: Prisma.$TicketTagPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      queueIntegration: Prisma.$QueueIntegrationsPayload<ExtArgs> | null
      prompt: Prisma.$PromptPayload<ExtArgs> | null
      UserRating: Prisma.$UserRatingPayload<ExtArgs>[]
      TicketTracking: Prisma.$TicketTrackingPayload<ExtArgs>[]
      TicketNote: Prisma.$TicketNotePayload<ExtArgs>[]
      Schedule: Prisma.$SchedulePayload<ExtArgs>[]
      Action_Logs: Prisma.$Action_LogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
      unreadMessages: number | null
      lastMessage: string | null
      isGroup: boolean
      createdAt: Date
      updatedAt: Date
      userId: number
      contactId: number
      whatsappId: number
      queueId: number
      chatbot: boolean | null
      queueOptionId: number
      companyId: number
      uuid: string
      useIntegration: boolean | null
      integrationId: number | null
      typebotSessionId: string | null
      typebotStatus: boolean
      promptId: number | null
      fromMe: boolean | null
      amountUsedBotQueues: number
      isBot: boolean | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    whatsapp<T extends WhatsappDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappDefaultArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    queue<T extends QueueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueDefaultArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    queueOption<T extends QueueOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueOptionDefaultArgs<ExtArgs>>): Prisma__QueueOptionClient<$Result.GetResult<Prisma.$QueueOptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Ticket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    ticketTags<T extends Ticket$ticketTagsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$ticketTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends Ticket$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    queueIntegration<T extends Ticket$queueIntegrationArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$queueIntegrationArgs<ExtArgs>>): Prisma__QueueIntegrationsClient<$Result.GetResult<Prisma.$QueueIntegrationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prompt<T extends Ticket$promptArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$promptArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    UserRating<T extends Ticket$UserRatingArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$UserRatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findMany"> | Null>
    TicketTracking<T extends Ticket$TicketTrackingArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$TicketTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    TicketNote<T extends Ticket$TicketNoteArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$TicketNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany"> | Null>
    Schedule<T extends Ticket$ScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$ScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    Action_Logs<T extends Ticket$Action_LogsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$Action_LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'Int'>
    readonly status: FieldRef<"Ticket", 'String'>
    readonly unreadMessages: FieldRef<"Ticket", 'Int'>
    readonly lastMessage: FieldRef<"Ticket", 'String'>
    readonly isGroup: FieldRef<"Ticket", 'Boolean'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly userId: FieldRef<"Ticket", 'Int'>
    readonly contactId: FieldRef<"Ticket", 'Int'>
    readonly whatsappId: FieldRef<"Ticket", 'Int'>
    readonly queueId: FieldRef<"Ticket", 'Int'>
    readonly chatbot: FieldRef<"Ticket", 'Boolean'>
    readonly queueOptionId: FieldRef<"Ticket", 'Int'>
    readonly companyId: FieldRef<"Ticket", 'Int'>
    readonly uuid: FieldRef<"Ticket", 'String'>
    readonly useIntegration: FieldRef<"Ticket", 'Boolean'>
    readonly integrationId: FieldRef<"Ticket", 'Int'>
    readonly typebotSessionId: FieldRef<"Ticket", 'String'>
    readonly typebotStatus: FieldRef<"Ticket", 'Boolean'>
    readonly promptId: FieldRef<"Ticket", 'Int'>
    readonly fromMe: FieldRef<"Ticket", 'Boolean'>
    readonly amountUsedBotQueues: FieldRef<"Ticket", 'Int'>
    readonly isBot: FieldRef<"Ticket", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket.messages
   */
  export type Ticket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Ticket.ticketTags
   */
  export type Ticket$ticketTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    cursor?: TicketTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
  }

  /**
   * Ticket.tags
   */
  export type Ticket$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Ticket.queueIntegration
   */
  export type Ticket$queueIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueIntegrations
     */
    select?: QueueIntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIntegrationsInclude<ExtArgs> | null
    where?: QueueIntegrationsWhereInput
  }

  /**
   * Ticket.prompt
   */
  export type Ticket$promptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
  }

  /**
   * Ticket.UserRating
   */
  export type Ticket$UserRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    where?: UserRatingWhereInput
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    cursor?: UserRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * Ticket.TicketTracking
   */
  export type Ticket$TicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    where?: TicketTrackingWhereInput
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    cursor?: TicketTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
  }

  /**
   * Ticket.TicketNote
   */
  export type Ticket$TicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    cursor?: TicketNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * Ticket.Schedule
   */
  export type Ticket$ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Ticket.Action_Logs
   */
  export type Ticket$Action_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    where?: Action_LogsWhereInput
    orderBy?: Action_LogsOrderByWithRelationInput | Action_LogsOrderByWithRelationInput[]
    cursor?: Action_LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Action_LogsScalarFieldEnum | Action_LogsScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketNote
   */

  export type AggregateTicketNote = {
    _count: TicketNoteCountAggregateOutputType | null
    _avg: TicketNoteAvgAggregateOutputType | null
    _sum: TicketNoteSumAggregateOutputType | null
    _min: TicketNoteMinAggregateOutputType | null
    _max: TicketNoteMaxAggregateOutputType | null
  }

  export type TicketNoteAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    contactId: number | null
    ticketId: number | null
  }

  export type TicketNoteSumAggregateOutputType = {
    id: number | null
    userId: number | null
    contactId: number | null
    ticketId: number | null
  }

  export type TicketNoteMinAggregateOutputType = {
    id: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    contactId: number | null
    ticketId: number | null
  }

  export type TicketNoteMaxAggregateOutputType = {
    id: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    contactId: number | null
    ticketId: number | null
  }

  export type TicketNoteCountAggregateOutputType = {
    id: number
    note: number
    createdAt: number
    updatedAt: number
    userId: number
    contactId: number
    ticketId: number
    _all: number
  }


  export type TicketNoteAvgAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    ticketId?: true
  }

  export type TicketNoteSumAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    ticketId?: true
  }

  export type TicketNoteMinAggregateInputType = {
    id?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    contactId?: true
    ticketId?: true
  }

  export type TicketNoteMaxAggregateInputType = {
    id?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    contactId?: true
    ticketId?: true
  }

  export type TicketNoteCountAggregateInputType = {
    id?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    contactId?: true
    ticketId?: true
    _all?: true
  }

  export type TicketNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketNote to aggregate.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketNotes
    **/
    _count?: true | TicketNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketNoteMaxAggregateInputType
  }

  export type GetTicketNoteAggregateType<T extends TicketNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketNote[P]>
      : GetScalarType<T[P], AggregateTicketNote[P]>
  }




  export type TicketNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithAggregationInput | TicketNoteOrderByWithAggregationInput[]
    by: TicketNoteScalarFieldEnum[] | TicketNoteScalarFieldEnum
    having?: TicketNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketNoteCountAggregateInputType | true
    _avg?: TicketNoteAvgAggregateInputType
    _sum?: TicketNoteSumAggregateInputType
    _min?: TicketNoteMinAggregateInputType
    _max?: TicketNoteMaxAggregateInputType
  }

  export type TicketNoteGroupByOutputType = {
    id: number
    note: string
    createdAt: Date
    updatedAt: Date
    userId: number
    contactId: number
    ticketId: number
    _count: TicketNoteCountAggregateOutputType | null
    _avg: TicketNoteAvgAggregateOutputType | null
    _sum: TicketNoteSumAggregateOutputType | null
    _min: TicketNoteMinAggregateOutputType | null
    _max: TicketNoteMaxAggregateOutputType | null
  }

  type GetTicketNoteGroupByPayload<T extends TicketNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketNoteGroupByOutputType[P]>
            : GetScalarType<T[P], TicketNoteGroupByOutputType[P]>
        }
      >
    >


  export type TicketNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contactId?: boolean
    ticketId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketNote"]>


  export type TicketNoteSelectScalar = {
    id?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contactId?: boolean
    ticketId?: boolean
  }

  export type TicketNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketNote"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      note: string
      createdAt: Date
      updatedAt: Date
      userId: number
      contactId: number
      ticketId: number
    }, ExtArgs["result"]["ticketNote"]>
    composites: {}
  }

  type TicketNoteGetPayload<S extends boolean | null | undefined | TicketNoteDefaultArgs> = $Result.GetResult<Prisma.$TicketNotePayload, S>

  type TicketNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TicketNoteCountAggregateInputType | true
    }

  export interface TicketNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketNote'], meta: { name: 'TicketNote' } }
    /**
     * Find zero or one TicketNote that matches the filter.
     * @param {TicketNoteFindUniqueArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketNoteFindUniqueArgs>(args: SelectSubset<T, TicketNoteFindUniqueArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketNoteFindUniqueOrThrowArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteFindFirstArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketNoteFindFirstArgs>(args?: SelectSubset<T, TicketNoteFindFirstArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteFindFirstOrThrowArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketNotes
     * const ticketNotes = await prisma.ticketNote.findMany()
     * 
     * // Get first 10 TicketNotes
     * const ticketNotes = await prisma.ticketNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketNoteWithIdOnly = await prisma.ticketNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketNoteFindManyArgs>(args?: SelectSubset<T, TicketNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketNote.
     * @param {TicketNoteCreateArgs} args - Arguments to create a TicketNote.
     * @example
     * // Create one TicketNote
     * const TicketNote = await prisma.ticketNote.create({
     *   data: {
     *     // ... data to create a TicketNote
     *   }
     * })
     * 
     */
    create<T extends TicketNoteCreateArgs>(args: SelectSubset<T, TicketNoteCreateArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketNotes.
     * @param {TicketNoteCreateManyArgs} args - Arguments to create many TicketNotes.
     * @example
     * // Create many TicketNotes
     * const ticketNote = await prisma.ticketNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketNoteCreateManyArgs>(args?: SelectSubset<T, TicketNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketNote.
     * @param {TicketNoteDeleteArgs} args - Arguments to delete one TicketNote.
     * @example
     * // Delete one TicketNote
     * const TicketNote = await prisma.ticketNote.delete({
     *   where: {
     *     // ... filter to delete one TicketNote
     *   }
     * })
     * 
     */
    delete<T extends TicketNoteDeleteArgs>(args: SelectSubset<T, TicketNoteDeleteArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketNote.
     * @param {TicketNoteUpdateArgs} args - Arguments to update one TicketNote.
     * @example
     * // Update one TicketNote
     * const ticketNote = await prisma.ticketNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketNoteUpdateArgs>(args: SelectSubset<T, TicketNoteUpdateArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketNotes.
     * @param {TicketNoteDeleteManyArgs} args - Arguments to filter TicketNotes to delete.
     * @example
     * // Delete a few TicketNotes
     * const { count } = await prisma.ticketNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketNoteDeleteManyArgs>(args?: SelectSubset<T, TicketNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketNotes
     * const ticketNote = await prisma.ticketNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketNoteUpdateManyArgs>(args: SelectSubset<T, TicketNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketNote.
     * @param {TicketNoteUpsertArgs} args - Arguments to update or create a TicketNote.
     * @example
     * // Update or create a TicketNote
     * const ticketNote = await prisma.ticketNote.upsert({
     *   create: {
     *     // ... data to create a TicketNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketNote we want to update
     *   }
     * })
     */
    upsert<T extends TicketNoteUpsertArgs>(args: SelectSubset<T, TicketNoteUpsertArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteCountArgs} args - Arguments to filter TicketNotes to count.
     * @example
     * // Count the number of TicketNotes
     * const count = await prisma.ticketNote.count({
     *   where: {
     *     // ... the filter for the TicketNotes we want to count
     *   }
     * })
    **/
    count<T extends TicketNoteCountArgs>(
      args?: Subset<T, TicketNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketNoteAggregateArgs>(args: Subset<T, TicketNoteAggregateArgs>): Prisma.PrismaPromise<GetTicketNoteAggregateType<T>>

    /**
     * Group by TicketNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketNoteGroupByArgs['orderBy'] }
        : { orderBy?: TicketNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketNote model
   */
  readonly fields: TicketNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketNote model
   */ 
  interface TicketNoteFieldRefs {
    readonly id: FieldRef<"TicketNote", 'Int'>
    readonly note: FieldRef<"TicketNote", 'String'>
    readonly createdAt: FieldRef<"TicketNote", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketNote", 'DateTime'>
    readonly userId: FieldRef<"TicketNote", 'Int'>
    readonly contactId: FieldRef<"TicketNote", 'Int'>
    readonly ticketId: FieldRef<"TicketNote", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TicketNote findUnique
   */
  export type TicketNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where: TicketNoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote findUniqueOrThrow
   */
  export type TicketNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where: TicketNoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote findFirst
   */
  export type TicketNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketNotes.
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketNotes.
     */
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote findFirstOrThrow
   */
  export type TicketNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketNotes.
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketNotes.
     */
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote findMany
   */
  export type TicketNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNotes to fetch.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketNotes.
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote create
   */
  export type TicketNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketNote.
     */
    data: XOR<TicketNoteCreateInput, TicketNoteUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote createMany
   */
  export type TicketNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketNotes.
     */
    data: TicketNoteCreateManyInput | TicketNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketNote update
   */
  export type TicketNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketNote.
     */
    data: XOR<TicketNoteUpdateInput, TicketNoteUncheckedUpdateInput>
    /**
     * Choose, which TicketNote to update.
     */
    where: TicketNoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote updateMany
   */
  export type TicketNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketNotes.
     */
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyInput>
    /**
     * Filter which TicketNotes to update
     */
    where?: TicketNoteWhereInput
  }

  /**
   * TicketNote upsert
   */
  export type TicketNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketNote to update in case it exists.
     */
    where: TicketNoteWhereUniqueInput
    /**
     * In case the TicketNote found by the `where` argument doesn't exist, create a new TicketNote with this data.
     */
    create: XOR<TicketNoteCreateInput, TicketNoteUncheckedCreateInput>
    /**
     * In case the TicketNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketNoteUpdateInput, TicketNoteUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote delete
   */
  export type TicketNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter which TicketNote to delete.
     */
    where: TicketNoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketNote deleteMany
   */
  export type TicketNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketNotes to delete
     */
    where?: TicketNoteWhereInput
  }

  /**
   * TicketNote without action
   */
  export type TicketNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
  }


  /**
   * Model TicketTag
   */

  export type AggregateTicketTag = {
    _count: TicketTagCountAggregateOutputType | null
    _avg: TicketTagAvgAggregateOutputType | null
    _sum: TicketTagSumAggregateOutputType | null
    _min: TicketTagMinAggregateOutputType | null
    _max: TicketTagMaxAggregateOutputType | null
  }

  export type TicketTagAvgAggregateOutputType = {
    ticketId: number | null
    tagId: number | null
  }

  export type TicketTagSumAggregateOutputType = {
    ticketId: number | null
    tagId: number | null
  }

  export type TicketTagMinAggregateOutputType = {
    ticketId: number | null
    tagId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketTagMaxAggregateOutputType = {
    ticketId: number | null
    tagId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketTagCountAggregateOutputType = {
    ticketId: number
    tagId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketTagAvgAggregateInputType = {
    ticketId?: true
    tagId?: true
  }

  export type TicketTagSumAggregateInputType = {
    ticketId?: true
    tagId?: true
  }

  export type TicketTagMinAggregateInputType = {
    ticketId?: true
    tagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketTagMaxAggregateInputType = {
    ticketId?: true
    tagId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketTagCountAggregateInputType = {
    ticketId?: true
    tagId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTag to aggregate.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketTags
    **/
    _count?: true | TicketTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketTagMaxAggregateInputType
  }

  export type GetTicketTagAggregateType<T extends TicketTagAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketTag[P]>
      : GetScalarType<T[P], AggregateTicketTag[P]>
  }




  export type TicketTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTagWhereInput
    orderBy?: TicketTagOrderByWithAggregationInput | TicketTagOrderByWithAggregationInput[]
    by: TicketTagScalarFieldEnum[] | TicketTagScalarFieldEnum
    having?: TicketTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketTagCountAggregateInputType | true
    _avg?: TicketTagAvgAggregateInputType
    _sum?: TicketTagSumAggregateInputType
    _min?: TicketTagMinAggregateInputType
    _max?: TicketTagMaxAggregateInputType
  }

  export type TicketTagGroupByOutputType = {
    ticketId: number
    tagId: number
    createdAt: Date
    updatedAt: Date
    _count: TicketTagCountAggregateOutputType | null
    _avg: TicketTagAvgAggregateOutputType | null
    _sum: TicketTagSumAggregateOutputType | null
    _min: TicketTagMinAggregateOutputType | null
    _max: TicketTagMaxAggregateOutputType | null
  }

  type GetTicketTagGroupByPayload<T extends TicketTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketTagGroupByOutputType[P]>
            : GetScalarType<T[P], TicketTagGroupByOutputType[P]>
        }
      >
    >


  export type TicketTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ticketId?: boolean
    tagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTag"]>


  export type TicketTagSelectScalar = {
    ticketId?: boolean
    tagId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TicketTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketTag"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ticketId: number
      tagId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticketTag"]>
    composites: {}
  }

  type TicketTagGetPayload<S extends boolean | null | undefined | TicketTagDefaultArgs> = $Result.GetResult<Prisma.$TicketTagPayload, S>

  type TicketTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketTagFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TicketTagCountAggregateInputType | true
    }

  export interface TicketTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketTag'], meta: { name: 'TicketTag' } }
    /**
     * Find zero or one TicketTag that matches the filter.
     * @param {TicketTagFindUniqueArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketTagFindUniqueArgs>(args: SelectSubset<T, TicketTagFindUniqueArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketTagFindUniqueOrThrowArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketTagFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindFirstArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketTagFindFirstArgs>(args?: SelectSubset<T, TicketTagFindFirstArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindFirstOrThrowArgs} args - Arguments to find a TicketTag
     * @example
     * // Get one TicketTag
     * const ticketTag = await prisma.ticketTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketTagFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketTags
     * const ticketTags = await prisma.ticketTag.findMany()
     * 
     * // Get first 10 TicketTags
     * const ticketTags = await prisma.ticketTag.findMany({ take: 10 })
     * 
     * // Only select the `ticketId`
     * const ticketTagWithTicketIdOnly = await prisma.ticketTag.findMany({ select: { ticketId: true } })
     * 
     */
    findMany<T extends TicketTagFindManyArgs>(args?: SelectSubset<T, TicketTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketTag.
     * @param {TicketTagCreateArgs} args - Arguments to create a TicketTag.
     * @example
     * // Create one TicketTag
     * const TicketTag = await prisma.ticketTag.create({
     *   data: {
     *     // ... data to create a TicketTag
     *   }
     * })
     * 
     */
    create<T extends TicketTagCreateArgs>(args: SelectSubset<T, TicketTagCreateArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketTags.
     * @param {TicketTagCreateManyArgs} args - Arguments to create many TicketTags.
     * @example
     * // Create many TicketTags
     * const ticketTag = await prisma.ticketTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketTagCreateManyArgs>(args?: SelectSubset<T, TicketTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketTag.
     * @param {TicketTagDeleteArgs} args - Arguments to delete one TicketTag.
     * @example
     * // Delete one TicketTag
     * const TicketTag = await prisma.ticketTag.delete({
     *   where: {
     *     // ... filter to delete one TicketTag
     *   }
     * })
     * 
     */
    delete<T extends TicketTagDeleteArgs>(args: SelectSubset<T, TicketTagDeleteArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketTag.
     * @param {TicketTagUpdateArgs} args - Arguments to update one TicketTag.
     * @example
     * // Update one TicketTag
     * const ticketTag = await prisma.ticketTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketTagUpdateArgs>(args: SelectSubset<T, TicketTagUpdateArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketTags.
     * @param {TicketTagDeleteManyArgs} args - Arguments to filter TicketTags to delete.
     * @example
     * // Delete a few TicketTags
     * const { count } = await prisma.ticketTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketTagDeleteManyArgs>(args?: SelectSubset<T, TicketTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketTags
     * const ticketTag = await prisma.ticketTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketTagUpdateManyArgs>(args: SelectSubset<T, TicketTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketTag.
     * @param {TicketTagUpsertArgs} args - Arguments to update or create a TicketTag.
     * @example
     * // Update or create a TicketTag
     * const ticketTag = await prisma.ticketTag.upsert({
     *   create: {
     *     // ... data to create a TicketTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketTag we want to update
     *   }
     * })
     */
    upsert<T extends TicketTagUpsertArgs>(args: SelectSubset<T, TicketTagUpsertArgs<ExtArgs>>): Prisma__TicketTagClient<$Result.GetResult<Prisma.$TicketTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagCountArgs} args - Arguments to filter TicketTags to count.
     * @example
     * // Count the number of TicketTags
     * const count = await prisma.ticketTag.count({
     *   where: {
     *     // ... the filter for the TicketTags we want to count
     *   }
     * })
    **/
    count<T extends TicketTagCountArgs>(
      args?: Subset<T, TicketTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketTagAggregateArgs>(args: Subset<T, TicketTagAggregateArgs>): Prisma.PrismaPromise<GetTicketTagAggregateType<T>>

    /**
     * Group by TicketTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketTagGroupByArgs['orderBy'] }
        : { orderBy?: TicketTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketTag model
   */
  readonly fields: TicketTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketTag model
   */ 
  interface TicketTagFieldRefs {
    readonly ticketId: FieldRef<"TicketTag", 'Int'>
    readonly tagId: FieldRef<"TicketTag", 'Int'>
    readonly createdAt: FieldRef<"TicketTag", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketTag findUnique
   */
  export type TicketTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where: TicketTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag findUniqueOrThrow
   */
  export type TicketTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where: TicketTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag findFirst
   */
  export type TicketTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTags.
     */
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag findFirstOrThrow
   */
  export type TicketTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTag to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTags.
     */
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag findMany
   */
  export type TicketTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter, which TicketTags to fetch.
     */
    where?: TicketTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTags to fetch.
     */
    orderBy?: TicketTagOrderByWithRelationInput | TicketTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketTags.
     */
    cursor?: TicketTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTags.
     */
    skip?: number
    distinct?: TicketTagScalarFieldEnum | TicketTagScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag create
   */
  export type TicketTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketTag.
     */
    data: XOR<TicketTagCreateInput, TicketTagUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag createMany
   */
  export type TicketTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketTags.
     */
    data: TicketTagCreateManyInput | TicketTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTag update
   */
  export type TicketTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketTag.
     */
    data: XOR<TicketTagUpdateInput, TicketTagUncheckedUpdateInput>
    /**
     * Choose, which TicketTag to update.
     */
    where: TicketTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag updateMany
   */
  export type TicketTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketTags.
     */
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyInput>
    /**
     * Filter which TicketTags to update
     */
    where?: TicketTagWhereInput
  }

  /**
   * TicketTag upsert
   */
  export type TicketTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketTag to update in case it exists.
     */
    where: TicketTagWhereUniqueInput
    /**
     * In case the TicketTag found by the `where` argument doesn't exist, create a new TicketTag with this data.
     */
    create: XOR<TicketTagCreateInput, TicketTagUncheckedCreateInput>
    /**
     * In case the TicketTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketTagUpdateInput, TicketTagUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag delete
   */
  export type TicketTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
    /**
     * Filter which TicketTag to delete.
     */
    where: TicketTagWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTag deleteMany
   */
  export type TicketTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTags to delete
     */
    where?: TicketTagWhereInput
  }

  /**
   * TicketTag without action
   */
  export type TicketTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTag
     */
    select?: TicketTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTagInclude<ExtArgs> | null
  }


  /**
   * Model TicketTracking
   */

  export type AggregateTicketTracking = {
    _count: TicketTrackingCountAggregateOutputType | null
    _avg: TicketTrackingAvgAggregateOutputType | null
    _sum: TicketTrackingSumAggregateOutputType | null
    _min: TicketTrackingMinAggregateOutputType | null
    _max: TicketTrackingMaxAggregateOutputType | null
  }

  export type TicketTrackingAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    whatsappId: number | null
    userId: number | null
  }

  export type TicketTrackingSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    whatsappId: number | null
    userId: number | null
  }

  export type TicketTrackingMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    whatsappId: number | null
    userId: number | null
    rated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    queuedAt: Date | null
    finishedAt: Date | null
    closedAt: Date | null
    ratingAt: Date | null
    chatbotAt: Date | null
  }

  export type TicketTrackingMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    whatsappId: number | null
    userId: number | null
    rated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    queuedAt: Date | null
    finishedAt: Date | null
    closedAt: Date | null
    ratingAt: Date | null
    chatbotAt: Date | null
  }

  export type TicketTrackingCountAggregateOutputType = {
    id: number
    ticketId: number
    companyId: number
    whatsappId: number
    userId: number
    rated: number
    createdAt: number
    updatedAt: number
    startedAt: number
    queuedAt: number
    finishedAt: number
    closedAt: number
    ratingAt: number
    chatbotAt: number
    _all: number
  }


  export type TicketTrackingAvgAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    whatsappId?: true
    userId?: true
  }

  export type TicketTrackingSumAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    whatsappId?: true
    userId?: true
  }

  export type TicketTrackingMinAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    whatsappId?: true
    userId?: true
    rated?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    queuedAt?: true
    finishedAt?: true
    closedAt?: true
    ratingAt?: true
    chatbotAt?: true
  }

  export type TicketTrackingMaxAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    whatsappId?: true
    userId?: true
    rated?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    queuedAt?: true
    finishedAt?: true
    closedAt?: true
    ratingAt?: true
    chatbotAt?: true
  }

  export type TicketTrackingCountAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    whatsappId?: true
    userId?: true
    rated?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    queuedAt?: true
    finishedAt?: true
    closedAt?: true
    ratingAt?: true
    chatbotAt?: true
    _all?: true
  }

  export type TicketTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTracking to aggregate.
     */
    where?: TicketTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTrackings to fetch.
     */
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketTrackings
    **/
    _count?: true | TicketTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketTrackingMaxAggregateInputType
  }

  export type GetTicketTrackingAggregateType<T extends TicketTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketTracking[P]>
      : GetScalarType<T[P], AggregateTicketTracking[P]>
  }




  export type TicketTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTrackingWhereInput
    orderBy?: TicketTrackingOrderByWithAggregationInput | TicketTrackingOrderByWithAggregationInput[]
    by: TicketTrackingScalarFieldEnum[] | TicketTrackingScalarFieldEnum
    having?: TicketTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketTrackingCountAggregateInputType | true
    _avg?: TicketTrackingAvgAggregateInputType
    _sum?: TicketTrackingSumAggregateInputType
    _min?: TicketTrackingMinAggregateInputType
    _max?: TicketTrackingMaxAggregateInputType
  }

  export type TicketTrackingGroupByOutputType = {
    id: number
    ticketId: number
    companyId: number
    whatsappId: number | null
    userId: number | null
    rated: boolean
    createdAt: Date
    updatedAt: Date
    startedAt: Date
    queuedAt: Date
    finishedAt: Date | null
    closedAt: Date | null
    ratingAt: Date
    chatbotAt: Date
    _count: TicketTrackingCountAggregateOutputType | null
    _avg: TicketTrackingAvgAggregateOutputType | null
    _sum: TicketTrackingSumAggregateOutputType | null
    _min: TicketTrackingMinAggregateOutputType | null
    _max: TicketTrackingMaxAggregateOutputType | null
  }

  type GetTicketTrackingGroupByPayload<T extends TicketTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], TicketTrackingGroupByOutputType[P]>
        }
      >
    >


  export type TicketTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    companyId?: boolean
    whatsappId?: boolean
    userId?: boolean
    rated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    queuedAt?: boolean
    finishedAt?: boolean
    closedAt?: boolean
    ratingAt?: boolean
    chatbotAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapp?: boolean | TicketTracking$whatsappArgs<ExtArgs>
    user?: boolean | TicketTracking$userArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTracking"]>


  export type TicketTrackingSelectScalar = {
    id?: boolean
    ticketId?: boolean
    companyId?: boolean
    whatsappId?: boolean
    userId?: boolean
    rated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    queuedAt?: boolean
    finishedAt?: boolean
    closedAt?: boolean
    ratingAt?: boolean
    chatbotAt?: boolean
  }

  export type TicketTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapp?: boolean | TicketTracking$whatsappArgs<ExtArgs>
    user?: boolean | TicketTracking$userArgs<ExtArgs>
  }

  export type $TicketTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketTracking"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      whatsapp: Prisma.$WhatsappPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      companyId: number
      whatsappId: number | null
      userId: number | null
      rated: boolean
      createdAt: Date
      updatedAt: Date
      startedAt: Date
      queuedAt: Date
      finishedAt: Date | null
      closedAt: Date | null
      ratingAt: Date
      chatbotAt: Date
    }, ExtArgs["result"]["ticketTracking"]>
    composites: {}
  }

  type TicketTrackingGetPayload<S extends boolean | null | undefined | TicketTrackingDefaultArgs> = $Result.GetResult<Prisma.$TicketTrackingPayload, S>

  type TicketTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: TicketTrackingCountAggregateInputType | true
    }

  export interface TicketTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketTracking'], meta: { name: 'TicketTracking' } }
    /**
     * Find zero or one TicketTracking that matches the filter.
     * @param {TicketTrackingFindUniqueArgs} args - Arguments to find a TicketTracking
     * @example
     * // Get one TicketTracking
     * const ticketTracking = await prisma.ticketTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketTrackingFindUniqueArgs>(args: SelectSubset<T, TicketTrackingFindUniqueArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketTrackingFindUniqueOrThrowArgs} args - Arguments to find a TicketTracking
     * @example
     * // Get one TicketTracking
     * const ticketTracking = await prisma.ticketTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingFindFirstArgs} args - Arguments to find a TicketTracking
     * @example
     * // Get one TicketTracking
     * const ticketTracking = await prisma.ticketTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketTrackingFindFirstArgs>(args?: SelectSubset<T, TicketTrackingFindFirstArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingFindFirstOrThrowArgs} args - Arguments to find a TicketTracking
     * @example
     * // Get one TicketTracking
     * const ticketTracking = await prisma.ticketTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketTrackings
     * const ticketTrackings = await prisma.ticketTracking.findMany()
     * 
     * // Get first 10 TicketTrackings
     * const ticketTrackings = await prisma.ticketTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketTrackingWithIdOnly = await prisma.ticketTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketTrackingFindManyArgs>(args?: SelectSubset<T, TicketTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketTracking.
     * @param {TicketTrackingCreateArgs} args - Arguments to create a TicketTracking.
     * @example
     * // Create one TicketTracking
     * const TicketTracking = await prisma.ticketTracking.create({
     *   data: {
     *     // ... data to create a TicketTracking
     *   }
     * })
     * 
     */
    create<T extends TicketTrackingCreateArgs>(args: SelectSubset<T, TicketTrackingCreateArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketTrackings.
     * @param {TicketTrackingCreateManyArgs} args - Arguments to create many TicketTrackings.
     * @example
     * // Create many TicketTrackings
     * const ticketTracking = await prisma.ticketTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketTrackingCreateManyArgs>(args?: SelectSubset<T, TicketTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketTracking.
     * @param {TicketTrackingDeleteArgs} args - Arguments to delete one TicketTracking.
     * @example
     * // Delete one TicketTracking
     * const TicketTracking = await prisma.ticketTracking.delete({
     *   where: {
     *     // ... filter to delete one TicketTracking
     *   }
     * })
     * 
     */
    delete<T extends TicketTrackingDeleteArgs>(args: SelectSubset<T, TicketTrackingDeleteArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketTracking.
     * @param {TicketTrackingUpdateArgs} args - Arguments to update one TicketTracking.
     * @example
     * // Update one TicketTracking
     * const ticketTracking = await prisma.ticketTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketTrackingUpdateArgs>(args: SelectSubset<T, TicketTrackingUpdateArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketTrackings.
     * @param {TicketTrackingDeleteManyArgs} args - Arguments to filter TicketTrackings to delete.
     * @example
     * // Delete a few TicketTrackings
     * const { count } = await prisma.ticketTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketTrackingDeleteManyArgs>(args?: SelectSubset<T, TicketTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketTrackings
     * const ticketTracking = await prisma.ticketTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketTrackingUpdateManyArgs>(args: SelectSubset<T, TicketTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketTracking.
     * @param {TicketTrackingUpsertArgs} args - Arguments to update or create a TicketTracking.
     * @example
     * // Update or create a TicketTracking
     * const ticketTracking = await prisma.ticketTracking.upsert({
     *   create: {
     *     // ... data to create a TicketTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketTracking we want to update
     *   }
     * })
     */
    upsert<T extends TicketTrackingUpsertArgs>(args: SelectSubset<T, TicketTrackingUpsertArgs<ExtArgs>>): Prisma__TicketTrackingClient<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingCountArgs} args - Arguments to filter TicketTrackings to count.
     * @example
     * // Count the number of TicketTrackings
     * const count = await prisma.ticketTracking.count({
     *   where: {
     *     // ... the filter for the TicketTrackings we want to count
     *   }
     * })
    **/
    count<T extends TicketTrackingCountArgs>(
      args?: Subset<T, TicketTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketTrackingAggregateArgs>(args: Subset<T, TicketTrackingAggregateArgs>): Prisma.PrismaPromise<GetTicketTrackingAggregateType<T>>

    /**
     * Group by TicketTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketTrackingGroupByArgs['orderBy'] }
        : { orderBy?: TicketTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketTracking model
   */
  readonly fields: TicketTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    whatsapp<T extends TicketTracking$whatsappArgs<ExtArgs> = {}>(args?: Subset<T, TicketTracking$whatsappArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends TicketTracking$userArgs<ExtArgs> = {}>(args?: Subset<T, TicketTracking$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketTracking model
   */ 
  interface TicketTrackingFieldRefs {
    readonly id: FieldRef<"TicketTracking", 'Int'>
    readonly ticketId: FieldRef<"TicketTracking", 'Int'>
    readonly companyId: FieldRef<"TicketTracking", 'Int'>
    readonly whatsappId: FieldRef<"TicketTracking", 'Int'>
    readonly userId: FieldRef<"TicketTracking", 'Int'>
    readonly rated: FieldRef<"TicketTracking", 'Boolean'>
    readonly createdAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly startedAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly queuedAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly finishedAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly closedAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly ratingAt: FieldRef<"TicketTracking", 'DateTime'>
    readonly chatbotAt: FieldRef<"TicketTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketTracking findUnique
   */
  export type TicketTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * Filter, which TicketTracking to fetch.
     */
    where: TicketTrackingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking findUniqueOrThrow
   */
  export type TicketTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * Filter, which TicketTracking to fetch.
     */
    where: TicketTrackingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking findFirst
   */
  export type TicketTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * Filter, which TicketTracking to fetch.
     */
    where?: TicketTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTrackings to fetch.
     */
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTrackings.
     */
    cursor?: TicketTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTrackings.
     */
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking findFirstOrThrow
   */
  export type TicketTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * Filter, which TicketTracking to fetch.
     */
    where?: TicketTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTrackings to fetch.
     */
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTrackings.
     */
    cursor?: TicketTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTrackings.
     */
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking findMany
   */
  export type TicketTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * Filter, which TicketTrackings to fetch.
     */
    where?: TicketTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTrackings to fetch.
     */
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketTrackings.
     */
    cursor?: TicketTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTrackings.
     */
    skip?: number
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking create
   */
  export type TicketTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketTracking.
     */
    data: XOR<TicketTrackingCreateInput, TicketTrackingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking createMany
   */
  export type TicketTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketTrackings.
     */
    data: TicketTrackingCreateManyInput | TicketTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTracking update
   */
  export type TicketTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketTracking.
     */
    data: XOR<TicketTrackingUpdateInput, TicketTrackingUncheckedUpdateInput>
    /**
     * Choose, which TicketTracking to update.
     */
    where: TicketTrackingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking updateMany
   */
  export type TicketTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketTrackings.
     */
    data: XOR<TicketTrackingUpdateManyMutationInput, TicketTrackingUncheckedUpdateManyInput>
    /**
     * Filter which TicketTrackings to update
     */
    where?: TicketTrackingWhereInput
  }

  /**
   * TicketTracking upsert
   */
  export type TicketTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketTracking to update in case it exists.
     */
    where: TicketTrackingWhereUniqueInput
    /**
     * In case the TicketTracking found by the `where` argument doesn't exist, create a new TicketTracking with this data.
     */
    create: XOR<TicketTrackingCreateInput, TicketTrackingUncheckedCreateInput>
    /**
     * In case the TicketTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketTrackingUpdateInput, TicketTrackingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking delete
   */
  export type TicketTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    /**
     * Filter which TicketTracking to delete.
     */
    where: TicketTrackingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TicketTracking deleteMany
   */
  export type TicketTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTrackings to delete
     */
    where?: TicketTrackingWhereInput
  }

  /**
   * TicketTracking.whatsapp
   */
  export type TicketTracking$whatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
  }

  /**
   * TicketTracking.user
   */
  export type TicketTracking$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TicketTracking without action
   */
  export type TicketTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    tokenVersion: number | null
    companyId: number | null
    whatsappId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    tokenVersion: number | null
    companyId: number | null
    whatsappId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    passwordHash: string | null
    tokenVersion: number | null
    profile: string | null
    super: boolean | null
    online: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    whatsappId: number | null
    avatarUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    passwordHash: string | null
    tokenVersion: number | null
    profile: string | null
    super: boolean | null
    online: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    whatsappId: number | null
    avatarUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    passwordHash: number
    tokenVersion: number
    profile: number
    super: number
    online: number
    createdAt: number
    updatedAt: number
    companyId: number
    whatsappId: number
    avatarUrl: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    tokenVersion?: true
    companyId?: true
    whatsappId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    tokenVersion?: true
    companyId?: true
    whatsappId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    tokenVersion?: true
    profile?: true
    super?: true
    online?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    whatsappId?: true
    avatarUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    tokenVersion?: true
    profile?: true
    super?: true
    online?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    whatsappId?: true
    avatarUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    passwordHash?: true
    tokenVersion?: true
    profile?: true
    super?: true
    online?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    whatsappId?: true
    avatarUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    passwordHash: string
    tokenVersion: number
    profile: string
    super: boolean
    online: boolean
    createdAt: Date
    updatedAt: Date
    companyId: number
    whatsappId: number | null
    avatarUrl: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    tokenVersion?: boolean
    profile?: boolean
    super?: boolean
    online?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    whatsappId?: boolean
    avatarUrl?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapp?: boolean | User$whatsappArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    queues?: boolean | User$queuesArgs<ExtArgs>
    quickMessages?: boolean | User$quickMessagesArgs<ExtArgs>
    ChatUsers?: boolean | User$ChatUsersArgs<ExtArgs>
    UserQueue?: boolean | User$UserQueueArgs<ExtArgs>
    UserRating?: boolean | User$UserRatingArgs<ExtArgs>
    TicketTracking?: boolean | User$TicketTrackingArgs<ExtArgs>
    TicketNote?: boolean | User$TicketNoteArgs<ExtArgs>
    Schedule?: boolean | User$ScheduleArgs<ExtArgs>
    ChatMessage?: boolean | User$ChatMessageArgs<ExtArgs>
    Chat?: boolean | User$ChatArgs<ExtArgs>
    Action_Logs?: boolean | User$Action_LogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    tokenVersion?: boolean
    profile?: boolean
    super?: boolean
    online?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    whatsappId?: boolean
    avatarUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    whatsapp?: boolean | User$whatsappArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    queues?: boolean | User$queuesArgs<ExtArgs>
    quickMessages?: boolean | User$quickMessagesArgs<ExtArgs>
    ChatUsers?: boolean | User$ChatUsersArgs<ExtArgs>
    UserQueue?: boolean | User$UserQueueArgs<ExtArgs>
    UserRating?: boolean | User$UserRatingArgs<ExtArgs>
    TicketTracking?: boolean | User$TicketTrackingArgs<ExtArgs>
    TicketNote?: boolean | User$TicketNoteArgs<ExtArgs>
    Schedule?: boolean | User$ScheduleArgs<ExtArgs>
    ChatMessage?: boolean | User$ChatMessageArgs<ExtArgs>
    Chat?: boolean | User$ChatArgs<ExtArgs>
    Action_Logs?: boolean | User$Action_LogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      whatsapp: Prisma.$WhatsappPayload<ExtArgs> | null
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      queues: Prisma.$QueuePayload<ExtArgs>[]
      quickMessages: Prisma.$QuickMessagePayload<ExtArgs>[]
      ChatUsers: Prisma.$ChatUserPayload<ExtArgs>[]
      UserQueue: Prisma.$UserQueuePayload<ExtArgs>[]
      UserRating: Prisma.$UserRatingPayload<ExtArgs>[]
      TicketTracking: Prisma.$TicketTrackingPayload<ExtArgs>[]
      TicketNote: Prisma.$TicketNotePayload<ExtArgs>[]
      Schedule: Prisma.$SchedulePayload<ExtArgs>[]
      ChatMessage: Prisma.$ChatMessagePayload<ExtArgs>[]
      Chat: Prisma.$ChatPayload<ExtArgs>[]
      Action_Logs: Prisma.$Action_LogsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      passwordHash: string
      tokenVersion: number
      profile: string
      super: boolean
      online: boolean
      createdAt: Date
      updatedAt: Date
      companyId: number
      whatsappId: number | null
      avatarUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    whatsapp<T extends User$whatsappArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    queues<T extends User$queuesArgs<ExtArgs> = {}>(args?: Subset<T, User$queuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany"> | Null>
    quickMessages<T extends User$quickMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$quickMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuickMessagePayload<ExtArgs>, T, "findMany"> | Null>
    ChatUsers<T extends User$ChatUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$ChatUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatUserPayload<ExtArgs>, T, "findMany"> | Null>
    UserQueue<T extends User$UserQueueArgs<ExtArgs> = {}>(args?: Subset<T, User$UserQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findMany"> | Null>
    UserRating<T extends User$UserRatingArgs<ExtArgs> = {}>(args?: Subset<T, User$UserRatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findMany"> | Null>
    TicketTracking<T extends User$TicketTrackingArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    TicketNote<T extends User$TicketNoteArgs<ExtArgs> = {}>(args?: Subset<T, User$TicketNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany"> | Null>
    Schedule<T extends User$ScheduleArgs<ExtArgs> = {}>(args?: Subset<T, User$ScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    ChatMessage<T extends User$ChatMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$ChatMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany"> | Null>
    Chat<T extends User$ChatArgs<ExtArgs> = {}>(args?: Subset<T, User$ChatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    Action_Logs<T extends User$Action_LogsArgs<ExtArgs> = {}>(args?: Subset<T, User$Action_LogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Action_LogsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly tokenVersion: FieldRef<"User", 'Int'>
    readonly profile: FieldRef<"User", 'String'>
    readonly super: FieldRef<"User", 'Boolean'>
    readonly online: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly companyId: FieldRef<"User", 'Int'>
    readonly whatsappId: FieldRef<"User", 'Int'>
    readonly avatarUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.whatsapp
   */
  export type User$whatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    where?: WhatsappWhereInput
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.queues
   */
  export type User$queuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    cursor?: QueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * User.quickMessages
   */
  export type User$quickMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuickMessage
     */
    select?: QuickMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuickMessageInclude<ExtArgs> | null
    where?: QuickMessageWhereInput
    orderBy?: QuickMessageOrderByWithRelationInput | QuickMessageOrderByWithRelationInput[]
    cursor?: QuickMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuickMessageScalarFieldEnum | QuickMessageScalarFieldEnum[]
  }

  /**
   * User.ChatUsers
   */
  export type User$ChatUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatUser
     */
    select?: ChatUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatUserInclude<ExtArgs> | null
    where?: ChatUserWhereInput
    orderBy?: ChatUserOrderByWithRelationInput | ChatUserOrderByWithRelationInput[]
    cursor?: ChatUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatUserScalarFieldEnum | ChatUserScalarFieldEnum[]
  }

  /**
   * User.UserQueue
   */
  export type User$UserQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    where?: UserQueueWhereInput
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    cursor?: UserQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
  }

  /**
   * User.UserRating
   */
  export type User$UserRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    where?: UserRatingWhereInput
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    cursor?: UserRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
  }

  /**
   * User.TicketTracking
   */
  export type User$TicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    where?: TicketTrackingWhereInput
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    cursor?: TicketTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
  }

  /**
   * User.TicketNote
   */
  export type User$TicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    cursor?: TicketNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * User.Schedule
   */
  export type User$ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * User.ChatMessage
   */
  export type User$ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.Chat
   */
  export type User$ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.Action_Logs
   */
  export type User$Action_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action_Logs
     */
    select?: Action_LogsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Action_LogsInclude<ExtArgs> | null
    where?: Action_LogsWhereInput
    orderBy?: Action_LogsOrderByWithRelationInput | Action_LogsOrderByWithRelationInput[]
    cursor?: Action_LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Action_LogsScalarFieldEnum | Action_LogsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserQueue
   */

  export type AggregateUserQueue = {
    _count: UserQueueCountAggregateOutputType | null
    _avg: UserQueueAvgAggregateOutputType | null
    _sum: UserQueueSumAggregateOutputType | null
    _min: UserQueueMinAggregateOutputType | null
    _max: UserQueueMaxAggregateOutputType | null
  }

  export type UserQueueAvgAggregateOutputType = {
    userId: number | null
    queueId: number | null
  }

  export type UserQueueSumAggregateOutputType = {
    userId: number | null
    queueId: number | null
  }

  export type UserQueueMinAggregateOutputType = {
    userId: number | null
    queueId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQueueMaxAggregateOutputType = {
    userId: number | null
    queueId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQueueCountAggregateOutputType = {
    userId: number
    queueId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserQueueAvgAggregateInputType = {
    userId?: true
    queueId?: true
  }

  export type UserQueueSumAggregateInputType = {
    userId?: true
    queueId?: true
  }

  export type UserQueueMinAggregateInputType = {
    userId?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQueueMaxAggregateInputType = {
    userId?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQueueCountAggregateInputType = {
    userId?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQueue to aggregate.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQueues
    **/
    _count?: true | UserQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQueueMaxAggregateInputType
  }

  export type GetUserQueueAggregateType<T extends UserQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQueue[P]>
      : GetScalarType<T[P], AggregateUserQueue[P]>
  }




  export type UserQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQueueWhereInput
    orderBy?: UserQueueOrderByWithAggregationInput | UserQueueOrderByWithAggregationInput[]
    by: UserQueueScalarFieldEnum[] | UserQueueScalarFieldEnum
    having?: UserQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQueueCountAggregateInputType | true
    _avg?: UserQueueAvgAggregateInputType
    _sum?: UserQueueSumAggregateInputType
    _min?: UserQueueMinAggregateInputType
    _max?: UserQueueMaxAggregateInputType
  }

  export type UserQueueGroupByOutputType = {
    userId: number
    queueId: number
    createdAt: Date
    updatedAt: Date
    _count: UserQueueCountAggregateOutputType | null
    _avg: UserQueueAvgAggregateOutputType | null
    _sum: UserQueueSumAggregateOutputType | null
    _min: UserQueueMinAggregateOutputType | null
    _max: UserQueueMaxAggregateOutputType | null
  }

  type GetUserQueueGroupByPayload<T extends UserQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQueueGroupByOutputType[P]>
            : GetScalarType<T[P], UserQueueGroupByOutputType[P]>
        }
      >
    >


  export type UserQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQueue"]>


  export type UserQueueSelectScalar = {
    userId?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }

  export type $UserQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQueue"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      queue: Prisma.$QueuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      queueId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userQueue"]>
    composites: {}
  }

  type UserQueueGetPayload<S extends boolean | null | undefined | UserQueueDefaultArgs> = $Result.GetResult<Prisma.$UserQueuePayload, S>

  type UserQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: UserQueueCountAggregateInputType | true
    }

  export interface UserQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQueue'], meta: { name: 'UserQueue' } }
    /**
     * Find zero or one UserQueue that matches the filter.
     * @param {UserQueueFindUniqueArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQueueFindUniqueArgs>(args: SelectSubset<T, UserQueueFindUniqueArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserQueueFindUniqueOrThrowArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueFindFirstArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQueueFindFirstArgs>(args?: SelectSubset<T, UserQueueFindFirstArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueFindFirstOrThrowArgs} args - Arguments to find a UserQueue
     * @example
     * // Get one UserQueue
     * const userQueue = await prisma.userQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQueues
     * const userQueues = await prisma.userQueue.findMany()
     * 
     * // Get first 10 UserQueues
     * const userQueues = await prisma.userQueue.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userQueueWithUserIdOnly = await prisma.userQueue.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserQueueFindManyArgs>(args?: SelectSubset<T, UserQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserQueue.
     * @param {UserQueueCreateArgs} args - Arguments to create a UserQueue.
     * @example
     * // Create one UserQueue
     * const UserQueue = await prisma.userQueue.create({
     *   data: {
     *     // ... data to create a UserQueue
     *   }
     * })
     * 
     */
    create<T extends UserQueueCreateArgs>(args: SelectSubset<T, UserQueueCreateArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserQueues.
     * @param {UserQueueCreateManyArgs} args - Arguments to create many UserQueues.
     * @example
     * // Create many UserQueues
     * const userQueue = await prisma.userQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQueueCreateManyArgs>(args?: SelectSubset<T, UserQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserQueue.
     * @param {UserQueueDeleteArgs} args - Arguments to delete one UserQueue.
     * @example
     * // Delete one UserQueue
     * const UserQueue = await prisma.userQueue.delete({
     *   where: {
     *     // ... filter to delete one UserQueue
     *   }
     * })
     * 
     */
    delete<T extends UserQueueDeleteArgs>(args: SelectSubset<T, UserQueueDeleteArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserQueue.
     * @param {UserQueueUpdateArgs} args - Arguments to update one UserQueue.
     * @example
     * // Update one UserQueue
     * const userQueue = await prisma.userQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQueueUpdateArgs>(args: SelectSubset<T, UserQueueUpdateArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserQueues.
     * @param {UserQueueDeleteManyArgs} args - Arguments to filter UserQueues to delete.
     * @example
     * // Delete a few UserQueues
     * const { count } = await prisma.userQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQueueDeleteManyArgs>(args?: SelectSubset<T, UserQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQueues
     * const userQueue = await prisma.userQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQueueUpdateManyArgs>(args: SelectSubset<T, UserQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserQueue.
     * @param {UserQueueUpsertArgs} args - Arguments to update or create a UserQueue.
     * @example
     * // Update or create a UserQueue
     * const userQueue = await prisma.userQueue.upsert({
     *   create: {
     *     // ... data to create a UserQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQueue we want to update
     *   }
     * })
     */
    upsert<T extends UserQueueUpsertArgs>(args: SelectSubset<T, UserQueueUpsertArgs<ExtArgs>>): Prisma__UserQueueClient<$Result.GetResult<Prisma.$UserQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueCountArgs} args - Arguments to filter UserQueues to count.
     * @example
     * // Count the number of UserQueues
     * const count = await prisma.userQueue.count({
     *   where: {
     *     // ... the filter for the UserQueues we want to count
     *   }
     * })
    **/
    count<T extends UserQueueCountArgs>(
      args?: Subset<T, UserQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQueueAggregateArgs>(args: Subset<T, UserQueueAggregateArgs>): Prisma.PrismaPromise<GetUserQueueAggregateType<T>>

    /**
     * Group by UserQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQueueGroupByArgs['orderBy'] }
        : { orderBy?: UserQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQueue model
   */
  readonly fields: UserQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    queue<T extends QueueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueDefaultArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQueue model
   */ 
  interface UserQueueFieldRefs {
    readonly userId: FieldRef<"UserQueue", 'Int'>
    readonly queueId: FieldRef<"UserQueue", 'Int'>
    readonly createdAt: FieldRef<"UserQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"UserQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserQueue findUnique
   */
  export type UserQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where: UserQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue findUniqueOrThrow
   */
  export type UserQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where: UserQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue findFirst
   */
  export type UserQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQueues.
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQueues.
     */
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue findFirstOrThrow
   */
  export type UserQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * Filter, which UserQueue to fetch.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQueues.
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQueues.
     */
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue findMany
   */
  export type UserQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * Filter, which UserQueues to fetch.
     */
    where?: UserQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQueues to fetch.
     */
    orderBy?: UserQueueOrderByWithRelationInput | UserQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQueues.
     */
    cursor?: UserQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQueues.
     */
    skip?: number
    distinct?: UserQueueScalarFieldEnum | UserQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue create
   */
  export type UserQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQueue.
     */
    data: XOR<UserQueueCreateInput, UserQueueUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue createMany
   */
  export type UserQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQueues.
     */
    data: UserQueueCreateManyInput | UserQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQueue update
   */
  export type UserQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQueue.
     */
    data: XOR<UserQueueUpdateInput, UserQueueUncheckedUpdateInput>
    /**
     * Choose, which UserQueue to update.
     */
    where: UserQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue updateMany
   */
  export type UserQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQueues.
     */
    data: XOR<UserQueueUpdateManyMutationInput, UserQueueUncheckedUpdateManyInput>
    /**
     * Filter which UserQueues to update
     */
    where?: UserQueueWhereInput
  }

  /**
   * UserQueue upsert
   */
  export type UserQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQueue to update in case it exists.
     */
    where: UserQueueWhereUniqueInput
    /**
     * In case the UserQueue found by the `where` argument doesn't exist, create a new UserQueue with this data.
     */
    create: XOR<UserQueueCreateInput, UserQueueUncheckedCreateInput>
    /**
     * In case the UserQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQueueUpdateInput, UserQueueUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue delete
   */
  export type UserQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
    /**
     * Filter which UserQueue to delete.
     */
    where: UserQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserQueue deleteMany
   */
  export type UserQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQueues to delete
     */
    where?: UserQueueWhereInput
  }

  /**
   * UserQueue without action
   */
  export type UserQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQueue
     */
    select?: UserQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQueueInclude<ExtArgs> | null
  }


  /**
   * Model UserRating
   */

  export type AggregateUserRating = {
    _count: UserRatingCountAggregateOutputType | null
    _avg: UserRatingAvgAggregateOutputType | null
    _sum: UserRatingSumAggregateOutputType | null
    _min: UserRatingMinAggregateOutputType | null
    _max: UserRatingMaxAggregateOutputType | null
  }

  export type UserRatingAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    userId: number | null
    rate: number | null
  }

  export type UserRatingSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    userId: number | null
    rate: number | null
  }

  export type UserRatingMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    userId: number | null
    rate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRatingMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    companyId: number | null
    userId: number | null
    rate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRatingCountAggregateOutputType = {
    id: number
    ticketId: number
    companyId: number
    userId: number
    rate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserRatingAvgAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    userId?: true
    rate?: true
  }

  export type UserRatingSumAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    userId?: true
    rate?: true
  }

  export type UserRatingMinAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    userId?: true
    rate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRatingMaxAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    userId?: true
    rate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRatingCountAggregateInputType = {
    id?: true
    ticketId?: true
    companyId?: true
    userId?: true
    rate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRating to aggregate.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRatings
    **/
    _count?: true | UserRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRatingMaxAggregateInputType
  }

  export type GetUserRatingAggregateType<T extends UserRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRating[P]>
      : GetScalarType<T[P], AggregateUserRating[P]>
  }




  export type UserRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRatingWhereInput
    orderBy?: UserRatingOrderByWithAggregationInput | UserRatingOrderByWithAggregationInput[]
    by: UserRatingScalarFieldEnum[] | UserRatingScalarFieldEnum
    having?: UserRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRatingCountAggregateInputType | true
    _avg?: UserRatingAvgAggregateInputType
    _sum?: UserRatingSumAggregateInputType
    _min?: UserRatingMinAggregateInputType
    _max?: UserRatingMaxAggregateInputType
  }

  export type UserRatingGroupByOutputType = {
    id: number
    ticketId: number
    companyId: number
    userId: number
    rate: number
    createdAt: Date
    updatedAt: Date
    _count: UserRatingCountAggregateOutputType | null
    _avg: UserRatingAvgAggregateOutputType | null
    _sum: UserRatingSumAggregateOutputType | null
    _min: UserRatingMinAggregateOutputType | null
    _max: UserRatingMaxAggregateOutputType | null
  }

  type GetUserRatingGroupByPayload<T extends UserRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRatingGroupByOutputType[P]>
            : GetScalarType<T[P], UserRatingGroupByOutputType[P]>
        }
      >
    >


  export type UserRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    companyId?: boolean
    userId?: boolean
    rate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRating"]>


  export type UserRatingSelectScalar = {
    id?: boolean
    ticketId?: boolean
    companyId?: boolean
    userId?: boolean
    rate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRating"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      companyId: number
      userId: number
      rate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userRating"]>
    composites: {}
  }

  type UserRatingGetPayload<S extends boolean | null | undefined | UserRatingDefaultArgs> = $Result.GetResult<Prisma.$UserRatingPayload, S>

  type UserRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: UserRatingCountAggregateInputType | true
    }

  export interface UserRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRating'], meta: { name: 'UserRating' } }
    /**
     * Find zero or one UserRating that matches the filter.
     * @param {UserRatingFindUniqueArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRatingFindUniqueArgs>(args: SelectSubset<T, UserRatingFindUniqueArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRatingFindUniqueOrThrowArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindFirstArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRatingFindFirstArgs>(args?: SelectSubset<T, UserRatingFindFirstArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindFirstOrThrowArgs} args - Arguments to find a UserRating
     * @example
     * // Get one UserRating
     * const userRating = await prisma.userRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRatings
     * const userRatings = await prisma.userRating.findMany()
     * 
     * // Get first 10 UserRatings
     * const userRatings = await prisma.userRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRatingWithIdOnly = await prisma.userRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRatingFindManyArgs>(args?: SelectSubset<T, UserRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRating.
     * @param {UserRatingCreateArgs} args - Arguments to create a UserRating.
     * @example
     * // Create one UserRating
     * const UserRating = await prisma.userRating.create({
     *   data: {
     *     // ... data to create a UserRating
     *   }
     * })
     * 
     */
    create<T extends UserRatingCreateArgs>(args: SelectSubset<T, UserRatingCreateArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRatings.
     * @param {UserRatingCreateManyArgs} args - Arguments to create many UserRatings.
     * @example
     * // Create many UserRatings
     * const userRating = await prisma.userRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRatingCreateManyArgs>(args?: SelectSubset<T, UserRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRating.
     * @param {UserRatingDeleteArgs} args - Arguments to delete one UserRating.
     * @example
     * // Delete one UserRating
     * const UserRating = await prisma.userRating.delete({
     *   where: {
     *     // ... filter to delete one UserRating
     *   }
     * })
     * 
     */
    delete<T extends UserRatingDeleteArgs>(args: SelectSubset<T, UserRatingDeleteArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRating.
     * @param {UserRatingUpdateArgs} args - Arguments to update one UserRating.
     * @example
     * // Update one UserRating
     * const userRating = await prisma.userRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRatingUpdateArgs>(args: SelectSubset<T, UserRatingUpdateArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRatings.
     * @param {UserRatingDeleteManyArgs} args - Arguments to filter UserRatings to delete.
     * @example
     * // Delete a few UserRatings
     * const { count } = await prisma.userRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRatingDeleteManyArgs>(args?: SelectSubset<T, UserRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRatings
     * const userRating = await prisma.userRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRatingUpdateManyArgs>(args: SelectSubset<T, UserRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRating.
     * @param {UserRatingUpsertArgs} args - Arguments to update or create a UserRating.
     * @example
     * // Update or create a UserRating
     * const userRating = await prisma.userRating.upsert({
     *   create: {
     *     // ... data to create a UserRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRating we want to update
     *   }
     * })
     */
    upsert<T extends UserRatingUpsertArgs>(args: SelectSubset<T, UserRatingUpsertArgs<ExtArgs>>): Prisma__UserRatingClient<$Result.GetResult<Prisma.$UserRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingCountArgs} args - Arguments to filter UserRatings to count.
     * @example
     * // Count the number of UserRatings
     * const count = await prisma.userRating.count({
     *   where: {
     *     // ... the filter for the UserRatings we want to count
     *   }
     * })
    **/
    count<T extends UserRatingCountArgs>(
      args?: Subset<T, UserRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRatingAggregateArgs>(args: Subset<T, UserRatingAggregateArgs>): Prisma.PrismaPromise<GetUserRatingAggregateType<T>>

    /**
     * Group by UserRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRatingGroupByArgs['orderBy'] }
        : { orderBy?: UserRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRating model
   */
  readonly fields: UserRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRating model
   */ 
  interface UserRatingFieldRefs {
    readonly id: FieldRef<"UserRating", 'Int'>
    readonly ticketId: FieldRef<"UserRating", 'Int'>
    readonly companyId: FieldRef<"UserRating", 'Int'>
    readonly userId: FieldRef<"UserRating", 'Int'>
    readonly rate: FieldRef<"UserRating", 'Int'>
    readonly createdAt: FieldRef<"UserRating", 'DateTime'>
    readonly updatedAt: FieldRef<"UserRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRating findUnique
   */
  export type UserRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where: UserRatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating findUniqueOrThrow
   */
  export type UserRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where: UserRatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating findFirst
   */
  export type UserRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRatings.
     */
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating findFirstOrThrow
   */
  export type UserRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRating to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRatings.
     */
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating findMany
   */
  export type UserRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter, which UserRatings to fetch.
     */
    where?: UserRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRatings to fetch.
     */
    orderBy?: UserRatingOrderByWithRelationInput | UserRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRatings.
     */
    cursor?: UserRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRatings.
     */
    skip?: number
    distinct?: UserRatingScalarFieldEnum | UserRatingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating create
   */
  export type UserRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRating.
     */
    data: XOR<UserRatingCreateInput, UserRatingUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating createMany
   */
  export type UserRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRatings.
     */
    data: UserRatingCreateManyInput | UserRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRating update
   */
  export type UserRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRating.
     */
    data: XOR<UserRatingUpdateInput, UserRatingUncheckedUpdateInput>
    /**
     * Choose, which UserRating to update.
     */
    where: UserRatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating updateMany
   */
  export type UserRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRatings.
     */
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyInput>
    /**
     * Filter which UserRatings to update
     */
    where?: UserRatingWhereInput
  }

  /**
   * UserRating upsert
   */
  export type UserRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRating to update in case it exists.
     */
    where: UserRatingWhereUniqueInput
    /**
     * In case the UserRating found by the `where` argument doesn't exist, create a new UserRating with this data.
     */
    create: XOR<UserRatingCreateInput, UserRatingUncheckedCreateInput>
    /**
     * In case the UserRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRatingUpdateInput, UserRatingUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating delete
   */
  export type UserRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
    /**
     * Filter which UserRating to delete.
     */
    where: UserRatingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRating deleteMany
   */
  export type UserRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRatings to delete
     */
    where?: UserRatingWhereInput
  }

  /**
   * UserRating without action
   */
  export type UserRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRating
     */
    select?: UserRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRatingInclude<ExtArgs> | null
  }


  /**
   * Model Whatsapp
   */

  export type AggregateWhatsapp = {
    _count: WhatsappCountAggregateOutputType | null
    _avg: WhatsappAvgAggregateOutputType | null
    _sum: WhatsappSumAggregateOutputType | null
    _min: WhatsappMinAggregateOutputType | null
    _max: WhatsappMaxAggregateOutputType | null
  }

  export type WhatsappAvgAggregateOutputType = {
    id: number | null
    retries: number | null
    transferQueueId: number | null
    timeToTransfer: number | null
    maxUseBotQueues: number | null
    sendIdQueue: number | null
    timeSendQueue: number | null
    integrationId: number | null
    expiresTicket: number | null
    companyId: number | null
    promptId: number | null
  }

  export type WhatsappSumAggregateOutputType = {
    id: number | null
    retries: number | null
    transferQueueId: number | null
    timeToTransfer: number | null
    maxUseBotQueues: number | null
    sendIdQueue: number | null
    timeSendQueue: number | null
    integrationId: number | null
    expiresTicket: number | null
    companyId: number | null
    promptId: number | null
  }

  export type WhatsappMinAggregateOutputType = {
    id: number | null
    name: string | null
    session: string | null
    qrcode: string | null
    status: string | null
    battery: string | null
    plugged: boolean | null
    retries: number | null
    greetingMessage: string | null
    farewellMessage: string | null
    complationMessage: string | null
    outOfHoursMessage: string | null
    ratingMessage: string | null
    provider: string | null
    isDefault: boolean | null
    token: string | null
    transferQueueId: number | null
    timeToTransfer: number | null
    maxUseBotQueues: number | null
    timeUseBotQueues: string | null
    sendIdQueue: number | null
    timeSendQueue: number | null
    integrationId: number | null
    expiresTicket: number | null
    expiresInactiveMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    promptId: number | null
  }

  export type WhatsappMaxAggregateOutputType = {
    id: number | null
    name: string | null
    session: string | null
    qrcode: string | null
    status: string | null
    battery: string | null
    plugged: boolean | null
    retries: number | null
    greetingMessage: string | null
    farewellMessage: string | null
    complationMessage: string | null
    outOfHoursMessage: string | null
    ratingMessage: string | null
    provider: string | null
    isDefault: boolean | null
    token: string | null
    transferQueueId: number | null
    timeToTransfer: number | null
    maxUseBotQueues: number | null
    timeUseBotQueues: string | null
    sendIdQueue: number | null
    timeSendQueue: number | null
    integrationId: number | null
    expiresTicket: number | null
    expiresInactiveMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: number | null
    promptId: number | null
  }

  export type WhatsappCountAggregateOutputType = {
    id: number
    name: number
    session: number
    qrcode: number
    status: number
    battery: number
    plugged: number
    retries: number
    greetingMessage: number
    farewellMessage: number
    complationMessage: number
    outOfHoursMessage: number
    ratingMessage: number
    provider: number
    isDefault: number
    token: number
    transferQueueId: number
    timeToTransfer: number
    maxUseBotQueues: number
    timeUseBotQueues: number
    sendIdQueue: number
    timeSendQueue: number
    integrationId: number
    expiresTicket: number
    expiresInactiveMessage: number
    createdAt: number
    updatedAt: number
    companyId: number
    promptId: number
    _all: number
  }


  export type WhatsappAvgAggregateInputType = {
    id?: true
    retries?: true
    transferQueueId?: true
    timeToTransfer?: true
    maxUseBotQueues?: true
    sendIdQueue?: true
    timeSendQueue?: true
    integrationId?: true
    expiresTicket?: true
    companyId?: true
    promptId?: true
  }

  export type WhatsappSumAggregateInputType = {
    id?: true
    retries?: true
    transferQueueId?: true
    timeToTransfer?: true
    maxUseBotQueues?: true
    sendIdQueue?: true
    timeSendQueue?: true
    integrationId?: true
    expiresTicket?: true
    companyId?: true
    promptId?: true
  }

  export type WhatsappMinAggregateInputType = {
    id?: true
    name?: true
    session?: true
    qrcode?: true
    status?: true
    battery?: true
    plugged?: true
    retries?: true
    greetingMessage?: true
    farewellMessage?: true
    complationMessage?: true
    outOfHoursMessage?: true
    ratingMessage?: true
    provider?: true
    isDefault?: true
    token?: true
    transferQueueId?: true
    timeToTransfer?: true
    maxUseBotQueues?: true
    timeUseBotQueues?: true
    sendIdQueue?: true
    timeSendQueue?: true
    integrationId?: true
    expiresTicket?: true
    expiresInactiveMessage?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    promptId?: true
  }

  export type WhatsappMaxAggregateInputType = {
    id?: true
    name?: true
    session?: true
    qrcode?: true
    status?: true
    battery?: true
    plugged?: true
    retries?: true
    greetingMessage?: true
    farewellMessage?: true
    complationMessage?: true
    outOfHoursMessage?: true
    ratingMessage?: true
    provider?: true
    isDefault?: true
    token?: true
    transferQueueId?: true
    timeToTransfer?: true
    maxUseBotQueues?: true
    timeUseBotQueues?: true
    sendIdQueue?: true
    timeSendQueue?: true
    integrationId?: true
    expiresTicket?: true
    expiresInactiveMessage?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    promptId?: true
  }

  export type WhatsappCountAggregateInputType = {
    id?: true
    name?: true
    session?: true
    qrcode?: true
    status?: true
    battery?: true
    plugged?: true
    retries?: true
    greetingMessage?: true
    farewellMessage?: true
    complationMessage?: true
    outOfHoursMessage?: true
    ratingMessage?: true
    provider?: true
    isDefault?: true
    token?: true
    transferQueueId?: true
    timeToTransfer?: true
    maxUseBotQueues?: true
    timeUseBotQueues?: true
    sendIdQueue?: true
    timeSendQueue?: true
    integrationId?: true
    expiresTicket?: true
    expiresInactiveMessage?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    promptId?: true
    _all?: true
  }

  export type WhatsappAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whatsapp to aggregate.
     */
    where?: WhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whatsapps to fetch.
     */
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whatsapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Whatsapps
    **/
    _count?: true | WhatsappCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsappAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsappSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappMaxAggregateInputType
  }

  export type GetWhatsappAggregateType<T extends WhatsappAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsapp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsapp[P]>
      : GetScalarType<T[P], AggregateWhatsapp[P]>
  }




  export type WhatsappGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappWhereInput
    orderBy?: WhatsappOrderByWithAggregationInput | WhatsappOrderByWithAggregationInput[]
    by: WhatsappScalarFieldEnum[] | WhatsappScalarFieldEnum
    having?: WhatsappScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappCountAggregateInputType | true
    _avg?: WhatsappAvgAggregateInputType
    _sum?: WhatsappSumAggregateInputType
    _min?: WhatsappMinAggregateInputType
    _max?: WhatsappMaxAggregateInputType
  }

  export type WhatsappGroupByOutputType = {
    id: number
    name: string | null
    session: string | null
    qrcode: string | null
    status: string | null
    battery: string | null
    plugged: boolean | null
    retries: number | null
    greetingMessage: string
    farewellMessage: string
    complationMessage: string
    outOfHoursMessage: string
    ratingMessage: string
    provider: string
    isDefault: boolean | null
    token: string | null
    transferQueueId: number | null
    timeToTransfer: number | null
    maxUseBotQueues: number | null
    timeUseBotQueues: string | null
    sendIdQueue: number | null
    timeSendQueue: number | null
    integrationId: number | null
    expiresTicket: number | null
    expiresInactiveMessage: string | null
    createdAt: Date
    updatedAt: Date
    companyId: number
    promptId: number | null
    _count: WhatsappCountAggregateOutputType | null
    _avg: WhatsappAvgAggregateOutputType | null
    _sum: WhatsappSumAggregateOutputType | null
    _min: WhatsappMinAggregateOutputType | null
    _max: WhatsappMaxAggregateOutputType | null
  }

  type GetWhatsappGroupByPayload<T extends WhatsappGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    session?: boolean
    qrcode?: boolean
    status?: boolean
    battery?: boolean
    plugged?: boolean
    retries?: boolean
    greetingMessage?: boolean
    farewellMessage?: boolean
    complationMessage?: boolean
    outOfHoursMessage?: boolean
    ratingMessage?: boolean
    provider?: boolean
    isDefault?: boolean
    token?: boolean
    transferQueueId?: boolean
    timeToTransfer?: boolean
    maxUseBotQueues?: boolean
    timeUseBotQueues?: boolean
    sendIdQueue?: boolean
    timeSendQueue?: boolean
    integrationId?: boolean
    expiresTicket?: boolean
    expiresInactiveMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    promptId?: boolean
    tickets?: boolean | Whatsapp$ticketsArgs<ExtArgs>
    queues?: boolean | Whatsapp$queuesArgs<ExtArgs>
    whatsappQueues?: boolean | Whatsapp$whatsappQueuesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    prompt?: boolean | Whatsapp$promptArgs<ExtArgs>
    User?: boolean | Whatsapp$UserArgs<ExtArgs>
    TicketTracking?: boolean | Whatsapp$TicketTrackingArgs<ExtArgs>
    Contact?: boolean | Whatsapp$ContactArgs<ExtArgs>
    Campaign?: boolean | Whatsapp$CampaignArgs<ExtArgs>
    BaileysChats?: boolean | Whatsapp$BaileysChatsArgs<ExtArgs>
    Baileys?: boolean | Whatsapp$BaileysArgs<ExtArgs>
    _count?: boolean | WhatsappCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsapp"]>


  export type WhatsappSelectScalar = {
    id?: boolean
    name?: boolean
    session?: boolean
    qrcode?: boolean
    status?: boolean
    battery?: boolean
    plugged?: boolean
    retries?: boolean
    greetingMessage?: boolean
    farewellMessage?: boolean
    complationMessage?: boolean
    outOfHoursMessage?: boolean
    ratingMessage?: boolean
    provider?: boolean
    isDefault?: boolean
    token?: boolean
    transferQueueId?: boolean
    timeToTransfer?: boolean
    maxUseBotQueues?: boolean
    timeUseBotQueues?: boolean
    sendIdQueue?: boolean
    timeSendQueue?: boolean
    integrationId?: boolean
    expiresTicket?: boolean
    expiresInactiveMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    promptId?: boolean
  }

  export type WhatsappInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | Whatsapp$ticketsArgs<ExtArgs>
    queues?: boolean | Whatsapp$queuesArgs<ExtArgs>
    whatsappQueues?: boolean | Whatsapp$whatsappQueuesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    prompt?: boolean | Whatsapp$promptArgs<ExtArgs>
    User?: boolean | Whatsapp$UserArgs<ExtArgs>
    TicketTracking?: boolean | Whatsapp$TicketTrackingArgs<ExtArgs>
    Contact?: boolean | Whatsapp$ContactArgs<ExtArgs>
    Campaign?: boolean | Whatsapp$CampaignArgs<ExtArgs>
    BaileysChats?: boolean | Whatsapp$BaileysChatsArgs<ExtArgs>
    Baileys?: boolean | Whatsapp$BaileysArgs<ExtArgs>
    _count?: boolean | WhatsappCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WhatsappPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Whatsapp"
    objects: {
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      queues: Prisma.$QueuePayload<ExtArgs>[]
      whatsappQueues: Prisma.$WhatsappQueuePayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      prompt: Prisma.$PromptPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>[]
      TicketTracking: Prisma.$TicketTrackingPayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Campaign: Prisma.$CampaignPayload<ExtArgs>[]
      BaileysChats: Prisma.$BaileysChatsPayload<ExtArgs>[]
      Baileys: Prisma.$BaileysPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      session: string | null
      qrcode: string | null
      status: string | null
      battery: string | null
      plugged: boolean | null
      retries: number | null
      greetingMessage: string
      farewellMessage: string
      complationMessage: string
      outOfHoursMessage: string
      ratingMessage: string
      provider: string
      isDefault: boolean | null
      token: string | null
      transferQueueId: number | null
      timeToTransfer: number | null
      maxUseBotQueues: number | null
      timeUseBotQueues: string | null
      sendIdQueue: number | null
      timeSendQueue: number | null
      integrationId: number | null
      expiresTicket: number | null
      expiresInactiveMessage: string | null
      createdAt: Date
      updatedAt: Date
      companyId: number
      promptId: number | null
    }, ExtArgs["result"]["whatsapp"]>
    composites: {}
  }

  type WhatsappGetPayload<S extends boolean | null | undefined | WhatsappDefaultArgs> = $Result.GetResult<Prisma.$WhatsappPayload, S>

  type WhatsappCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhatsappFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: WhatsappCountAggregateInputType | true
    }

  export interface WhatsappDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Whatsapp'], meta: { name: 'Whatsapp' } }
    /**
     * Find zero or one Whatsapp that matches the filter.
     * @param {WhatsappFindUniqueArgs} args - Arguments to find a Whatsapp
     * @example
     * // Get one Whatsapp
     * const whatsapp = await prisma.whatsapp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappFindUniqueArgs>(args: SelectSubset<T, WhatsappFindUniqueArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Whatsapp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhatsappFindUniqueOrThrowArgs} args - Arguments to find a Whatsapp
     * @example
     * // Get one Whatsapp
     * const whatsapp = await prisma.whatsapp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Whatsapp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappFindFirstArgs} args - Arguments to find a Whatsapp
     * @example
     * // Get one Whatsapp
     * const whatsapp = await prisma.whatsapp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappFindFirstArgs>(args?: SelectSubset<T, WhatsappFindFirstArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Whatsapp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappFindFirstOrThrowArgs} args - Arguments to find a Whatsapp
     * @example
     * // Get one Whatsapp
     * const whatsapp = await prisma.whatsapp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Whatsapps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsapps
     * const whatsapps = await prisma.whatsapp.findMany()
     * 
     * // Get first 10 Whatsapps
     * const whatsapps = await prisma.whatsapp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsappWithIdOnly = await prisma.whatsapp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsappFindManyArgs>(args?: SelectSubset<T, WhatsappFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Whatsapp.
     * @param {WhatsappCreateArgs} args - Arguments to create a Whatsapp.
     * @example
     * // Create one Whatsapp
     * const Whatsapp = await prisma.whatsapp.create({
     *   data: {
     *     // ... data to create a Whatsapp
     *   }
     * })
     * 
     */
    create<T extends WhatsappCreateArgs>(args: SelectSubset<T, WhatsappCreateArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Whatsapps.
     * @param {WhatsappCreateManyArgs} args - Arguments to create many Whatsapps.
     * @example
     * // Create many Whatsapps
     * const whatsapp = await prisma.whatsapp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappCreateManyArgs>(args?: SelectSubset<T, WhatsappCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Whatsapp.
     * @param {WhatsappDeleteArgs} args - Arguments to delete one Whatsapp.
     * @example
     * // Delete one Whatsapp
     * const Whatsapp = await prisma.whatsapp.delete({
     *   where: {
     *     // ... filter to delete one Whatsapp
     *   }
     * })
     * 
     */
    delete<T extends WhatsappDeleteArgs>(args: SelectSubset<T, WhatsappDeleteArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Whatsapp.
     * @param {WhatsappUpdateArgs} args - Arguments to update one Whatsapp.
     * @example
     * // Update one Whatsapp
     * const whatsapp = await prisma.whatsapp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappUpdateArgs>(args: SelectSubset<T, WhatsappUpdateArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Whatsapps.
     * @param {WhatsappDeleteManyArgs} args - Arguments to filter Whatsapps to delete.
     * @example
     * // Delete a few Whatsapps
     * const { count } = await prisma.whatsapp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappDeleteManyArgs>(args?: SelectSubset<T, WhatsappDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsapps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsapps
     * const whatsapp = await prisma.whatsapp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappUpdateManyArgs>(args: SelectSubset<T, WhatsappUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Whatsapp.
     * @param {WhatsappUpsertArgs} args - Arguments to update or create a Whatsapp.
     * @example
     * // Update or create a Whatsapp
     * const whatsapp = await prisma.whatsapp.upsert({
     *   create: {
     *     // ... data to create a Whatsapp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsapp we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappUpsertArgs>(args: SelectSubset<T, WhatsappUpsertArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Whatsapps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappCountArgs} args - Arguments to filter Whatsapps to count.
     * @example
     * // Count the number of Whatsapps
     * const count = await prisma.whatsapp.count({
     *   where: {
     *     // ... the filter for the Whatsapps we want to count
     *   }
     * })
    **/
    count<T extends WhatsappCountArgs>(
      args?: Subset<T, WhatsappCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsapp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappAggregateArgs>(args: Subset<T, WhatsappAggregateArgs>): Prisma.PrismaPromise<GetWhatsappAggregateType<T>>

    /**
     * Group by Whatsapp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Whatsapp model
   */
  readonly fields: WhatsappFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Whatsapp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends Whatsapp$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    queues<T extends Whatsapp$queuesArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$queuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany"> | Null>
    whatsappQueues<T extends Whatsapp$whatsappQueuesArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$whatsappQueuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prompt<T extends Whatsapp$promptArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$promptArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User<T extends Whatsapp$UserArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    TicketTracking<T extends Whatsapp$TicketTrackingArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$TicketTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    Contact<T extends Whatsapp$ContactArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany"> | Null>
    Campaign<T extends Whatsapp$CampaignArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$CampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    BaileysChats<T extends Whatsapp$BaileysChatsArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$BaileysChatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaileysChatsPayload<ExtArgs>, T, "findMany"> | Null>
    Baileys<T extends Whatsapp$BaileysArgs<ExtArgs> = {}>(args?: Subset<T, Whatsapp$BaileysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BaileysPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Whatsapp model
   */ 
  interface WhatsappFieldRefs {
    readonly id: FieldRef<"Whatsapp", 'Int'>
    readonly name: FieldRef<"Whatsapp", 'String'>
    readonly session: FieldRef<"Whatsapp", 'String'>
    readonly qrcode: FieldRef<"Whatsapp", 'String'>
    readonly status: FieldRef<"Whatsapp", 'String'>
    readonly battery: FieldRef<"Whatsapp", 'String'>
    readonly plugged: FieldRef<"Whatsapp", 'Boolean'>
    readonly retries: FieldRef<"Whatsapp", 'Int'>
    readonly greetingMessage: FieldRef<"Whatsapp", 'String'>
    readonly farewellMessage: FieldRef<"Whatsapp", 'String'>
    readonly complationMessage: FieldRef<"Whatsapp", 'String'>
    readonly outOfHoursMessage: FieldRef<"Whatsapp", 'String'>
    readonly ratingMessage: FieldRef<"Whatsapp", 'String'>
    readonly provider: FieldRef<"Whatsapp", 'String'>
    readonly isDefault: FieldRef<"Whatsapp", 'Boolean'>
    readonly token: FieldRef<"Whatsapp", 'String'>
    readonly transferQueueId: FieldRef<"Whatsapp", 'Int'>
    readonly timeToTransfer: FieldRef<"Whatsapp", 'Int'>
    readonly maxUseBotQueues: FieldRef<"Whatsapp", 'Int'>
    readonly timeUseBotQueues: FieldRef<"Whatsapp", 'String'>
    readonly sendIdQueue: FieldRef<"Whatsapp", 'Int'>
    readonly timeSendQueue: FieldRef<"Whatsapp", 'Int'>
    readonly integrationId: FieldRef<"Whatsapp", 'Int'>
    readonly expiresTicket: FieldRef<"Whatsapp", 'Int'>
    readonly expiresInactiveMessage: FieldRef<"Whatsapp", 'String'>
    readonly createdAt: FieldRef<"Whatsapp", 'DateTime'>
    readonly updatedAt: FieldRef<"Whatsapp", 'DateTime'>
    readonly companyId: FieldRef<"Whatsapp", 'Int'>
    readonly promptId: FieldRef<"Whatsapp", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Whatsapp findUnique
   */
  export type WhatsappFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * Filter, which Whatsapp to fetch.
     */
    where: WhatsappWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp findUniqueOrThrow
   */
  export type WhatsappFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * Filter, which Whatsapp to fetch.
     */
    where: WhatsappWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp findFirst
   */
  export type WhatsappFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * Filter, which Whatsapp to fetch.
     */
    where?: WhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whatsapps to fetch.
     */
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whatsapps.
     */
    cursor?: WhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whatsapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whatsapps.
     */
    distinct?: WhatsappScalarFieldEnum | WhatsappScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp findFirstOrThrow
   */
  export type WhatsappFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * Filter, which Whatsapp to fetch.
     */
    where?: WhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whatsapps to fetch.
     */
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whatsapps.
     */
    cursor?: WhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whatsapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whatsapps.
     */
    distinct?: WhatsappScalarFieldEnum | WhatsappScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp findMany
   */
  export type WhatsappFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * Filter, which Whatsapps to fetch.
     */
    where?: WhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whatsapps to fetch.
     */
    orderBy?: WhatsappOrderByWithRelationInput | WhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Whatsapps.
     */
    cursor?: WhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whatsapps.
     */
    skip?: number
    distinct?: WhatsappScalarFieldEnum | WhatsappScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp create
   */
  export type WhatsappCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * The data needed to create a Whatsapp.
     */
    data: XOR<WhatsappCreateInput, WhatsappUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp createMany
   */
  export type WhatsappCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Whatsapps.
     */
    data: WhatsappCreateManyInput | WhatsappCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Whatsapp update
   */
  export type WhatsappUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * The data needed to update a Whatsapp.
     */
    data: XOR<WhatsappUpdateInput, WhatsappUncheckedUpdateInput>
    /**
     * Choose, which Whatsapp to update.
     */
    where: WhatsappWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp updateMany
   */
  export type WhatsappUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Whatsapps.
     */
    data: XOR<WhatsappUpdateManyMutationInput, WhatsappUncheckedUpdateManyInput>
    /**
     * Filter which Whatsapps to update
     */
    where?: WhatsappWhereInput
  }

  /**
   * Whatsapp upsert
   */
  export type WhatsappUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * The filter to search for the Whatsapp to update in case it exists.
     */
    where: WhatsappWhereUniqueInput
    /**
     * In case the Whatsapp found by the `where` argument doesn't exist, create a new Whatsapp with this data.
     */
    create: XOR<WhatsappCreateInput, WhatsappUncheckedCreateInput>
    /**
     * In case the Whatsapp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappUpdateInput, WhatsappUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp delete
   */
  export type WhatsappDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
    /**
     * Filter which Whatsapp to delete.
     */
    where: WhatsappWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Whatsapp deleteMany
   */
  export type WhatsappDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whatsapps to delete
     */
    where?: WhatsappWhereInput
  }

  /**
   * Whatsapp.tickets
   */
  export type Whatsapp$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Whatsapp.queues
   */
  export type Whatsapp$queuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    cursor?: QueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Whatsapp.whatsappQueues
   */
  export type Whatsapp$whatsappQueuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    where?: WhatsappQueueWhereInput
    orderBy?: WhatsappQueueOrderByWithRelationInput | WhatsappQueueOrderByWithRelationInput[]
    cursor?: WhatsappQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappQueueScalarFieldEnum | WhatsappQueueScalarFieldEnum[]
  }

  /**
   * Whatsapp.prompt
   */
  export type Whatsapp$promptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
  }

  /**
   * Whatsapp.User
   */
  export type Whatsapp$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Whatsapp.TicketTracking
   */
  export type Whatsapp$TicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTracking
     */
    select?: TicketTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTrackingInclude<ExtArgs> | null
    where?: TicketTrackingWhereInput
    orderBy?: TicketTrackingOrderByWithRelationInput | TicketTrackingOrderByWithRelationInput[]
    cursor?: TicketTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTrackingScalarFieldEnum | TicketTrackingScalarFieldEnum[]
  }

  /**
   * Whatsapp.Contact
   */
  export type Whatsapp$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Whatsapp.Campaign
   */
  export type Whatsapp$CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Whatsapp.BaileysChats
   */
  export type Whatsapp$BaileysChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BaileysChats
     */
    select?: BaileysChatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysChatsInclude<ExtArgs> | null
    where?: BaileysChatsWhereInput
    orderBy?: BaileysChatsOrderByWithRelationInput | BaileysChatsOrderByWithRelationInput[]
    cursor?: BaileysChatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BaileysChatsScalarFieldEnum | BaileysChatsScalarFieldEnum[]
  }

  /**
   * Whatsapp.Baileys
   */
  export type Whatsapp$BaileysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Baileys
     */
    select?: BaileysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BaileysInclude<ExtArgs> | null
    where?: BaileysWhereInput
    orderBy?: BaileysOrderByWithRelationInput | BaileysOrderByWithRelationInput[]
    cursor?: BaileysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BaileysScalarFieldEnum | BaileysScalarFieldEnum[]
  }

  /**
   * Whatsapp without action
   */
  export type WhatsappDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsapp
     */
    select?: WhatsappSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappInclude<ExtArgs> | null
  }


  /**
   * Model WhatsappQueue
   */

  export type AggregateWhatsappQueue = {
    _count: WhatsappQueueCountAggregateOutputType | null
    _avg: WhatsappQueueAvgAggregateOutputType | null
    _sum: WhatsappQueueSumAggregateOutputType | null
    _min: WhatsappQueueMinAggregateOutputType | null
    _max: WhatsappQueueMaxAggregateOutputType | null
  }

  export type WhatsappQueueAvgAggregateOutputType = {
    whatsappId: number | null
    queueId: number | null
  }

  export type WhatsappQueueSumAggregateOutputType = {
    whatsappId: number | null
    queueId: number | null
  }

  export type WhatsappQueueMinAggregateOutputType = {
    whatsappId: number | null
    queueId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappQueueMaxAggregateOutputType = {
    whatsappId: number | null
    queueId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappQueueCountAggregateOutputType = {
    whatsappId: number
    queueId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsappQueueAvgAggregateInputType = {
    whatsappId?: true
    queueId?: true
  }

  export type WhatsappQueueSumAggregateInputType = {
    whatsappId?: true
    queueId?: true
  }

  export type WhatsappQueueMinAggregateInputType = {
    whatsappId?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappQueueMaxAggregateInputType = {
    whatsappId?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappQueueCountAggregateInputType = {
    whatsappId?: true
    queueId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsappQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappQueue to aggregate.
     */
    where?: WhatsappQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappQueues to fetch.
     */
    orderBy?: WhatsappQueueOrderByWithRelationInput | WhatsappQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsappQueues
    **/
    _count?: true | WhatsappQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsappQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsappQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappQueueMaxAggregateInputType
  }

  export type GetWhatsappQueueAggregateType<T extends WhatsappQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsappQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsappQueue[P]>
      : GetScalarType<T[P], AggregateWhatsappQueue[P]>
  }




  export type WhatsappQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappQueueWhereInput
    orderBy?: WhatsappQueueOrderByWithAggregationInput | WhatsappQueueOrderByWithAggregationInput[]
    by: WhatsappQueueScalarFieldEnum[] | WhatsappQueueScalarFieldEnum
    having?: WhatsappQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappQueueCountAggregateInputType | true
    _avg?: WhatsappQueueAvgAggregateInputType
    _sum?: WhatsappQueueSumAggregateInputType
    _min?: WhatsappQueueMinAggregateInputType
    _max?: WhatsappQueueMaxAggregateInputType
  }

  export type WhatsappQueueGroupByOutputType = {
    whatsappId: number
    queueId: number
    createdAt: Date
    updatedAt: Date
    _count: WhatsappQueueCountAggregateOutputType | null
    _avg: WhatsappQueueAvgAggregateOutputType | null
    _sum: WhatsappQueueSumAggregateOutputType | null
    _min: WhatsappQueueMinAggregateOutputType | null
    _max: WhatsappQueueMaxAggregateOutputType | null
  }

  type GetWhatsappQueueGroupByPayload<T extends WhatsappQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappQueueGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappQueueGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    whatsappId?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappQueue"]>


  export type WhatsappQueueSelectScalar = {
    whatsappId?: boolean
    queueId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsappQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsapp?: boolean | WhatsappDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }

  export type $WhatsappQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsappQueue"
    objects: {
      whatsapp: Prisma.$WhatsappPayload<ExtArgs>
      queue: Prisma.$QueuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      whatsappId: number
      queueId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsappQueue"]>
    composites: {}
  }

  type WhatsappQueueGetPayload<S extends boolean | null | undefined | WhatsappQueueDefaultArgs> = $Result.GetResult<Prisma.$WhatsappQueuePayload, S>

  type WhatsappQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhatsappQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'relationLoadStrategy'> & {
      select?: WhatsappQueueCountAggregateInputType | true
    }

  export interface WhatsappQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsappQueue'], meta: { name: 'WhatsappQueue' } }
    /**
     * Find zero or one WhatsappQueue that matches the filter.
     * @param {WhatsappQueueFindUniqueArgs} args - Arguments to find a WhatsappQueue
     * @example
     * // Get one WhatsappQueue
     * const whatsappQueue = await prisma.whatsappQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappQueueFindUniqueArgs>(args: SelectSubset<T, WhatsappQueueFindUniqueArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhatsappQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhatsappQueueFindUniqueOrThrowArgs} args - Arguments to find a WhatsappQueue
     * @example
     * // Get one WhatsappQueue
     * const whatsappQueue = await prisma.whatsappQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhatsappQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueFindFirstArgs} args - Arguments to find a WhatsappQueue
     * @example
     * // Get one WhatsappQueue
     * const whatsappQueue = await prisma.whatsappQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappQueueFindFirstArgs>(args?: SelectSubset<T, WhatsappQueueFindFirstArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhatsappQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueFindFirstOrThrowArgs} args - Arguments to find a WhatsappQueue
     * @example
     * // Get one WhatsappQueue
     * const whatsappQueue = await prisma.whatsappQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhatsappQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsappQueues
     * const whatsappQueues = await prisma.whatsappQueue.findMany()
     * 
     * // Get first 10 WhatsappQueues
     * const whatsappQueues = await prisma.whatsappQueue.findMany({ take: 10 })
     * 
     * // Only select the `whatsappId`
     * const whatsappQueueWithWhatsappIdOnly = await prisma.whatsappQueue.findMany({ select: { whatsappId: true } })
     * 
     */
    findMany<T extends WhatsappQueueFindManyArgs>(args?: SelectSubset<T, WhatsappQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhatsappQueue.
     * @param {WhatsappQueueCreateArgs} args - Arguments to create a WhatsappQueue.
     * @example
     * // Create one WhatsappQueue
     * const WhatsappQueue = await prisma.whatsappQueue.create({
     *   data: {
     *     // ... data to create a WhatsappQueue
     *   }
     * })
     * 
     */
    create<T extends WhatsappQueueCreateArgs>(args: SelectSubset<T, WhatsappQueueCreateArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhatsappQueues.
     * @param {WhatsappQueueCreateManyArgs} args - Arguments to create many WhatsappQueues.
     * @example
     * // Create many WhatsappQueues
     * const whatsappQueue = await prisma.whatsappQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappQueueCreateManyArgs>(args?: SelectSubset<T, WhatsappQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WhatsappQueue.
     * @param {WhatsappQueueDeleteArgs} args - Arguments to delete one WhatsappQueue.
     * @example
     * // Delete one WhatsappQueue
     * const WhatsappQueue = await prisma.whatsappQueue.delete({
     *   where: {
     *     // ... filter to delete one WhatsappQueue
     *   }
     * })
     * 
     */
    delete<T extends WhatsappQueueDeleteArgs>(args: SelectSubset<T, WhatsappQueueDeleteArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhatsappQueue.
     * @param {WhatsappQueueUpdateArgs} args - Arguments to update one WhatsappQueue.
     * @example
     * // Update one WhatsappQueue
     * const whatsappQueue = await prisma.whatsappQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappQueueUpdateArgs>(args: SelectSubset<T, WhatsappQueueUpdateArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhatsappQueues.
     * @param {WhatsappQueueDeleteManyArgs} args - Arguments to filter WhatsappQueues to delete.
     * @example
     * // Delete a few WhatsappQueues
     * const { count } = await prisma.whatsappQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappQueueDeleteManyArgs>(args?: SelectSubset<T, WhatsappQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsappQueues
     * const whatsappQueue = await prisma.whatsappQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappQueueUpdateManyArgs>(args: SelectSubset<T, WhatsappQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhatsappQueue.
     * @param {WhatsappQueueUpsertArgs} args - Arguments to update or create a WhatsappQueue.
     * @example
     * // Update or create a WhatsappQueue
     * const whatsappQueue = await prisma.whatsappQueue.upsert({
     *   create: {
     *     // ... data to create a WhatsappQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsappQueue we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappQueueUpsertArgs>(args: SelectSubset<T, WhatsappQueueUpsertArgs<ExtArgs>>): Prisma__WhatsappQueueClient<$Result.GetResult<Prisma.$WhatsappQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhatsappQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueCountArgs} args - Arguments to filter WhatsappQueues to count.
     * @example
     * // Count the number of WhatsappQueues
     * const count = await prisma.whatsappQueue.count({
     *   where: {
     *     // ... the filter for the WhatsappQueues we want to count
     *   }
     * })
    **/
    count<T extends WhatsappQueueCountArgs>(
      args?: Subset<T, WhatsappQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsappQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappQueueAggregateArgs>(args: Subset<T, WhatsappQueueAggregateArgs>): Prisma.PrismaPromise<GetWhatsappQueueAggregateType<T>>

    /**
     * Group by WhatsappQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappQueueGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsappQueue model
   */
  readonly fields: WhatsappQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsappQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsapp<T extends WhatsappDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappDefaultArgs<ExtArgs>>): Prisma__WhatsappClient<$Result.GetResult<Prisma.$WhatsappPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    queue<T extends QueueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueDefaultArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsappQueue model
   */ 
  interface WhatsappQueueFieldRefs {
    readonly whatsappId: FieldRef<"WhatsappQueue", 'Int'>
    readonly queueId: FieldRef<"WhatsappQueue", 'Int'>
    readonly createdAt: FieldRef<"WhatsappQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsappQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsappQueue findUnique
   */
  export type WhatsappQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappQueue to fetch.
     */
    where: WhatsappQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue findUniqueOrThrow
   */
  export type WhatsappQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappQueue to fetch.
     */
    where: WhatsappQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue findFirst
   */
  export type WhatsappQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappQueue to fetch.
     */
    where?: WhatsappQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappQueues to fetch.
     */
    orderBy?: WhatsappQueueOrderByWithRelationInput | WhatsappQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappQueues.
     */
    cursor?: WhatsappQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappQueues.
     */
    distinct?: WhatsappQueueScalarFieldEnum | WhatsappQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue findFirstOrThrow
   */
  export type WhatsappQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappQueue to fetch.
     */
    where?: WhatsappQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappQueues to fetch.
     */
    orderBy?: WhatsappQueueOrderByWithRelationInput | WhatsappQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappQueues.
     */
    cursor?: WhatsappQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappQueues.
     */
    distinct?: WhatsappQueueScalarFieldEnum | WhatsappQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue findMany
   */
  export type WhatsappQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappQueues to fetch.
     */
    where?: WhatsappQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappQueues to fetch.
     */
    orderBy?: WhatsappQueueOrderByWithRelationInput | WhatsappQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsappQueues.
     */
    cursor?: WhatsappQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappQueues.
     */
    skip?: number
    distinct?: WhatsappQueueScalarFieldEnum | WhatsappQueueScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue create
   */
  export type WhatsappQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsappQueue.
     */
    data: XOR<WhatsappQueueCreateInput, WhatsappQueueUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue createMany
   */
  export type WhatsappQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsappQueues.
     */
    data: WhatsappQueueCreateManyInput | WhatsappQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappQueue update
   */
  export type WhatsappQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsappQueue.
     */
    data: XOR<WhatsappQueueUpdateInput, WhatsappQueueUncheckedUpdateInput>
    /**
     * Choose, which WhatsappQueue to update.
     */
    where: WhatsappQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue updateMany
   */
  export type WhatsappQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsappQueues.
     */
    data: XOR<WhatsappQueueUpdateManyMutationInput, WhatsappQueueUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappQueues to update
     */
    where?: WhatsappQueueWhereInput
  }

  /**
   * WhatsappQueue upsert
   */
  export type WhatsappQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsappQueue to update in case it exists.
     */
    where: WhatsappQueueWhereUniqueInput
    /**
     * In case the WhatsappQueue found by the `where` argument doesn't exist, create a new WhatsappQueue with this data.
     */
    create: XOR<WhatsappQueueCreateInput, WhatsappQueueUncheckedCreateInput>
    /**
     * In case the WhatsappQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappQueueUpdateInput, WhatsappQueueUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue delete
   */
  export type WhatsappQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
    /**
     * Filter which WhatsappQueue to delete.
     */
    where: WhatsappQueueWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WhatsappQueue deleteMany
   */
  export type WhatsappQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappQueues to delete
     */
    where?: WhatsappQueueWhereInput
  }

  /**
   * WhatsappQueue without action
   */
  export type WhatsappQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappQueue
     */
    select?: WhatsappQueueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappQueueInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    priority: 'priority',
    title: 'title',
    text: 'text',
    mediaPath: 'mediaPath',
    mediaName: 'mediaName',
    companyId: 'companyId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const BaileysScalarFieldEnum: {
    id: 'id',
    contacts: 'contacts',
    chats: 'chats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    whatsappId: 'whatsappId'
  };

  export type BaileysScalarFieldEnum = (typeof BaileysScalarFieldEnum)[keyof typeof BaileysScalarFieldEnum]


  export const BaileysChatsScalarFieldEnum: {
    id: 'id',
    jid: 'jid',
    conversationTimestamp: 'conversationTimestamp',
    unreadCount: 'unreadCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    whatsappId: 'whatsappId'
  };

  export type BaileysChatsScalarFieldEnum = (typeof BaileysChatsScalarFieldEnum)[keyof typeof BaileysChatsScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    message1: 'message1',
    message2: 'message2',
    message3: 'message3',
    message4: 'message4',
    message5: 'message5',
    confirmationMessage1: 'confirmationMessage1',
    confirmationMessage2: 'confirmationMessage2',
    confirmationMessage3: 'confirmationMessage3',
    confirmationMessage4: 'confirmationMessage4',
    confirmationMessage5: 'confirmationMessage5',
    status: 'status',
    confirmation: 'confirmation',
    mediaPath: 'mediaPath',
    mediaName: 'mediaName',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    contactListId: 'contactListId',
    whatsappId: 'whatsappId',
    fileListId: 'fileListId'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type CampaignSettingScalarFieldEnum = (typeof CampaignSettingScalarFieldEnum)[keyof typeof CampaignSettingScalarFieldEnum]


  export const CampaignShippingScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    number: 'number',
    message: 'message',
    confirmationMessage: 'confirmationMessage',
    confirmation: 'confirmation',
    contactId: 'contactId',
    campaignId: 'campaignId',
    confirmationRequestedAt: 'confirmationRequestedAt',
    confirmedAt: 'confirmedAt',
    deliveredAt: 'deliveredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignShippingScalarFieldEnum = (typeof CampaignShippingScalarFieldEnum)[keyof typeof CampaignShippingScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    title: 'title',
    ownerId: 'ownerId',
    lastMessage: 'lastMessage',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    senderId: 'senderId',
    message: 'message',
    mediaPath: 'mediaPath',
    mediaName: 'mediaName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const ChatUserScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    userId: 'userId',
    unreads: 'unreads',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatUserScalarFieldEnum = (typeof ChatUserScalarFieldEnum)[keyof typeof ChatUserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    status: 'status',
    dueDate: 'dueDate',
    recurrence: 'recurrence',
    planId: 'planId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    number: 'number',
    email: 'email',
    profilePicUrl: 'profilePicUrl',
    isGroup: 'isGroup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    whatsappId: 'whatsappId'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ContactCustomFieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    contactId: 'contactId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactCustomFieldScalarFieldEnum = (typeof ContactCustomFieldScalarFieldEnum)[keyof typeof ContactCustomFieldScalarFieldEnum]


  export const ContactListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type ContactListScalarFieldEnum = (typeof ContactListScalarFieldEnum)[keyof typeof ContactListScalarFieldEnum]


  export const ContactListItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    number: 'number',
    email: 'email',
    isWhatsappValid: 'isWhatsappValid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    contactListId: 'contactListId'
  };

  export type ContactListItemScalarFieldEnum = (typeof ContactListItemScalarFieldEnum)[keyof typeof ContactListItemScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const FilesOptionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    mediaType: 'mediaType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fileId: 'fileId'
  };

  export type FilesOptionsScalarFieldEnum = (typeof FilesOptionsScalarFieldEnum)[keyof typeof FilesOptionsScalarFieldEnum]


  export const HelpScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    video: 'video',
    link: 'link',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpScalarFieldEnum = (typeof HelpScalarFieldEnum)[keyof typeof HelpScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    detail: 'detail',
    status: 'status',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dueDate: 'dueDate',
    companyId: 'companyId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const System_LogsScalarFieldEnum: {
    id: 'id',
    level: 'level',
    message: 'message',
    createdAt: 'createdAt',
    actionLogId: 'actionLogId'
  };

  export type System_LogsScalarFieldEnum = (typeof System_LogsScalarFieldEnum)[keyof typeof System_LogsScalarFieldEnum]


  export const Action_LogsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ticketId: 'ticketId',
    action: 'action',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type Action_LogsScalarFieldEnum = (typeof Action_LogsScalarFieldEnum)[keyof typeof Action_LogsScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    participant: 'participant',
    dataJson: 'dataJson',
    ack: 'ack',
    read: 'read',
    fromMe: 'fromMe',
    body: 'body',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    quotedMsgId: 'quotedMsgId',
    ticketId: 'ticketId',
    contactId: 'contactId',
    companyId: 'companyId',
    queueId: 'queueId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    users: 'users',
    connections: 'connections',
    queues: 'queues',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    useSchedules: 'useSchedules',
    useCampaigns: 'useCampaigns',
    useInternalChat: 'useInternalChat',
    useExternalApi: 'useExternalApi',
    useKanban: 'useKanban',
    useOpenAi: 'useOpenAi',
    useIntegrations: 'useIntegrations'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PromptScalarFieldEnum: {
    id: 'id',
    name: 'name',
    prompt: 'prompt',
    apiKey: 'apiKey',
    maxMessages: 'maxMessages',
    maxTokens: 'maxTokens',
    temperature: 'temperature',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    voice: 'voice',
    voiceKey: 'voiceKey',
    voiceRegion: 'voiceRegion',
    queueId: 'queueId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromptScalarFieldEnum = (typeof PromptScalarFieldEnum)[keyof typeof PromptScalarFieldEnum]


  export const QueueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    greetingMessage: 'greetingMessage',
    outOfHoursMessage: 'outOfHoursMessage',
    schedules: 'schedules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    orderQueue: 'orderQueue',
    integrationId: 'integrationId',
    promptId: 'promptId'
  };

  export type QueueScalarFieldEnum = (typeof QueueScalarFieldEnum)[keyof typeof QueueScalarFieldEnum]


  export const QueueIntegrationsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    projectName: 'projectName',
    jsonContent: 'jsonContent',
    language: 'language',
    urlN8N: 'urlN8N',
    companyId: 'companyId',
    typebotSlug: 'typebotSlug',
    typebotExpires: 'typebotExpires',
    typebotKeywordFinish: 'typebotKeywordFinish',
    typebotUnknownMessage: 'typebotUnknownMessage',
    typebotDelayMessage: 'typebotDelayMessage',
    typebotKeywordRestart: 'typebotKeywordRestart',
    typebotRestartMessage: 'typebotRestartMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QueueIntegrationsScalarFieldEnum = (typeof QueueIntegrationsScalarFieldEnum)[keyof typeof QueueIntegrationsScalarFieldEnum]


  export const QueueOptionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    option: 'option',
    queueId: 'queueId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QueueOptionScalarFieldEnum = (typeof QueueOptionScalarFieldEnum)[keyof typeof QueueOptionScalarFieldEnum]


  export const QuickMessageScalarFieldEnum: {
    id: 'id',
    shortcode: 'shortcode',
    message: 'message',
    mediaName: 'mediaName',
    mediaPath: 'mediaPath',
    companyId: 'companyId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuickMessageScalarFieldEnum = (typeof QuickMessageScalarFieldEnum)[keyof typeof QuickMessageScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    body: 'body',
    sendAt: 'sendAt',
    sentAt: 'sentAt',
    status: 'status',
    mediaPath: 'mediaPath',
    mediaName: 'mediaName',
    contactId: 'contactId',
    ticketId: 'ticketId',
    userId: 'userId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    isActive: 'isActive',
    userPriceCents: 'userPriceCents',
    whatsPriceCents: 'whatsPriceCents',
    lastInvoiceUrl: 'lastInvoiceUrl',
    lastPlanChange: 'lastPlanChange',
    expiresAt: 'expiresAt',
    providerSubscriptionId: 'providerSubscriptionId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    companyId: 'companyId',
    kanban: 'kanban',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    status: 'status',
    unreadMessages: 'unreadMessages',
    lastMessage: 'lastMessage',
    isGroup: 'isGroup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    contactId: 'contactId',
    whatsappId: 'whatsappId',
    queueId: 'queueId',
    chatbot: 'chatbot',
    queueOptionId: 'queueOptionId',
    companyId: 'companyId',
    uuid: 'uuid',
    useIntegration: 'useIntegration',
    integrationId: 'integrationId',
    typebotSessionId: 'typebotSessionId',
    typebotStatus: 'typebotStatus',
    promptId: 'promptId',
    fromMe: 'fromMe',
    amountUsedBotQueues: 'amountUsedBotQueues',
    isBot: 'isBot'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketNoteScalarFieldEnum: {
    id: 'id',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    contactId: 'contactId',
    ticketId: 'ticketId'
  };

  export type TicketNoteScalarFieldEnum = (typeof TicketNoteScalarFieldEnum)[keyof typeof TicketNoteScalarFieldEnum]


  export const TicketTagScalarFieldEnum: {
    ticketId: 'ticketId',
    tagId: 'tagId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketTagScalarFieldEnum = (typeof TicketTagScalarFieldEnum)[keyof typeof TicketTagScalarFieldEnum]


  export const TicketTrackingScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    companyId: 'companyId',
    whatsappId: 'whatsappId',
    userId: 'userId',
    rated: 'rated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    queuedAt: 'queuedAt',
    finishedAt: 'finishedAt',
    closedAt: 'closedAt',
    ratingAt: 'ratingAt',
    chatbotAt: 'chatbotAt'
  };

  export type TicketTrackingScalarFieldEnum = (typeof TicketTrackingScalarFieldEnum)[keyof typeof TicketTrackingScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    tokenVersion: 'tokenVersion',
    profile: 'profile',
    super: 'super',
    online: 'online',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    whatsappId: 'whatsappId',
    avatarUrl: 'avatarUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserQueueScalarFieldEnum: {
    userId: 'userId',
    queueId: 'queueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserQueueScalarFieldEnum = (typeof UserQueueScalarFieldEnum)[keyof typeof UserQueueScalarFieldEnum]


  export const UserRatingScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    companyId: 'companyId',
    userId: 'userId',
    rate: 'rate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserRatingScalarFieldEnum = (typeof UserRatingScalarFieldEnum)[keyof typeof UserRatingScalarFieldEnum]


  export const WhatsappScalarFieldEnum: {
    id: 'id',
    name: 'name',
    session: 'session',
    qrcode: 'qrcode',
    status: 'status',
    battery: 'battery',
    plugged: 'plugged',
    retries: 'retries',
    greetingMessage: 'greetingMessage',
    farewellMessage: 'farewellMessage',
    complationMessage: 'complationMessage',
    outOfHoursMessage: 'outOfHoursMessage',
    ratingMessage: 'ratingMessage',
    provider: 'provider',
    isDefault: 'isDefault',
    token: 'token',
    transferQueueId: 'transferQueueId',
    timeToTransfer: 'timeToTransfer',
    maxUseBotQueues: 'maxUseBotQueues',
    timeUseBotQueues: 'timeUseBotQueues',
    sendIdQueue: 'sendIdQueue',
    timeSendQueue: 'timeSendQueue',
    integrationId: 'integrationId',
    expiresTicket: 'expiresTicket',
    expiresInactiveMessage: 'expiresInactiveMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    promptId: 'promptId'
  };

  export type WhatsappScalarFieldEnum = (typeof WhatsappScalarFieldEnum)[keyof typeof WhatsappScalarFieldEnum]


  export const WhatsappQueueScalarFieldEnum: {
    whatsappId: 'whatsappId',
    queueId: 'queueId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsappQueueScalarFieldEnum = (typeof WhatsappQueueScalarFieldEnum)[keyof typeof WhatsappQueueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: IntFilter<"Announcement"> | number
    priority?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    text?: StringFilter<"Announcement"> | string
    mediaPath?: StringNullableFilter<"Announcement"> | string | null
    mediaName?: StringNullableFilter<"Announcement"> | string | null
    companyId?: IntFilter<"Announcement"> | number
    status?: BoolFilter<"Announcement"> | boolean
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    text?: SortOrder
    mediaPath?: SortOrderInput | SortOrder
    mediaName?: SortOrderInput | SortOrder
    companyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    priority?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    text?: StringFilter<"Announcement"> | string
    mediaPath?: StringNullableFilter<"Announcement"> | string | null
    mediaName?: StringNullableFilter<"Announcement"> | string | null
    companyId?: IntFilter<"Announcement"> | number
    status?: BoolFilter<"Announcement"> | boolean
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    text?: SortOrder
    mediaPath?: SortOrderInput | SortOrder
    mediaName?: SortOrderInput | SortOrder
    companyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _avg?: AnnouncementAvgOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
    _sum?: AnnouncementSumOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Announcement"> | number
    priority?: IntWithAggregatesFilter<"Announcement"> | number
    title?: StringWithAggregatesFilter<"Announcement"> | string
    text?: StringWithAggregatesFilter<"Announcement"> | string
    mediaPath?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    mediaName?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    companyId?: IntWithAggregatesFilter<"Announcement"> | number
    status?: BoolWithAggregatesFilter<"Announcement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type BaileysWhereInput = {
    AND?: BaileysWhereInput | BaileysWhereInput[]
    OR?: BaileysWhereInput[]
    NOT?: BaileysWhereInput | BaileysWhereInput[]
    id?: IntFilter<"Baileys"> | number
    contacts?: StringNullableFilter<"Baileys"> | string | null
    chats?: StringNullableFilter<"Baileys"> | string | null
    createdAt?: DateTimeFilter<"Baileys"> | Date | string
    updatedAt?: DateTimeFilter<"Baileys"> | Date | string
    whatsappId?: IntFilter<"Baileys"> | number
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
  }

  export type BaileysOrderByWithRelationInput = {
    id?: SortOrder
    contacts?: SortOrderInput | SortOrder
    chats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
    whatsapp?: WhatsappOrderByWithRelationInput
  }

  export type BaileysWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BaileysWhereInput | BaileysWhereInput[]
    OR?: BaileysWhereInput[]
    NOT?: BaileysWhereInput | BaileysWhereInput[]
    contacts?: StringNullableFilter<"Baileys"> | string | null
    chats?: StringNullableFilter<"Baileys"> | string | null
    createdAt?: DateTimeFilter<"Baileys"> | Date | string
    updatedAt?: DateTimeFilter<"Baileys"> | Date | string
    whatsappId?: IntFilter<"Baileys"> | number
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
  }, "id">

  export type BaileysOrderByWithAggregationInput = {
    id?: SortOrder
    contacts?: SortOrderInput | SortOrder
    chats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
    _count?: BaileysCountOrderByAggregateInput
    _avg?: BaileysAvgOrderByAggregateInput
    _max?: BaileysMaxOrderByAggregateInput
    _min?: BaileysMinOrderByAggregateInput
    _sum?: BaileysSumOrderByAggregateInput
  }

  export type BaileysScalarWhereWithAggregatesInput = {
    AND?: BaileysScalarWhereWithAggregatesInput | BaileysScalarWhereWithAggregatesInput[]
    OR?: BaileysScalarWhereWithAggregatesInput[]
    NOT?: BaileysScalarWhereWithAggregatesInput | BaileysScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Baileys"> | number
    contacts?: StringNullableWithAggregatesFilter<"Baileys"> | string | null
    chats?: StringNullableWithAggregatesFilter<"Baileys"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Baileys"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Baileys"> | Date | string
    whatsappId?: IntWithAggregatesFilter<"Baileys"> | number
  }

  export type BaileysChatsWhereInput = {
    AND?: BaileysChatsWhereInput | BaileysChatsWhereInput[]
    OR?: BaileysChatsWhereInput[]
    NOT?: BaileysChatsWhereInput | BaileysChatsWhereInput[]
    id?: IntFilter<"BaileysChats"> | number
    jid?: StringFilter<"BaileysChats"> | string
    conversationTimestamp?: IntFilter<"BaileysChats"> | number
    unreadCount?: IntFilter<"BaileysChats"> | number
    createdAt?: DateTimeFilter<"BaileysChats"> | Date | string
    updatedAt?: DateTimeFilter<"BaileysChats"> | Date | string
    whatsappId?: IntFilter<"BaileysChats"> | number
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
  }

  export type BaileysChatsOrderByWithRelationInput = {
    id?: SortOrder
    jid?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
    whatsapp?: WhatsappOrderByWithRelationInput
  }

  export type BaileysChatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BaileysChatsWhereInput | BaileysChatsWhereInput[]
    OR?: BaileysChatsWhereInput[]
    NOT?: BaileysChatsWhereInput | BaileysChatsWhereInput[]
    jid?: StringFilter<"BaileysChats"> | string
    conversationTimestamp?: IntFilter<"BaileysChats"> | number
    unreadCount?: IntFilter<"BaileysChats"> | number
    createdAt?: DateTimeFilter<"BaileysChats"> | Date | string
    updatedAt?: DateTimeFilter<"BaileysChats"> | Date | string
    whatsappId?: IntFilter<"BaileysChats"> | number
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
  }, "id">

  export type BaileysChatsOrderByWithAggregationInput = {
    id?: SortOrder
    jid?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
    _count?: BaileysChatsCountOrderByAggregateInput
    _avg?: BaileysChatsAvgOrderByAggregateInput
    _max?: BaileysChatsMaxOrderByAggregateInput
    _min?: BaileysChatsMinOrderByAggregateInput
    _sum?: BaileysChatsSumOrderByAggregateInput
  }

  export type BaileysChatsScalarWhereWithAggregatesInput = {
    AND?: BaileysChatsScalarWhereWithAggregatesInput | BaileysChatsScalarWhereWithAggregatesInput[]
    OR?: BaileysChatsScalarWhereWithAggregatesInput[]
    NOT?: BaileysChatsScalarWhereWithAggregatesInput | BaileysChatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BaileysChats"> | number
    jid?: StringWithAggregatesFilter<"BaileysChats"> | string
    conversationTimestamp?: IntWithAggregatesFilter<"BaileysChats"> | number
    unreadCount?: IntWithAggregatesFilter<"BaileysChats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BaileysChats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BaileysChats"> | Date | string
    whatsappId?: IntWithAggregatesFilter<"BaileysChats"> | number
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: IntFilter<"Campaign"> | number
    name?: StringFilter<"Campaign"> | string
    message1?: StringFilter<"Campaign"> | string
    message2?: StringFilter<"Campaign"> | string
    message3?: StringFilter<"Campaign"> | string
    message4?: StringFilter<"Campaign"> | string
    message5?: StringFilter<"Campaign"> | string
    confirmationMessage1?: StringFilter<"Campaign"> | string
    confirmationMessage2?: StringFilter<"Campaign"> | string
    confirmationMessage3?: StringFilter<"Campaign"> | string
    confirmationMessage4?: StringFilter<"Campaign"> | string
    confirmationMessage5?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    confirmation?: BoolFilter<"Campaign"> | boolean
    mediaPath?: StringFilter<"Campaign"> | string
    mediaName?: StringFilter<"Campaign"> | string
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    companyId?: IntFilter<"Campaign"> | number
    contactListId?: IntNullableFilter<"Campaign"> | number | null
    whatsappId?: IntNullableFilter<"Campaign"> | number | null
    fileListId?: IntFilter<"Campaign"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    contactList?: XOR<ContactListNullableRelationFilter, ContactListWhereInput> | null
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    fileList?: XOR<FilesRelationFilter, FilesWhereInput>
    shipping?: CampaignShippingListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    message1?: SortOrder
    message2?: SortOrder
    message3?: SortOrder
    message4?: SortOrder
    message5?: SortOrder
    confirmationMessage1?: SortOrder
    confirmationMessage2?: SortOrder
    confirmationMessage3?: SortOrder
    confirmationMessage4?: SortOrder
    confirmationMessage5?: SortOrder
    status?: SortOrder
    confirmation?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrderInput | SortOrder
    whatsappId?: SortOrderInput | SortOrder
    fileListId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    contactList?: ContactListOrderByWithRelationInput
    whatsapp?: WhatsappOrderByWithRelationInput
    fileList?: FilesOrderByWithRelationInput
    shipping?: CampaignShippingOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    message1?: StringFilter<"Campaign"> | string
    message2?: StringFilter<"Campaign"> | string
    message3?: StringFilter<"Campaign"> | string
    message4?: StringFilter<"Campaign"> | string
    message5?: StringFilter<"Campaign"> | string
    confirmationMessage1?: StringFilter<"Campaign"> | string
    confirmationMessage2?: StringFilter<"Campaign"> | string
    confirmationMessage3?: StringFilter<"Campaign"> | string
    confirmationMessage4?: StringFilter<"Campaign"> | string
    confirmationMessage5?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    confirmation?: BoolFilter<"Campaign"> | boolean
    mediaPath?: StringFilter<"Campaign"> | string
    mediaName?: StringFilter<"Campaign"> | string
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    companyId?: IntFilter<"Campaign"> | number
    contactListId?: IntNullableFilter<"Campaign"> | number | null
    whatsappId?: IntNullableFilter<"Campaign"> | number | null
    fileListId?: IntFilter<"Campaign"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    contactList?: XOR<ContactListNullableRelationFilter, ContactListWhereInput> | null
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    fileList?: XOR<FilesRelationFilter, FilesWhereInput>
    shipping?: CampaignShippingListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    message1?: SortOrder
    message2?: SortOrder
    message3?: SortOrder
    message4?: SortOrder
    message5?: SortOrder
    confirmationMessage1?: SortOrder
    confirmationMessage2?: SortOrder
    confirmationMessage3?: SortOrder
    confirmationMessage4?: SortOrder
    confirmationMessage5?: SortOrder
    status?: SortOrder
    confirmation?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrderInput | SortOrder
    whatsappId?: SortOrderInput | SortOrder
    fileListId?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Campaign"> | number
    name?: StringWithAggregatesFilter<"Campaign"> | string
    message1?: StringWithAggregatesFilter<"Campaign"> | string
    message2?: StringWithAggregatesFilter<"Campaign"> | string
    message3?: StringWithAggregatesFilter<"Campaign"> | string
    message4?: StringWithAggregatesFilter<"Campaign"> | string
    message5?: StringWithAggregatesFilter<"Campaign"> | string
    confirmationMessage1?: StringWithAggregatesFilter<"Campaign"> | string
    confirmationMessage2?: StringWithAggregatesFilter<"Campaign"> | string
    confirmationMessage3?: StringWithAggregatesFilter<"Campaign"> | string
    confirmationMessage4?: StringWithAggregatesFilter<"Campaign"> | string
    confirmationMessage5?: StringWithAggregatesFilter<"Campaign"> | string
    status?: StringWithAggregatesFilter<"Campaign"> | string
    confirmation?: BoolWithAggregatesFilter<"Campaign"> | boolean
    mediaPath?: StringWithAggregatesFilter<"Campaign"> | string
    mediaName?: StringWithAggregatesFilter<"Campaign"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    companyId?: IntWithAggregatesFilter<"Campaign"> | number
    contactListId?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    whatsappId?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    fileListId?: IntWithAggregatesFilter<"Campaign"> | number
  }

  export type CampaignSettingWhereInput = {
    AND?: CampaignSettingWhereInput | CampaignSettingWhereInput[]
    OR?: CampaignSettingWhereInput[]
    NOT?: CampaignSettingWhereInput | CampaignSettingWhereInput[]
    id?: IntFilter<"CampaignSetting"> | number
    key?: StringFilter<"CampaignSetting"> | string
    value?: StringFilter<"CampaignSetting"> | string
    createdAt?: DateTimeFilter<"CampaignSetting"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSetting"> | Date | string
    companyId?: IntFilter<"CampaignSetting"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type CampaignSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CampaignSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CampaignSettingWhereInput | CampaignSettingWhereInput[]
    OR?: CampaignSettingWhereInput[]
    NOT?: CampaignSettingWhereInput | CampaignSettingWhereInput[]
    key?: StringFilter<"CampaignSetting"> | string
    value?: StringFilter<"CampaignSetting"> | string
    createdAt?: DateTimeFilter<"CampaignSetting"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSetting"> | Date | string
    companyId?: IntFilter<"CampaignSetting"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type CampaignSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: CampaignSettingCountOrderByAggregateInput
    _avg?: CampaignSettingAvgOrderByAggregateInput
    _max?: CampaignSettingMaxOrderByAggregateInput
    _min?: CampaignSettingMinOrderByAggregateInput
    _sum?: CampaignSettingSumOrderByAggregateInput
  }

  export type CampaignSettingScalarWhereWithAggregatesInput = {
    AND?: CampaignSettingScalarWhereWithAggregatesInput | CampaignSettingScalarWhereWithAggregatesInput[]
    OR?: CampaignSettingScalarWhereWithAggregatesInput[]
    NOT?: CampaignSettingScalarWhereWithAggregatesInput | CampaignSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CampaignSetting"> | number
    key?: StringWithAggregatesFilter<"CampaignSetting"> | string
    value?: StringWithAggregatesFilter<"CampaignSetting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignSetting"> | Date | string
    companyId?: IntWithAggregatesFilter<"CampaignSetting"> | number
  }

  export type CampaignShippingWhereInput = {
    AND?: CampaignShippingWhereInput | CampaignShippingWhereInput[]
    OR?: CampaignShippingWhereInput[]
    NOT?: CampaignShippingWhereInput | CampaignShippingWhereInput[]
    id?: IntFilter<"CampaignShipping"> | number
    jobId?: StringFilter<"CampaignShipping"> | string
    number?: StringFilter<"CampaignShipping"> | string
    message?: StringFilter<"CampaignShipping"> | string
    confirmationMessage?: StringFilter<"CampaignShipping"> | string
    confirmation?: BoolFilter<"CampaignShipping"> | boolean
    contactId?: IntFilter<"CampaignShipping"> | number
    campaignId?: IntFilter<"CampaignShipping"> | number
    confirmationRequestedAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignShipping"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignShipping"> | Date | string
    contact?: XOR<ContactListItemRelationFilter, ContactListItemWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignShippingOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    number?: SortOrder
    message?: SortOrder
    confirmationMessage?: SortOrder
    confirmation?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
    confirmationRequestedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactListItemOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignShippingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contactId_campaignId?: CampaignShippingContactIdCampaignIdCompoundUniqueInput
    AND?: CampaignShippingWhereInput | CampaignShippingWhereInput[]
    OR?: CampaignShippingWhereInput[]
    NOT?: CampaignShippingWhereInput | CampaignShippingWhereInput[]
    jobId?: StringFilter<"CampaignShipping"> | string
    number?: StringFilter<"CampaignShipping"> | string
    message?: StringFilter<"CampaignShipping"> | string
    confirmationMessage?: StringFilter<"CampaignShipping"> | string
    confirmation?: BoolFilter<"CampaignShipping"> | boolean
    contactId?: IntFilter<"CampaignShipping"> | number
    campaignId?: IntFilter<"CampaignShipping"> | number
    confirmationRequestedAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignShipping"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignShipping"> | Date | string
    contact?: XOR<ContactListItemRelationFilter, ContactListItemWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id" | "contactId_campaignId">

  export type CampaignShippingOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    number?: SortOrder
    message?: SortOrder
    confirmationMessage?: SortOrder
    confirmation?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
    confirmationRequestedAt?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignShippingCountOrderByAggregateInput
    _avg?: CampaignShippingAvgOrderByAggregateInput
    _max?: CampaignShippingMaxOrderByAggregateInput
    _min?: CampaignShippingMinOrderByAggregateInput
    _sum?: CampaignShippingSumOrderByAggregateInput
  }

  export type CampaignShippingScalarWhereWithAggregatesInput = {
    AND?: CampaignShippingScalarWhereWithAggregatesInput | CampaignShippingScalarWhereWithAggregatesInput[]
    OR?: CampaignShippingScalarWhereWithAggregatesInput[]
    NOT?: CampaignShippingScalarWhereWithAggregatesInput | CampaignShippingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CampaignShipping"> | number
    jobId?: StringWithAggregatesFilter<"CampaignShipping"> | string
    number?: StringWithAggregatesFilter<"CampaignShipping"> | string
    message?: StringWithAggregatesFilter<"CampaignShipping"> | string
    confirmationMessage?: StringWithAggregatesFilter<"CampaignShipping"> | string
    confirmation?: BoolWithAggregatesFilter<"CampaignShipping"> | boolean
    contactId?: IntWithAggregatesFilter<"CampaignShipping"> | number
    campaignId?: IntWithAggregatesFilter<"CampaignShipping"> | number
    confirmationRequestedAt?: DateTimeNullableWithAggregatesFilter<"CampaignShipping"> | Date | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"CampaignShipping"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"CampaignShipping"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignShipping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignShipping"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: IntFilter<"Chat"> | number
    uuid?: StringFilter<"Chat"> | string
    title?: StringFilter<"Chat"> | string
    ownerId?: IntFilter<"Chat"> | number
    lastMessage?: StringFilter<"Chat"> | string
    companyId?: IntFilter<"Chat"> | number
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    users?: ChatUserListRelationFilter
    messages?: ChatMessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    ownerId?: SortOrder
    lastMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    users?: ChatUserOrderByRelationAggregateInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    uuid?: StringFilter<"Chat"> | string
    title?: StringFilter<"Chat"> | string
    ownerId?: IntFilter<"Chat"> | number
    lastMessage?: StringFilter<"Chat"> | string
    companyId?: IntFilter<"Chat"> | number
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    users?: ChatUserListRelationFilter
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    ownerId?: SortOrder
    lastMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _avg?: ChatAvgOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
    _sum?: ChatSumOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chat"> | number
    uuid?: StringWithAggregatesFilter<"Chat"> | string
    title?: StringWithAggregatesFilter<"Chat"> | string
    ownerId?: IntWithAggregatesFilter<"Chat"> | number
    lastMessage?: StringWithAggregatesFilter<"Chat"> | string
    companyId?: IntWithAggregatesFilter<"Chat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    chatId?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    message?: StringFilter<"ChatMessage"> | string
    mediaPath?: StringNullableFilter<"ChatMessage"> | string | null
    mediaName?: StringNullableFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    mediaPath?: SortOrderInput | SortOrder
    mediaName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    chatId?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    message?: StringFilter<"ChatMessage"> | string
    mediaPath?: StringNullableFilter<"ChatMessage"> | string | null
    mediaName?: StringNullableFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    mediaPath?: SortOrderInput | SortOrder
    mediaName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatMessage"> | number
    chatId?: IntWithAggregatesFilter<"ChatMessage"> | number
    senderId?: IntWithAggregatesFilter<"ChatMessage"> | number
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    mediaPath?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    mediaName?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type ChatUserWhereInput = {
    AND?: ChatUserWhereInput | ChatUserWhereInput[]
    OR?: ChatUserWhereInput[]
    NOT?: ChatUserWhereInput | ChatUserWhereInput[]
    id?: IntFilter<"ChatUser"> | number
    chatId?: IntFilter<"ChatUser"> | number
    userId?: IntFilter<"ChatUser"> | number
    unreads?: IntFilter<"ChatUser"> | number
    createdAt?: DateTimeFilter<"ChatUser"> | Date | string
    updatedAt?: DateTimeFilter<"ChatUser"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatUserOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChatUserWhereInput | ChatUserWhereInput[]
    OR?: ChatUserWhereInput[]
    NOT?: ChatUserWhereInput | ChatUserWhereInput[]
    chatId?: IntFilter<"ChatUser"> | number
    userId?: IntFilter<"ChatUser"> | number
    unreads?: IntFilter<"ChatUser"> | number
    createdAt?: DateTimeFilter<"ChatUser"> | Date | string
    updatedAt?: DateTimeFilter<"ChatUser"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChatUserOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatUserCountOrderByAggregateInput
    _avg?: ChatUserAvgOrderByAggregateInput
    _max?: ChatUserMaxOrderByAggregateInput
    _min?: ChatUserMinOrderByAggregateInput
    _sum?: ChatUserSumOrderByAggregateInput
  }

  export type ChatUserScalarWhereWithAggregatesInput = {
    AND?: ChatUserScalarWhereWithAggregatesInput | ChatUserScalarWhereWithAggregatesInput[]
    OR?: ChatUserScalarWhereWithAggregatesInput[]
    NOT?: ChatUserScalarWhereWithAggregatesInput | ChatUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChatUser"> | number
    chatId?: IntWithAggregatesFilter<"ChatUser"> | number
    userId?: IntWithAggregatesFilter<"ChatUser"> | number
    unreads?: IntWithAggregatesFilter<"ChatUser"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ChatUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatUser"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    status?: BoolFilter<"Company"> | boolean
    dueDate?: DateTimeFilter<"Company"> | Date | string
    recurrence?: StringFilter<"Company"> | string
    planId?: IntFilter<"Company"> | number
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    schedules?: ScheduleListRelationFilter
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    users?: UserListRelationFilter
    userRatings?: UserRatingListRelationFilter
    queues?: QueueListRelationFilter
    whatsapps?: WhatsappListRelationFilter
    messages?: MessageListRelationFilter
    contacts?: ContactListRelationFilter
    settings?: SettingListRelationFilter
    tags?: TagListRelationFilter
    tickets?: TicketListRelationFilter
    ticketTrackings?: TicketTrackingListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    quickMessages?: QuickMessageListRelationFilter
    queueIntegrationss?: QueueIntegrationsListRelationFilter
    prompts?: PromptListRelationFilter
    filess?: FilesListRelationFilter
    contactListItems?: ContactListItemListRelationFilter
    contactLists?: ContactListListRelationFilter
    chats?: ChatListRelationFilter
    campaignSettings?: CampaignSettingListRelationFilter
    campaigns?: CampaignListRelationFilter
    announcements?: AnnouncementListRelationFilter
    queue?: QueueListRelationFilter
    ratings?: RatingListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    recurrence?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schedules?: ScheduleOrderByRelationAggregateInput
    plan?: PlanOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    userRatings?: UserRatingOrderByRelationAggregateInput
    queues?: QueueOrderByRelationAggregateInput
    whatsapps?: WhatsappOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    settings?: SettingOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    ticketTrackings?: TicketTrackingOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    quickMessages?: QuickMessageOrderByRelationAggregateInput
    queueIntegrationss?: QueueIntegrationsOrderByRelationAggregateInput
    prompts?: PromptOrderByRelationAggregateInput
    filess?: FilesOrderByRelationAggregateInput
    contactListItems?: ContactListItemOrderByRelationAggregateInput
    contactLists?: ContactListOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    campaignSettings?: CampaignSettingOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    announcements?: AnnouncementOrderByRelationAggregateInput
    queue?: QueueOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    status?: BoolFilter<"Company"> | boolean
    dueDate?: DateTimeFilter<"Company"> | Date | string
    recurrence?: StringFilter<"Company"> | string
    planId?: IntFilter<"Company"> | number
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    schedules?: ScheduleListRelationFilter
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    users?: UserListRelationFilter
    userRatings?: UserRatingListRelationFilter
    queues?: QueueListRelationFilter
    whatsapps?: WhatsappListRelationFilter
    messages?: MessageListRelationFilter
    contacts?: ContactListRelationFilter
    settings?: SettingListRelationFilter
    tags?: TagListRelationFilter
    tickets?: TicketListRelationFilter
    ticketTrackings?: TicketTrackingListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    quickMessages?: QuickMessageListRelationFilter
    queueIntegrationss?: QueueIntegrationsListRelationFilter
    prompts?: PromptListRelationFilter
    filess?: FilesListRelationFilter
    contactListItems?: ContactListItemListRelationFilter
    contactLists?: ContactListListRelationFilter
    chats?: ChatListRelationFilter
    campaignSettings?: CampaignSettingListRelationFilter
    campaigns?: CampaignListRelationFilter
    announcements?: AnnouncementListRelationFilter
    queue?: QueueListRelationFilter
    ratings?: RatingListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    recurrence?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringWithAggregatesFilter<"Company"> | string
    email?: StringWithAggregatesFilter<"Company"> | string
    status?: BoolWithAggregatesFilter<"Company"> | boolean
    dueDate?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    recurrence?: StringWithAggregatesFilter<"Company"> | string
    planId?: IntWithAggregatesFilter<"Company"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    number?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    profilePicUrl?: StringFilter<"Contact"> | string
    isGroup?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    companyId?: IntFilter<"Contact"> | number
    whatsappId?: IntNullableFilter<"Contact"> | number | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    tickets?: TicketListRelationFilter
    extraInfo?: ContactCustomFieldListRelationFilter
    schedules?: ScheduleListRelationFilter
    TicketNote?: TicketNoteListRelationFilter
    Message?: MessageListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    whatsapp?: WhatsappOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    extraInfo?: ContactCustomFieldOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
    TicketNote?: TicketNoteOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    number?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    profilePicUrl?: StringFilter<"Contact"> | string
    isGroup?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    companyId?: IntFilter<"Contact"> | number
    whatsappId?: IntNullableFilter<"Contact"> | number | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    tickets?: TicketListRelationFilter
    extraInfo?: ContactCustomFieldListRelationFilter
    schedules?: ScheduleListRelationFilter
    TicketNote?: TicketNoteListRelationFilter
    Message?: MessageListRelationFilter
  }, "id" | "number">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    name?: StringWithAggregatesFilter<"Contact"> | string
    number?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    profilePicUrl?: StringWithAggregatesFilter<"Contact"> | string
    isGroup?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    companyId?: IntWithAggregatesFilter<"Contact"> | number
    whatsappId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
  }

  export type ContactCustomFieldWhereInput = {
    AND?: ContactCustomFieldWhereInput | ContactCustomFieldWhereInput[]
    OR?: ContactCustomFieldWhereInput[]
    NOT?: ContactCustomFieldWhereInput | ContactCustomFieldWhereInput[]
    id?: IntFilter<"ContactCustomField"> | number
    name?: StringFilter<"ContactCustomField"> | string
    value?: StringFilter<"ContactCustomField"> | string
    contactId?: IntFilter<"ContactCustomField"> | number
    createdAt?: DateTimeFilter<"ContactCustomField"> | Date | string
    updatedAt?: DateTimeFilter<"ContactCustomField"> | Date | string
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
  }

  export type ContactCustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
  }

  export type ContactCustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactCustomFieldWhereInput | ContactCustomFieldWhereInput[]
    OR?: ContactCustomFieldWhereInput[]
    NOT?: ContactCustomFieldWhereInput | ContactCustomFieldWhereInput[]
    name?: StringFilter<"ContactCustomField"> | string
    value?: StringFilter<"ContactCustomField"> | string
    contactId?: IntFilter<"ContactCustomField"> | number
    createdAt?: DateTimeFilter<"ContactCustomField"> | Date | string
    updatedAt?: DateTimeFilter<"ContactCustomField"> | Date | string
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
  }, "id">

  export type ContactCustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCustomFieldCountOrderByAggregateInput
    _avg?: ContactCustomFieldAvgOrderByAggregateInput
    _max?: ContactCustomFieldMaxOrderByAggregateInput
    _min?: ContactCustomFieldMinOrderByAggregateInput
    _sum?: ContactCustomFieldSumOrderByAggregateInput
  }

  export type ContactCustomFieldScalarWhereWithAggregatesInput = {
    AND?: ContactCustomFieldScalarWhereWithAggregatesInput | ContactCustomFieldScalarWhereWithAggregatesInput[]
    OR?: ContactCustomFieldScalarWhereWithAggregatesInput[]
    NOT?: ContactCustomFieldScalarWhereWithAggregatesInput | ContactCustomFieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactCustomField"> | number
    name?: StringWithAggregatesFilter<"ContactCustomField"> | string
    value?: StringWithAggregatesFilter<"ContactCustomField"> | string
    contactId?: IntWithAggregatesFilter<"ContactCustomField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContactCustomField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactCustomField"> | Date | string
  }

  export type ContactListWhereInput = {
    AND?: ContactListWhereInput | ContactListWhereInput[]
    OR?: ContactListWhereInput[]
    NOT?: ContactListWhereInput | ContactListWhereInput[]
    id?: IntFilter<"ContactList"> | number
    name?: StringFilter<"ContactList"> | string
    createdAt?: DateTimeFilter<"ContactList"> | Date | string
    updatedAt?: DateTimeFilter<"ContactList"> | Date | string
    companyId?: IntFilter<"ContactList"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    items?: ContactListItemListRelationFilter
    Campaign?: CampaignListRelationFilter
  }

  export type ContactListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    items?: ContactListItemOrderByRelationAggregateInput
    Campaign?: CampaignOrderByRelationAggregateInput
  }

  export type ContactListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactListWhereInput | ContactListWhereInput[]
    OR?: ContactListWhereInput[]
    NOT?: ContactListWhereInput | ContactListWhereInput[]
    name?: StringFilter<"ContactList"> | string
    createdAt?: DateTimeFilter<"ContactList"> | Date | string
    updatedAt?: DateTimeFilter<"ContactList"> | Date | string
    companyId?: IntFilter<"ContactList"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    items?: ContactListItemListRelationFilter
    Campaign?: CampaignListRelationFilter
  }, "id">

  export type ContactListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: ContactListCountOrderByAggregateInput
    _avg?: ContactListAvgOrderByAggregateInput
    _max?: ContactListMaxOrderByAggregateInput
    _min?: ContactListMinOrderByAggregateInput
    _sum?: ContactListSumOrderByAggregateInput
  }

  export type ContactListScalarWhereWithAggregatesInput = {
    AND?: ContactListScalarWhereWithAggregatesInput | ContactListScalarWhereWithAggregatesInput[]
    OR?: ContactListScalarWhereWithAggregatesInput[]
    NOT?: ContactListScalarWhereWithAggregatesInput | ContactListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactList"> | number
    name?: StringWithAggregatesFilter<"ContactList"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactList"> | Date | string
    companyId?: IntWithAggregatesFilter<"ContactList"> | number
  }

  export type ContactListItemWhereInput = {
    AND?: ContactListItemWhereInput | ContactListItemWhereInput[]
    OR?: ContactListItemWhereInput[]
    NOT?: ContactListItemWhereInput | ContactListItemWhereInput[]
    id?: IntFilter<"ContactListItem"> | number
    name?: StringFilter<"ContactListItem"> | string
    number?: StringFilter<"ContactListItem"> | string
    email?: StringFilter<"ContactListItem"> | string
    isWhatsappValid?: BoolNullableFilter<"ContactListItem"> | boolean | null
    createdAt?: DateTimeFilter<"ContactListItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContactListItem"> | Date | string
    companyId?: IntFilter<"ContactListItem"> | number
    contactListId?: IntFilter<"ContactListItem"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    contactList?: XOR<ContactListRelationFilter, ContactListWhereInput>
    CampaignShipping?: CampaignShippingListRelationFilter
  }

  export type ContactListItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    isWhatsappValid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    contactList?: ContactListOrderByWithRelationInput
    CampaignShipping?: CampaignShippingOrderByRelationAggregateInput
  }

  export type ContactListItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactListItemWhereInput | ContactListItemWhereInput[]
    OR?: ContactListItemWhereInput[]
    NOT?: ContactListItemWhereInput | ContactListItemWhereInput[]
    name?: StringFilter<"ContactListItem"> | string
    number?: StringFilter<"ContactListItem"> | string
    email?: StringFilter<"ContactListItem"> | string
    isWhatsappValid?: BoolNullableFilter<"ContactListItem"> | boolean | null
    createdAt?: DateTimeFilter<"ContactListItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContactListItem"> | Date | string
    companyId?: IntFilter<"ContactListItem"> | number
    contactListId?: IntFilter<"ContactListItem"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    contactList?: XOR<ContactListRelationFilter, ContactListWhereInput>
    CampaignShipping?: CampaignShippingListRelationFilter
  }, "id">

  export type ContactListItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    isWhatsappValid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    _count?: ContactListItemCountOrderByAggregateInput
    _avg?: ContactListItemAvgOrderByAggregateInput
    _max?: ContactListItemMaxOrderByAggregateInput
    _min?: ContactListItemMinOrderByAggregateInput
    _sum?: ContactListItemSumOrderByAggregateInput
  }

  export type ContactListItemScalarWhereWithAggregatesInput = {
    AND?: ContactListItemScalarWhereWithAggregatesInput | ContactListItemScalarWhereWithAggregatesInput[]
    OR?: ContactListItemScalarWhereWithAggregatesInput[]
    NOT?: ContactListItemScalarWhereWithAggregatesInput | ContactListItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactListItem"> | number
    name?: StringWithAggregatesFilter<"ContactListItem"> | string
    number?: StringWithAggregatesFilter<"ContactListItem"> | string
    email?: StringWithAggregatesFilter<"ContactListItem"> | string
    isWhatsappValid?: BoolNullableWithAggregatesFilter<"ContactListItem"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactListItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactListItem"> | Date | string
    companyId?: IntWithAggregatesFilter<"ContactListItem"> | number
    contactListId?: IntWithAggregatesFilter<"ContactListItem"> | number
  }

  export type FilesWhereInput = {
    AND?: FilesWhereInput | FilesWhereInput[]
    OR?: FilesWhereInput[]
    NOT?: FilesWhereInput | FilesWhereInput[]
    id?: IntFilter<"Files"> | number
    name?: StringFilter<"Files"> | string
    message?: StringFilter<"Files"> | string
    createdAt?: DateTimeFilter<"Files"> | Date | string
    updatedAt?: DateTimeFilter<"Files"> | Date | string
    companyId?: IntFilter<"Files"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    options?: FilesOptionsListRelationFilter
    Campaign?: CampaignListRelationFilter
  }

  export type FilesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    options?: FilesOptionsOrderByRelationAggregateInput
    Campaign?: CampaignOrderByRelationAggregateInput
  }

  export type FilesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilesWhereInput | FilesWhereInput[]
    OR?: FilesWhereInput[]
    NOT?: FilesWhereInput | FilesWhereInput[]
    name?: StringFilter<"Files"> | string
    message?: StringFilter<"Files"> | string
    createdAt?: DateTimeFilter<"Files"> | Date | string
    updatedAt?: DateTimeFilter<"Files"> | Date | string
    companyId?: IntFilter<"Files"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    options?: FilesOptionsListRelationFilter
    Campaign?: CampaignListRelationFilter
  }, "id">

  export type FilesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: FilesCountOrderByAggregateInput
    _avg?: FilesAvgOrderByAggregateInput
    _max?: FilesMaxOrderByAggregateInput
    _min?: FilesMinOrderByAggregateInput
    _sum?: FilesSumOrderByAggregateInput
  }

  export type FilesScalarWhereWithAggregatesInput = {
    AND?: FilesScalarWhereWithAggregatesInput | FilesScalarWhereWithAggregatesInput[]
    OR?: FilesScalarWhereWithAggregatesInput[]
    NOT?: FilesScalarWhereWithAggregatesInput | FilesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Files"> | number
    name?: StringWithAggregatesFilter<"Files"> | string
    message?: StringWithAggregatesFilter<"Files"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Files"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Files"> | Date | string
    companyId?: IntWithAggregatesFilter<"Files"> | number
  }

  export type FilesOptionsWhereInput = {
    AND?: FilesOptionsWhereInput | FilesOptionsWhereInput[]
    OR?: FilesOptionsWhereInput[]
    NOT?: FilesOptionsWhereInput | FilesOptionsWhereInput[]
    id?: IntFilter<"FilesOptions"> | number
    name?: StringFilter<"FilesOptions"> | string
    path?: StringFilter<"FilesOptions"> | string
    mediaType?: StringFilter<"FilesOptions"> | string
    createdAt?: DateTimeFilter<"FilesOptions"> | Date | string
    updatedAt?: DateTimeFilter<"FilesOptions"> | Date | string
    fileId?: IntFilter<"FilesOptions"> | number
    file?: XOR<FilesRelationFilter, FilesWhereInput>
  }

  export type FilesOptionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileId?: SortOrder
    file?: FilesOrderByWithRelationInput
  }

  export type FilesOptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FilesOptionsWhereInput | FilesOptionsWhereInput[]
    OR?: FilesOptionsWhereInput[]
    NOT?: FilesOptionsWhereInput | FilesOptionsWhereInput[]
    name?: StringFilter<"FilesOptions"> | string
    path?: StringFilter<"FilesOptions"> | string
    mediaType?: StringFilter<"FilesOptions"> | string
    createdAt?: DateTimeFilter<"FilesOptions"> | Date | string
    updatedAt?: DateTimeFilter<"FilesOptions"> | Date | string
    fileId?: IntFilter<"FilesOptions"> | number
    file?: XOR<FilesRelationFilter, FilesWhereInput>
  }, "id">

  export type FilesOptionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileId?: SortOrder
    _count?: FilesOptionsCountOrderByAggregateInput
    _avg?: FilesOptionsAvgOrderByAggregateInput
    _max?: FilesOptionsMaxOrderByAggregateInput
    _min?: FilesOptionsMinOrderByAggregateInput
    _sum?: FilesOptionsSumOrderByAggregateInput
  }

  export type FilesOptionsScalarWhereWithAggregatesInput = {
    AND?: FilesOptionsScalarWhereWithAggregatesInput | FilesOptionsScalarWhereWithAggregatesInput[]
    OR?: FilesOptionsScalarWhereWithAggregatesInput[]
    NOT?: FilesOptionsScalarWhereWithAggregatesInput | FilesOptionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilesOptions"> | number
    name?: StringWithAggregatesFilter<"FilesOptions"> | string
    path?: StringWithAggregatesFilter<"FilesOptions"> | string
    mediaType?: StringWithAggregatesFilter<"FilesOptions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FilesOptions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FilesOptions"> | Date | string
    fileId?: IntWithAggregatesFilter<"FilesOptions"> | number
  }

  export type HelpWhereInput = {
    AND?: HelpWhereInput | HelpWhereInput[]
    OR?: HelpWhereInput[]
    NOT?: HelpWhereInput | HelpWhereInput[]
    id?: IntFilter<"Help"> | number
    title?: StringFilter<"Help"> | string
    description?: StringFilter<"Help"> | string
    video?: StringFilter<"Help"> | string
    link?: StringFilter<"Help"> | string
    createdAt?: DateTimeFilter<"Help"> | Date | string
    updatedAt?: DateTimeFilter<"Help"> | Date | string
  }

  export type HelpOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    video?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HelpWhereInput | HelpWhereInput[]
    OR?: HelpWhereInput[]
    NOT?: HelpWhereInput | HelpWhereInput[]
    title?: StringFilter<"Help"> | string
    description?: StringFilter<"Help"> | string
    video?: StringFilter<"Help"> | string
    link?: StringFilter<"Help"> | string
    createdAt?: DateTimeFilter<"Help"> | Date | string
    updatedAt?: DateTimeFilter<"Help"> | Date | string
  }, "id">

  export type HelpOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    video?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpCountOrderByAggregateInput
    _avg?: HelpAvgOrderByAggregateInput
    _max?: HelpMaxOrderByAggregateInput
    _min?: HelpMinOrderByAggregateInput
    _sum?: HelpSumOrderByAggregateInput
  }

  export type HelpScalarWhereWithAggregatesInput = {
    AND?: HelpScalarWhereWithAggregatesInput | HelpScalarWhereWithAggregatesInput[]
    OR?: HelpScalarWhereWithAggregatesInput[]
    NOT?: HelpScalarWhereWithAggregatesInput | HelpScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Help"> | number
    title?: StringWithAggregatesFilter<"Help"> | string
    description?: StringWithAggregatesFilter<"Help"> | string
    video?: StringWithAggregatesFilter<"Help"> | string
    link?: StringWithAggregatesFilter<"Help"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Help"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Help"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    detail?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    value?: FloatFilter<"Invoice"> | number
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: StringFilter<"Invoice"> | string
    companyId?: IntFilter<"Invoice"> | number
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    detail?: StringFilter<"Invoice"> | string
    status?: StringFilter<"Invoice"> | string
    value?: FloatFilter<"Invoice"> | number
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: StringFilter<"Invoice"> | string
    companyId?: IntFilter<"Invoice"> | number
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    companyId?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    detail?: StringWithAggregatesFilter<"Invoice"> | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    value?: FloatWithAggregatesFilter<"Invoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: StringWithAggregatesFilter<"Invoice"> | string
    companyId?: IntWithAggregatesFilter<"Invoice"> | number
  }

  export type System_LogsWhereInput = {
    AND?: System_LogsWhereInput | System_LogsWhereInput[]
    OR?: System_LogsWhereInput[]
    NOT?: System_LogsWhereInput | System_LogsWhereInput[]
    id?: IntFilter<"System_Logs"> | number
    level?: StringFilter<"System_Logs"> | string
    message?: StringFilter<"System_Logs"> | string
    createdAt?: DateTimeFilter<"System_Logs"> | Date | string
    actionLogId?: IntNullableFilter<"System_Logs"> | number | null
    actionLog?: XOR<Action_LogsNullableRelationFilter, Action_LogsWhereInput> | null
  }

  export type System_LogsOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    actionLogId?: SortOrderInput | SortOrder
    actionLog?: Action_LogsOrderByWithRelationInput
  }

  export type System_LogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: System_LogsWhereInput | System_LogsWhereInput[]
    OR?: System_LogsWhereInput[]
    NOT?: System_LogsWhereInput | System_LogsWhereInput[]
    level?: StringFilter<"System_Logs"> | string
    message?: StringFilter<"System_Logs"> | string
    createdAt?: DateTimeFilter<"System_Logs"> | Date | string
    actionLogId?: IntNullableFilter<"System_Logs"> | number | null
    actionLog?: XOR<Action_LogsNullableRelationFilter, Action_LogsWhereInput> | null
  }, "id">

  export type System_LogsOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    actionLogId?: SortOrderInput | SortOrder
    _count?: System_LogsCountOrderByAggregateInput
    _avg?: System_LogsAvgOrderByAggregateInput
    _max?: System_LogsMaxOrderByAggregateInput
    _min?: System_LogsMinOrderByAggregateInput
    _sum?: System_LogsSumOrderByAggregateInput
  }

  export type System_LogsScalarWhereWithAggregatesInput = {
    AND?: System_LogsScalarWhereWithAggregatesInput | System_LogsScalarWhereWithAggregatesInput[]
    OR?: System_LogsScalarWhereWithAggregatesInput[]
    NOT?: System_LogsScalarWhereWithAggregatesInput | System_LogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"System_Logs"> | number
    level?: StringWithAggregatesFilter<"System_Logs"> | string
    message?: StringWithAggregatesFilter<"System_Logs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"System_Logs"> | Date | string
    actionLogId?: IntNullableWithAggregatesFilter<"System_Logs"> | number | null
  }

  export type Action_LogsWhereInput = {
    AND?: Action_LogsWhereInput | Action_LogsWhereInput[]
    OR?: Action_LogsWhereInput[]
    NOT?: Action_LogsWhereInput | Action_LogsWhereInput[]
    id?: IntFilter<"Action_Logs"> | number
    userId?: IntFilter<"Action_Logs"> | number
    ticketId?: IntNullableFilter<"Action_Logs"> | number | null
    action?: StringFilter<"Action_Logs"> | string
    message?: StringNullableFilter<"Action_Logs"> | string | null
    createdAt?: DateTimeFilter<"Action_Logs"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ticket?: XOR<TicketNullableRelationFilter, TicketWhereInput> | null
    System_Logs?: System_LogsListRelationFilter
  }

  export type Action_LogsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
    System_Logs?: System_LogsOrderByRelationAggregateInput
  }

  export type Action_LogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Action_LogsWhereInput | Action_LogsWhereInput[]
    OR?: Action_LogsWhereInput[]
    NOT?: Action_LogsWhereInput | Action_LogsWhereInput[]
    userId?: IntFilter<"Action_Logs"> | number
    ticketId?: IntNullableFilter<"Action_Logs"> | number | null
    action?: StringFilter<"Action_Logs"> | string
    message?: StringNullableFilter<"Action_Logs"> | string | null
    createdAt?: DateTimeFilter<"Action_Logs"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    ticket?: XOR<TicketNullableRelationFilter, TicketWhereInput> | null
    System_Logs?: System_LogsListRelationFilter
  }, "id">

  export type Action_LogsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrderInput | SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: Action_LogsCountOrderByAggregateInput
    _avg?: Action_LogsAvgOrderByAggregateInput
    _max?: Action_LogsMaxOrderByAggregateInput
    _min?: Action_LogsMinOrderByAggregateInput
    _sum?: Action_LogsSumOrderByAggregateInput
  }

  export type Action_LogsScalarWhereWithAggregatesInput = {
    AND?: Action_LogsScalarWhereWithAggregatesInput | Action_LogsScalarWhereWithAggregatesInput[]
    OR?: Action_LogsScalarWhereWithAggregatesInput[]
    NOT?: Action_LogsScalarWhereWithAggregatesInput | Action_LogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Action_Logs"> | number
    userId?: IntWithAggregatesFilter<"Action_Logs"> | number
    ticketId?: IntNullableWithAggregatesFilter<"Action_Logs"> | number | null
    action?: StringWithAggregatesFilter<"Action_Logs"> | string
    message?: StringNullableWithAggregatesFilter<"Action_Logs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Action_Logs"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    remoteJid?: StringFilter<"Message"> | string
    participant?: StringFilter<"Message"> | string
    dataJson?: StringFilter<"Message"> | string
    ack?: IntFilter<"Message"> | number
    read?: BoolFilter<"Message"> | boolean
    fromMe?: BoolFilter<"Message"> | boolean
    body?: StringFilter<"Message"> | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringFilter<"Message"> | string
    isDeleted?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    quotedMsgId?: StringNullableFilter<"Message"> | string | null
    ticketId?: IntNullableFilter<"Message"> | number | null
    contactId?: IntNullableFilter<"Message"> | number | null
    companyId?: IntFilter<"Message"> | number
    queueId?: IntNullableFilter<"Message"> | number | null
    quotedMsg?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    ticket?: XOR<TicketNullableRelationFilter, TicketWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    queue?: XOR<QueueNullableRelationFilter, QueueWhereInput> | null
    Message?: MessageListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    participant?: SortOrder
    dataJson?: SortOrder
    ack?: SortOrder
    read?: SortOrder
    fromMe?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotedMsgId?: SortOrderInput | SortOrder
    ticketId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    queueId?: SortOrderInput | SortOrder
    quotedMsg?: MessageOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    queue?: QueueOrderByWithRelationInput
    Message?: MessageOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    remoteJid?: StringFilter<"Message"> | string
    participant?: StringFilter<"Message"> | string
    dataJson?: StringFilter<"Message"> | string
    ack?: IntFilter<"Message"> | number
    read?: BoolFilter<"Message"> | boolean
    fromMe?: BoolFilter<"Message"> | boolean
    body?: StringFilter<"Message"> | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringFilter<"Message"> | string
    isDeleted?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    quotedMsgId?: StringNullableFilter<"Message"> | string | null
    ticketId?: IntNullableFilter<"Message"> | number | null
    contactId?: IntNullableFilter<"Message"> | number | null
    companyId?: IntFilter<"Message"> | number
    queueId?: IntNullableFilter<"Message"> | number | null
    quotedMsg?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    ticket?: XOR<TicketNullableRelationFilter, TicketWhereInput> | null
    contact?: XOR<ContactNullableRelationFilter, ContactWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    queue?: XOR<QueueNullableRelationFilter, QueueWhereInput> | null
    Message?: MessageListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    participant?: SortOrder
    dataJson?: SortOrder
    ack?: SortOrder
    read?: SortOrder
    fromMe?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotedMsgId?: SortOrderInput | SortOrder
    ticketId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    queueId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    remoteJid?: StringWithAggregatesFilter<"Message"> | string
    participant?: StringWithAggregatesFilter<"Message"> | string
    dataJson?: StringWithAggregatesFilter<"Message"> | string
    ack?: IntWithAggregatesFilter<"Message"> | number
    read?: BoolWithAggregatesFilter<"Message"> | boolean
    fromMe?: BoolWithAggregatesFilter<"Message"> | boolean
    body?: StringWithAggregatesFilter<"Message"> | string
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaType?: StringWithAggregatesFilter<"Message"> | string
    isDeleted?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    quotedMsgId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    ticketId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    contactId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    companyId?: IntWithAggregatesFilter<"Message"> | number
    queueId?: IntNullableWithAggregatesFilter<"Message"> | number | null
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: IntFilter<"Plan"> | number
    name?: StringFilter<"Plan"> | string
    users?: IntNullableFilter<"Plan"> | number | null
    connections?: IntNullableFilter<"Plan"> | number | null
    queues?: IntNullableFilter<"Plan"> | number | null
    value?: FloatNullableFilter<"Plan"> | number | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    useSchedules?: BoolFilter<"Plan"> | boolean
    useCampaigns?: BoolFilter<"Plan"> | boolean
    useInternalChat?: BoolFilter<"Plan"> | boolean
    useExternalApi?: BoolFilter<"Plan"> | boolean
    useKanban?: BoolFilter<"Plan"> | boolean
    useOpenAi?: BoolFilter<"Plan"> | boolean
    useIntegrations?: BoolFilter<"Plan"> | boolean
    Company?: CompanyListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: SortOrderInput | SortOrder
    connections?: SortOrderInput | SortOrder
    queues?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    useSchedules?: SortOrder
    useCampaigns?: SortOrder
    useInternalChat?: SortOrder
    useExternalApi?: SortOrder
    useKanban?: SortOrder
    useOpenAi?: SortOrder
    useIntegrations?: SortOrder
    Company?: CompanyOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    users?: IntNullableFilter<"Plan"> | number | null
    connections?: IntNullableFilter<"Plan"> | number | null
    queues?: IntNullableFilter<"Plan"> | number | null
    value?: FloatNullableFilter<"Plan"> | number | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    useSchedules?: BoolFilter<"Plan"> | boolean
    useCampaigns?: BoolFilter<"Plan"> | boolean
    useInternalChat?: BoolFilter<"Plan"> | boolean
    useExternalApi?: BoolFilter<"Plan"> | boolean
    useKanban?: BoolFilter<"Plan"> | boolean
    useOpenAi?: BoolFilter<"Plan"> | boolean
    useIntegrations?: BoolFilter<"Plan"> | boolean
    Company?: CompanyListRelationFilter
  }, "id" | "name">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: SortOrderInput | SortOrder
    connections?: SortOrderInput | SortOrder
    queues?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    useSchedules?: SortOrder
    useCampaigns?: SortOrder
    useInternalChat?: SortOrder
    useExternalApi?: SortOrder
    useKanban?: SortOrder
    useOpenAi?: SortOrder
    useIntegrations?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plan"> | number
    name?: StringWithAggregatesFilter<"Plan"> | string
    users?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    connections?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    queues?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    value?: FloatNullableWithAggregatesFilter<"Plan"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    useSchedules?: BoolWithAggregatesFilter<"Plan"> | boolean
    useCampaigns?: BoolWithAggregatesFilter<"Plan"> | boolean
    useInternalChat?: BoolWithAggregatesFilter<"Plan"> | boolean
    useExternalApi?: BoolWithAggregatesFilter<"Plan"> | boolean
    useKanban?: BoolWithAggregatesFilter<"Plan"> | boolean
    useOpenAi?: BoolWithAggregatesFilter<"Plan"> | boolean
    useIntegrations?: BoolWithAggregatesFilter<"Plan"> | boolean
  }

  export type PromptWhereInput = {
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    id?: IntFilter<"Prompt"> | number
    name?: StringFilter<"Prompt"> | string
    prompt?: StringFilter<"Prompt"> | string
    apiKey?: StringFilter<"Prompt"> | string
    maxMessages?: IntFilter<"Prompt"> | number
    maxTokens?: IntFilter<"Prompt"> | number
    temperature?: IntFilter<"Prompt"> | number
    promptTokens?: IntFilter<"Prompt"> | number
    completionTokens?: IntFilter<"Prompt"> | number
    totalTokens?: IntFilter<"Prompt"> | number
    voice?: StringFilter<"Prompt"> | string
    voiceKey?: StringNullableFilter<"Prompt"> | string | null
    voiceRegion?: StringNullableFilter<"Prompt"> | string | null
    queueId?: IntNullableFilter<"Prompt"> | number | null
    companyId?: IntFilter<"Prompt"> | number
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    queue?: XOR<QueueNullableRelationFilter, QueueWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    Whatsapp?: WhatsappListRelationFilter
    Ticket?: TicketListRelationFilter
  }

  export type PromptOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    apiKey?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    voice?: SortOrder
    voiceKey?: SortOrderInput | SortOrder
    voiceRegion?: SortOrderInput | SortOrder
    queueId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    queue?: QueueOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    Whatsapp?: WhatsappOrderByRelationAggregateInput
    Ticket?: TicketOrderByRelationAggregateInput
  }

  export type PromptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    queueId?: number
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    name?: StringFilter<"Prompt"> | string
    prompt?: StringFilter<"Prompt"> | string
    apiKey?: StringFilter<"Prompt"> | string
    maxMessages?: IntFilter<"Prompt"> | number
    maxTokens?: IntFilter<"Prompt"> | number
    temperature?: IntFilter<"Prompt"> | number
    promptTokens?: IntFilter<"Prompt"> | number
    completionTokens?: IntFilter<"Prompt"> | number
    totalTokens?: IntFilter<"Prompt"> | number
    voice?: StringFilter<"Prompt"> | string
    voiceKey?: StringNullableFilter<"Prompt"> | string | null
    voiceRegion?: StringNullableFilter<"Prompt"> | string | null
    companyId?: IntFilter<"Prompt"> | number
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    queue?: XOR<QueueNullableRelationFilter, QueueWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    Whatsapp?: WhatsappListRelationFilter
    Ticket?: TicketListRelationFilter
  }, "id" | "queueId">

  export type PromptOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    apiKey?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    voice?: SortOrder
    voiceKey?: SortOrderInput | SortOrder
    voiceRegion?: SortOrderInput | SortOrder
    queueId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromptCountOrderByAggregateInput
    _avg?: PromptAvgOrderByAggregateInput
    _max?: PromptMaxOrderByAggregateInput
    _min?: PromptMinOrderByAggregateInput
    _sum?: PromptSumOrderByAggregateInput
  }

  export type PromptScalarWhereWithAggregatesInput = {
    AND?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    OR?: PromptScalarWhereWithAggregatesInput[]
    NOT?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prompt"> | number
    name?: StringWithAggregatesFilter<"Prompt"> | string
    prompt?: StringWithAggregatesFilter<"Prompt"> | string
    apiKey?: StringWithAggregatesFilter<"Prompt"> | string
    maxMessages?: IntWithAggregatesFilter<"Prompt"> | number
    maxTokens?: IntWithAggregatesFilter<"Prompt"> | number
    temperature?: IntWithAggregatesFilter<"Prompt"> | number
    promptTokens?: IntWithAggregatesFilter<"Prompt"> | number
    completionTokens?: IntWithAggregatesFilter<"Prompt"> | number
    totalTokens?: IntWithAggregatesFilter<"Prompt"> | number
    voice?: StringWithAggregatesFilter<"Prompt"> | string
    voiceKey?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    voiceRegion?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    queueId?: IntNullableWithAggregatesFilter<"Prompt"> | number | null
    companyId?: IntWithAggregatesFilter<"Prompt"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
  }

  export type QueueWhereInput = {
    AND?: QueueWhereInput | QueueWhereInput[]
    OR?: QueueWhereInput[]
    NOT?: QueueWhereInput | QueueWhereInput[]
    id?: IntFilter<"Queue"> | number
    name?: StringFilter<"Queue"> | string
    color?: StringFilter<"Queue"> | string
    greetingMessage?: StringFilter<"Queue"> | string
    outOfHoursMessage?: StringFilter<"Queue"> | string
    schedules?: JsonNullableFilter<"Queue">
    createdAt?: DateTimeFilter<"Queue"> | Date | string
    updatedAt?: DateTimeFilter<"Queue"> | Date | string
    companyId?: IntFilter<"Queue"> | number
    orderQueue?: IntFilter<"Queue"> | number
    integrationId?: IntNullableFilter<"Queue"> | number | null
    promptId?: IntNullableFilter<"Queue"> | number | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapps?: WhatsappListRelationFilter
    users?: UserListRelationFilter
    options?: QueueOptionListRelationFilter
    queueIntegrations?: XOR<QueueIntegrationsNullableRelationFilter, QueueIntegrationsWhereInput> | null
    prompt?: PromptListRelationFilter
    UserQueue?: UserQueueListRelationFilter
    WhatsappQueue?: WhatsappQueueListRelationFilter
    Ticket?: TicketListRelationFilter
    Message?: MessageListRelationFilter
    Company?: CompanyListRelationFilter
  }

  export type QueueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    greetingMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    schedules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    whatsapps?: WhatsappOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    options?: QueueOptionOrderByRelationAggregateInput
    queueIntegrations?: QueueIntegrationsOrderByWithRelationInput
    prompt?: PromptOrderByRelationAggregateInput
    UserQueue?: UserQueueOrderByRelationAggregateInput
    WhatsappQueue?: WhatsappQueueOrderByRelationAggregateInput
    Ticket?: TicketOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
    Company?: CompanyOrderByRelationAggregateInput
  }

  export type QueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    color?: string
    AND?: QueueWhereInput | QueueWhereInput[]
    OR?: QueueWhereInput[]
    NOT?: QueueWhereInput | QueueWhereInput[]
    greetingMessage?: StringFilter<"Queue"> | string
    outOfHoursMessage?: StringFilter<"Queue"> | string
    schedules?: JsonNullableFilter<"Queue">
    createdAt?: DateTimeFilter<"Queue"> | Date | string
    updatedAt?: DateTimeFilter<"Queue"> | Date | string
    companyId?: IntFilter<"Queue"> | number
    orderQueue?: IntFilter<"Queue"> | number
    integrationId?: IntNullableFilter<"Queue"> | number | null
    promptId?: IntNullableFilter<"Queue"> | number | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapps?: WhatsappListRelationFilter
    users?: UserListRelationFilter
    options?: QueueOptionListRelationFilter
    queueIntegrations?: XOR<QueueIntegrationsNullableRelationFilter, QueueIntegrationsWhereInput> | null
    prompt?: PromptListRelationFilter
    UserQueue?: UserQueueListRelationFilter
    WhatsappQueue?: WhatsappQueueListRelationFilter
    Ticket?: TicketListRelationFilter
    Message?: MessageListRelationFilter
    Company?: CompanyListRelationFilter
  }, "id" | "name" | "color">

  export type QueueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    greetingMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    schedules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrderInput | SortOrder
    promptId?: SortOrderInput | SortOrder
    _count?: QueueCountOrderByAggregateInput
    _avg?: QueueAvgOrderByAggregateInput
    _max?: QueueMaxOrderByAggregateInput
    _min?: QueueMinOrderByAggregateInput
    _sum?: QueueSumOrderByAggregateInput
  }

  export type QueueScalarWhereWithAggregatesInput = {
    AND?: QueueScalarWhereWithAggregatesInput | QueueScalarWhereWithAggregatesInput[]
    OR?: QueueScalarWhereWithAggregatesInput[]
    NOT?: QueueScalarWhereWithAggregatesInput | QueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Queue"> | number
    name?: StringWithAggregatesFilter<"Queue"> | string
    color?: StringWithAggregatesFilter<"Queue"> | string
    greetingMessage?: StringWithAggregatesFilter<"Queue"> | string
    outOfHoursMessage?: StringWithAggregatesFilter<"Queue"> | string
    schedules?: JsonNullableWithAggregatesFilter<"Queue">
    createdAt?: DateTimeWithAggregatesFilter<"Queue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Queue"> | Date | string
    companyId?: IntWithAggregatesFilter<"Queue"> | number
    orderQueue?: IntWithAggregatesFilter<"Queue"> | number
    integrationId?: IntNullableWithAggregatesFilter<"Queue"> | number | null
    promptId?: IntNullableWithAggregatesFilter<"Queue"> | number | null
  }

  export type QueueIntegrationsWhereInput = {
    AND?: QueueIntegrationsWhereInput | QueueIntegrationsWhereInput[]
    OR?: QueueIntegrationsWhereInput[]
    NOT?: QueueIntegrationsWhereInput | QueueIntegrationsWhereInput[]
    id?: IntFilter<"QueueIntegrations"> | number
    type?: StringFilter<"QueueIntegrations"> | string
    name?: StringFilter<"QueueIntegrations"> | string
    projectName?: StringFilter<"QueueIntegrations"> | string
    jsonContent?: StringNullableFilter<"QueueIntegrations"> | string | null
    language?: StringNullableFilter<"QueueIntegrations"> | string | null
    urlN8N?: StringNullableFilter<"QueueIntegrations"> | string | null
    companyId?: IntFilter<"QueueIntegrations"> | number
    typebotSlug?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotExpires?: IntNullableFilter<"QueueIntegrations"> | number | null
    typebotKeywordFinish?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotUnknownMessage?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotDelayMessage?: IntNullableFilter<"QueueIntegrations"> | number | null
    typebotKeywordRestart?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotRestartMessage?: StringNullableFilter<"QueueIntegrations"> | string | null
    createdAt?: DateTimeFilter<"QueueIntegrations"> | Date | string
    updatedAt?: DateTimeFilter<"QueueIntegrations"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    Ticket?: TicketListRelationFilter
    Queue?: QueueListRelationFilter
  }

  export type QueueIntegrationsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    projectName?: SortOrder
    jsonContent?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    urlN8N?: SortOrderInput | SortOrder
    companyId?: SortOrder
    typebotSlug?: SortOrderInput | SortOrder
    typebotExpires?: SortOrderInput | SortOrder
    typebotKeywordFinish?: SortOrderInput | SortOrder
    typebotUnknownMessage?: SortOrderInput | SortOrder
    typebotDelayMessage?: SortOrderInput | SortOrder
    typebotKeywordRestart?: SortOrderInput | SortOrder
    typebotRestartMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    Ticket?: TicketOrderByRelationAggregateInput
    Queue?: QueueOrderByRelationAggregateInput
  }

  export type QueueIntegrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_companyId?: QueueIntegrationsNameCompanyIdCompoundUniqueInput
    AND?: QueueIntegrationsWhereInput | QueueIntegrationsWhereInput[]
    OR?: QueueIntegrationsWhereInput[]
    NOT?: QueueIntegrationsWhereInput | QueueIntegrationsWhereInput[]
    type?: StringFilter<"QueueIntegrations"> | string
    name?: StringFilter<"QueueIntegrations"> | string
    projectName?: StringFilter<"QueueIntegrations"> | string
    jsonContent?: StringNullableFilter<"QueueIntegrations"> | string | null
    language?: StringNullableFilter<"QueueIntegrations"> | string | null
    urlN8N?: StringNullableFilter<"QueueIntegrations"> | string | null
    companyId?: IntFilter<"QueueIntegrations"> | number
    typebotSlug?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotExpires?: IntNullableFilter<"QueueIntegrations"> | number | null
    typebotKeywordFinish?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotUnknownMessage?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotDelayMessage?: IntNullableFilter<"QueueIntegrations"> | number | null
    typebotKeywordRestart?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotRestartMessage?: StringNullableFilter<"QueueIntegrations"> | string | null
    createdAt?: DateTimeFilter<"QueueIntegrations"> | Date | string
    updatedAt?: DateTimeFilter<"QueueIntegrations"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    Ticket?: TicketListRelationFilter
    Queue?: QueueListRelationFilter
  }, "id" | "name_companyId">

  export type QueueIntegrationsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    projectName?: SortOrder
    jsonContent?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    urlN8N?: SortOrderInput | SortOrder
    companyId?: SortOrder
    typebotSlug?: SortOrderInput | SortOrder
    typebotExpires?: SortOrderInput | SortOrder
    typebotKeywordFinish?: SortOrderInput | SortOrder
    typebotUnknownMessage?: SortOrderInput | SortOrder
    typebotDelayMessage?: SortOrderInput | SortOrder
    typebotKeywordRestart?: SortOrderInput | SortOrder
    typebotRestartMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QueueIntegrationsCountOrderByAggregateInput
    _avg?: QueueIntegrationsAvgOrderByAggregateInput
    _max?: QueueIntegrationsMaxOrderByAggregateInput
    _min?: QueueIntegrationsMinOrderByAggregateInput
    _sum?: QueueIntegrationsSumOrderByAggregateInput
  }

  export type QueueIntegrationsScalarWhereWithAggregatesInput = {
    AND?: QueueIntegrationsScalarWhereWithAggregatesInput | QueueIntegrationsScalarWhereWithAggregatesInput[]
    OR?: QueueIntegrationsScalarWhereWithAggregatesInput[]
    NOT?: QueueIntegrationsScalarWhereWithAggregatesInput | QueueIntegrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QueueIntegrations"> | number
    type?: StringWithAggregatesFilter<"QueueIntegrations"> | string
    name?: StringWithAggregatesFilter<"QueueIntegrations"> | string
    projectName?: StringWithAggregatesFilter<"QueueIntegrations"> | string
    jsonContent?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    language?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    urlN8N?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    companyId?: IntWithAggregatesFilter<"QueueIntegrations"> | number
    typebotSlug?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    typebotExpires?: IntNullableWithAggregatesFilter<"QueueIntegrations"> | number | null
    typebotKeywordFinish?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    typebotUnknownMessage?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    typebotDelayMessage?: IntNullableWithAggregatesFilter<"QueueIntegrations"> | number | null
    typebotKeywordRestart?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    typebotRestartMessage?: StringNullableWithAggregatesFilter<"QueueIntegrations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QueueIntegrations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QueueIntegrations"> | Date | string
  }

  export type QueueOptionWhereInput = {
    AND?: QueueOptionWhereInput | QueueOptionWhereInput[]
    OR?: QueueOptionWhereInput[]
    NOT?: QueueOptionWhereInput | QueueOptionWhereInput[]
    id?: IntFilter<"QueueOption"> | number
    title?: StringFilter<"QueueOption"> | string
    message?: StringNullableFilter<"QueueOption"> | string | null
    option?: StringNullableFilter<"QueueOption"> | string | null
    queueId?: IntFilter<"QueueOption"> | number
    parentId?: IntNullableFilter<"QueueOption"> | number | null
    createdAt?: DateTimeFilter<"QueueOption"> | Date | string
    updatedAt?: DateTimeFilter<"QueueOption"> | Date | string
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
    parent?: XOR<QueueOptionNullableRelationFilter, QueueOptionWhereInput> | null
    Ticket?: TicketListRelationFilter
    QueueOption?: QueueOptionListRelationFilter
  }

  export type QueueOptionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrderInput | SortOrder
    option?: SortOrderInput | SortOrder
    queueId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    queue?: QueueOrderByWithRelationInput
    parent?: QueueOptionOrderByWithRelationInput
    Ticket?: TicketOrderByRelationAggregateInput
    QueueOption?: QueueOptionOrderByRelationAggregateInput
  }

  export type QueueOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QueueOptionWhereInput | QueueOptionWhereInput[]
    OR?: QueueOptionWhereInput[]
    NOT?: QueueOptionWhereInput | QueueOptionWhereInput[]
    title?: StringFilter<"QueueOption"> | string
    message?: StringNullableFilter<"QueueOption"> | string | null
    option?: StringNullableFilter<"QueueOption"> | string | null
    queueId?: IntFilter<"QueueOption"> | number
    parentId?: IntNullableFilter<"QueueOption"> | number | null
    createdAt?: DateTimeFilter<"QueueOption"> | Date | string
    updatedAt?: DateTimeFilter<"QueueOption"> | Date | string
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
    parent?: XOR<QueueOptionNullableRelationFilter, QueueOptionWhereInput> | null
    Ticket?: TicketListRelationFilter
    QueueOption?: QueueOptionListRelationFilter
  }, "id">

  export type QueueOptionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrderInput | SortOrder
    option?: SortOrderInput | SortOrder
    queueId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QueueOptionCountOrderByAggregateInput
    _avg?: QueueOptionAvgOrderByAggregateInput
    _max?: QueueOptionMaxOrderByAggregateInput
    _min?: QueueOptionMinOrderByAggregateInput
    _sum?: QueueOptionSumOrderByAggregateInput
  }

  export type QueueOptionScalarWhereWithAggregatesInput = {
    AND?: QueueOptionScalarWhereWithAggregatesInput | QueueOptionScalarWhereWithAggregatesInput[]
    OR?: QueueOptionScalarWhereWithAggregatesInput[]
    NOT?: QueueOptionScalarWhereWithAggregatesInput | QueueOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QueueOption"> | number
    title?: StringWithAggregatesFilter<"QueueOption"> | string
    message?: StringNullableWithAggregatesFilter<"QueueOption"> | string | null
    option?: StringNullableWithAggregatesFilter<"QueueOption"> | string | null
    queueId?: IntWithAggregatesFilter<"QueueOption"> | number
    parentId?: IntNullableWithAggregatesFilter<"QueueOption"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"QueueOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QueueOption"> | Date | string
  }

  export type QuickMessageWhereInput = {
    AND?: QuickMessageWhereInput | QuickMessageWhereInput[]
    OR?: QuickMessageWhereInput[]
    NOT?: QuickMessageWhereInput | QuickMessageWhereInput[]
    id?: IntFilter<"QuickMessage"> | number
    shortcode?: StringFilter<"QuickMessage"> | string
    message?: StringFilter<"QuickMessage"> | string
    mediaName?: StringNullableFilter<"QuickMessage"> | string | null
    mediaPath?: StringNullableFilter<"QuickMessage"> | string | null
    companyId?: IntFilter<"QuickMessage"> | number
    userId?: IntFilter<"QuickMessage"> | number
    createdAt?: DateTimeFilter<"QuickMessage"> | Date | string
    updatedAt?: DateTimeFilter<"QuickMessage"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QuickMessageOrderByWithRelationInput = {
    id?: SortOrder
    shortcode?: SortOrder
    message?: SortOrder
    mediaName?: SortOrderInput | SortOrder
    mediaPath?: SortOrderInput | SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type QuickMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuickMessageWhereInput | QuickMessageWhereInput[]
    OR?: QuickMessageWhereInput[]
    NOT?: QuickMessageWhereInput | QuickMessageWhereInput[]
    shortcode?: StringFilter<"QuickMessage"> | string
    message?: StringFilter<"QuickMessage"> | string
    mediaName?: StringNullableFilter<"QuickMessage"> | string | null
    mediaPath?: StringNullableFilter<"QuickMessage"> | string | null
    companyId?: IntFilter<"QuickMessage"> | number
    userId?: IntFilter<"QuickMessage"> | number
    createdAt?: DateTimeFilter<"QuickMessage"> | Date | string
    updatedAt?: DateTimeFilter<"QuickMessage"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type QuickMessageOrderByWithAggregationInput = {
    id?: SortOrder
    shortcode?: SortOrder
    message?: SortOrder
    mediaName?: SortOrderInput | SortOrder
    mediaPath?: SortOrderInput | SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuickMessageCountOrderByAggregateInput
    _avg?: QuickMessageAvgOrderByAggregateInput
    _max?: QuickMessageMaxOrderByAggregateInput
    _min?: QuickMessageMinOrderByAggregateInput
    _sum?: QuickMessageSumOrderByAggregateInput
  }

  export type QuickMessageScalarWhereWithAggregatesInput = {
    AND?: QuickMessageScalarWhereWithAggregatesInput | QuickMessageScalarWhereWithAggregatesInput[]
    OR?: QuickMessageScalarWhereWithAggregatesInput[]
    NOT?: QuickMessageScalarWhereWithAggregatesInput | QuickMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuickMessage"> | number
    shortcode?: StringWithAggregatesFilter<"QuickMessage"> | string
    message?: StringWithAggregatesFilter<"QuickMessage"> | string
    mediaName?: StringNullableWithAggregatesFilter<"QuickMessage"> | string | null
    mediaPath?: StringNullableWithAggregatesFilter<"QuickMessage"> | string | null
    companyId?: IntWithAggregatesFilter<"QuickMessage"> | number
    userId?: IntWithAggregatesFilter<"QuickMessage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuickMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuickMessage"> | Date | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: IntFilter<"Rating"> | number
    name?: StringFilter<"Rating"> | string
    companyId?: IntFilter<"Rating"> | number
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Company?: CompanyOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    name?: StringFilter<"Rating"> | string
    companyId?: IntFilter<"Rating"> | number
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rating"> | number
    name?: StringWithAggregatesFilter<"Rating"> | string
    companyId?: IntWithAggregatesFilter<"Rating"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: IntFilter<"Schedule"> | number
    body?: StringFilter<"Schedule"> | string
    sendAt?: DateTimeFilter<"Schedule"> | Date | string
    sentAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    status?: StringFilter<"Schedule"> | string
    mediaPath?: StringFilter<"Schedule"> | string
    mediaName?: StringFilter<"Schedule"> | string
    contactId?: IntFilter<"Schedule"> | number
    ticketId?: IntFilter<"Schedule"> | number
    userId?: IntFilter<"Schedule"> | number
    companyId?: IntFilter<"Schedule"> | number
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    status?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    body?: StringFilter<"Schedule"> | string
    sendAt?: DateTimeFilter<"Schedule"> | Date | string
    sentAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    status?: StringFilter<"Schedule"> | string
    mediaPath?: StringFilter<"Schedule"> | string
    mediaName?: StringFilter<"Schedule"> | string
    contactId?: IntFilter<"Schedule"> | number
    ticketId?: IntFilter<"Schedule"> | number
    userId?: IntFilter<"Schedule"> | number
    companyId?: IntFilter<"Schedule"> | number
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    status?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Schedule"> | number
    body?: StringWithAggregatesFilter<"Schedule"> | string
    sendAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    status?: StringWithAggregatesFilter<"Schedule"> | string
    mediaPath?: StringWithAggregatesFilter<"Schedule"> | string
    mediaName?: StringWithAggregatesFilter<"Schedule"> | string
    contactId?: IntWithAggregatesFilter<"Schedule"> | number
    ticketId?: IntWithAggregatesFilter<"Schedule"> | number
    userId?: IntWithAggregatesFilter<"Schedule"> | number
    companyId?: IntWithAggregatesFilter<"Schedule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: IntFilter<"Setting"> | number
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
    companyId?: IntFilter<"Setting"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    companyId_key?: SettingCompanyIdKeyCompoundUniqueInput
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
    companyId?: IntFilter<"Setting"> | number
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id" | "companyId_key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _avg?: SettingAvgOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
    _sum?: SettingSumOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Setting"> | number
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    companyId?: IntWithAggregatesFilter<"Setting"> | number
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    isActive?: BoolFilter<"Subscription"> | boolean
    userPriceCents?: IntNullableFilter<"Subscription"> | number | null
    whatsPriceCents?: IntNullableFilter<"Subscription"> | number | null
    lastInvoiceUrl?: StringNullableFilter<"Subscription"> | string | null
    lastPlanChange?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    providerSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    companyId?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    isActive?: SortOrder
    userPriceCents?: SortOrderInput | SortOrder
    whatsPriceCents?: SortOrderInput | SortOrder
    lastInvoiceUrl?: SortOrderInput | SortOrder
    lastPlanChange?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    providerSubscriptionId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    isActive?: BoolFilter<"Subscription"> | boolean
    userPriceCents?: IntNullableFilter<"Subscription"> | number | null
    whatsPriceCents?: IntNullableFilter<"Subscription"> | number | null
    lastInvoiceUrl?: StringNullableFilter<"Subscription"> | string | null
    lastPlanChange?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    providerSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    companyId?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    isActive?: SortOrder
    userPriceCents?: SortOrderInput | SortOrder
    whatsPriceCents?: SortOrderInput | SortOrder
    lastInvoiceUrl?: SortOrderInput | SortOrder
    lastPlanChange?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    providerSubscriptionId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    isActive?: BoolWithAggregatesFilter<"Subscription"> | boolean
    userPriceCents?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    whatsPriceCents?: IntNullableWithAggregatesFilter<"Subscription"> | number | null
    lastInvoiceUrl?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    lastPlanChange?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    providerSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    companyId?: IntWithAggregatesFilter<"Subscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    companyId?: IntFilter<"Tag"> | number
    kanban?: IntFilter<"Tag"> | number
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    ticketTags?: TicketTagListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    ticketTags?: TicketTagOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    companyId?: IntFilter<"Tag"> | number
    kanban?: IntFilter<"Tag"> | number
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    ticketTags?: TicketTagListRelationFilter
    tickets?: TicketListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    companyId?: IntWithAggregatesFilter<"Tag"> | number
    kanban?: IntWithAggregatesFilter<"Tag"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: IntFilter<"Ticket"> | number
    status?: StringFilter<"Ticket"> | string
    unreadMessages?: IntNullableFilter<"Ticket"> | number | null
    lastMessage?: StringNullableFilter<"Ticket"> | string | null
    isGroup?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    userId?: IntFilter<"Ticket"> | number
    contactId?: IntFilter<"Ticket"> | number
    whatsappId?: IntFilter<"Ticket"> | number
    queueId?: IntFilter<"Ticket"> | number
    chatbot?: BoolNullableFilter<"Ticket"> | boolean | null
    queueOptionId?: IntFilter<"Ticket"> | number
    companyId?: IntFilter<"Ticket"> | number
    uuid?: StringFilter<"Ticket"> | string
    useIntegration?: BoolNullableFilter<"Ticket"> | boolean | null
    integrationId?: IntNullableFilter<"Ticket"> | number | null
    typebotSessionId?: StringNullableFilter<"Ticket"> | string | null
    typebotStatus?: BoolFilter<"Ticket"> | boolean
    promptId?: IntNullableFilter<"Ticket"> | number | null
    fromMe?: BoolNullableFilter<"Ticket"> | boolean | null
    amountUsedBotQueues?: IntFilter<"Ticket"> | number
    isBot?: BoolNullableFilter<"Ticket"> | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
    queueOption?: XOR<QueueOptionRelationFilter, QueueOptionWhereInput>
    messages?: MessageListRelationFilter
    ticketTags?: TicketTagListRelationFilter
    tags?: TagListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    queueIntegration?: XOR<QueueIntegrationsNullableRelationFilter, QueueIntegrationsWhereInput> | null
    prompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    UserRating?: UserRatingListRelationFilter
    TicketTracking?: TicketTrackingListRelationFilter
    TicketNote?: TicketNoteListRelationFilter
    Schedule?: ScheduleListRelationFilter
    Action_Logs?: Action_LogsListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    unreadMessages?: SortOrderInput | SortOrder
    lastMessage?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    chatbot?: SortOrderInput | SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    uuid?: SortOrder
    useIntegration?: SortOrderInput | SortOrder
    integrationId?: SortOrderInput | SortOrder
    typebotSessionId?: SortOrderInput | SortOrder
    typebotStatus?: SortOrder
    promptId?: SortOrderInput | SortOrder
    fromMe?: SortOrderInput | SortOrder
    amountUsedBotQueues?: SortOrder
    isBot?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    whatsapp?: WhatsappOrderByWithRelationInput
    queue?: QueueOrderByWithRelationInput
    queueOption?: QueueOptionOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    ticketTags?: TicketTagOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    queueIntegration?: QueueIntegrationsOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    UserRating?: UserRatingOrderByRelationAggregateInput
    TicketTracking?: TicketTrackingOrderByRelationAggregateInput
    TicketNote?: TicketNoteOrderByRelationAggregateInput
    Schedule?: ScheduleOrderByRelationAggregateInput
    Action_Logs?: Action_LogsOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    status?: StringFilter<"Ticket"> | string
    unreadMessages?: IntNullableFilter<"Ticket"> | number | null
    lastMessage?: StringNullableFilter<"Ticket"> | string | null
    isGroup?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    userId?: IntFilter<"Ticket"> | number
    contactId?: IntFilter<"Ticket"> | number
    whatsappId?: IntFilter<"Ticket"> | number
    queueId?: IntFilter<"Ticket"> | number
    chatbot?: BoolNullableFilter<"Ticket"> | boolean | null
    queueOptionId?: IntFilter<"Ticket"> | number
    companyId?: IntFilter<"Ticket"> | number
    uuid?: StringFilter<"Ticket"> | string
    useIntegration?: BoolNullableFilter<"Ticket"> | boolean | null
    integrationId?: IntNullableFilter<"Ticket"> | number | null
    typebotSessionId?: StringNullableFilter<"Ticket"> | string | null
    typebotStatus?: BoolFilter<"Ticket"> | boolean
    promptId?: IntNullableFilter<"Ticket"> | number | null
    fromMe?: BoolNullableFilter<"Ticket"> | boolean | null
    amountUsedBotQueues?: IntFilter<"Ticket"> | number
    isBot?: BoolNullableFilter<"Ticket"> | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
    queueOption?: XOR<QueueOptionRelationFilter, QueueOptionWhereInput>
    messages?: MessageListRelationFilter
    ticketTags?: TicketTagListRelationFilter
    tags?: TagListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    queueIntegration?: XOR<QueueIntegrationsNullableRelationFilter, QueueIntegrationsWhereInput> | null
    prompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    UserRating?: UserRatingListRelationFilter
    TicketTracking?: TicketTrackingListRelationFilter
    TicketNote?: TicketNoteListRelationFilter
    Schedule?: ScheduleListRelationFilter
    Action_Logs?: Action_LogsListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    unreadMessages?: SortOrderInput | SortOrder
    lastMessage?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    chatbot?: SortOrderInput | SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    uuid?: SortOrder
    useIntegration?: SortOrderInput | SortOrder
    integrationId?: SortOrderInput | SortOrder
    typebotSessionId?: SortOrderInput | SortOrder
    typebotStatus?: SortOrder
    promptId?: SortOrderInput | SortOrder
    fromMe?: SortOrderInput | SortOrder
    amountUsedBotQueues?: SortOrder
    isBot?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ticket"> | number
    status?: StringWithAggregatesFilter<"Ticket"> | string
    unreadMessages?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    lastMessage?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    isGroup?: BoolWithAggregatesFilter<"Ticket"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    userId?: IntWithAggregatesFilter<"Ticket"> | number
    contactId?: IntWithAggregatesFilter<"Ticket"> | number
    whatsappId?: IntWithAggregatesFilter<"Ticket"> | number
    queueId?: IntWithAggregatesFilter<"Ticket"> | number
    chatbot?: BoolNullableWithAggregatesFilter<"Ticket"> | boolean | null
    queueOptionId?: IntWithAggregatesFilter<"Ticket"> | number
    companyId?: IntWithAggregatesFilter<"Ticket"> | number
    uuid?: StringWithAggregatesFilter<"Ticket"> | string
    useIntegration?: BoolNullableWithAggregatesFilter<"Ticket"> | boolean | null
    integrationId?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    typebotSessionId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    typebotStatus?: BoolWithAggregatesFilter<"Ticket"> | boolean
    promptId?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    fromMe?: BoolNullableWithAggregatesFilter<"Ticket"> | boolean | null
    amountUsedBotQueues?: IntWithAggregatesFilter<"Ticket"> | number
    isBot?: BoolNullableWithAggregatesFilter<"Ticket"> | boolean | null
  }

  export type TicketNoteWhereInput = {
    AND?: TicketNoteWhereInput | TicketNoteWhereInput[]
    OR?: TicketNoteWhereInput[]
    NOT?: TicketNoteWhereInput | TicketNoteWhereInput[]
    id?: IntFilter<"TicketNote"> | number
    note?: StringFilter<"TicketNote"> | string
    createdAt?: DateTimeFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeFilter<"TicketNote"> | Date | string
    userId?: IntFilter<"TicketNote"> | number
    contactId?: IntFilter<"TicketNote"> | number
    ticketId?: IntFilter<"TicketNote"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }

  export type TicketNoteOrderByWithRelationInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    user?: UserOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketNoteWhereInput | TicketNoteWhereInput[]
    OR?: TicketNoteWhereInput[]
    NOT?: TicketNoteWhereInput | TicketNoteWhereInput[]
    note?: StringFilter<"TicketNote"> | string
    createdAt?: DateTimeFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeFilter<"TicketNote"> | Date | string
    userId?: IntFilter<"TicketNote"> | number
    contactId?: IntFilter<"TicketNote"> | number
    ticketId?: IntFilter<"TicketNote"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    contact?: XOR<ContactRelationFilter, ContactWhereInput>
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketNoteOrderByWithAggregationInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    _count?: TicketNoteCountOrderByAggregateInput
    _avg?: TicketNoteAvgOrderByAggregateInput
    _max?: TicketNoteMaxOrderByAggregateInput
    _min?: TicketNoteMinOrderByAggregateInput
    _sum?: TicketNoteSumOrderByAggregateInput
  }

  export type TicketNoteScalarWhereWithAggregatesInput = {
    AND?: TicketNoteScalarWhereWithAggregatesInput | TicketNoteScalarWhereWithAggregatesInput[]
    OR?: TicketNoteScalarWhereWithAggregatesInput[]
    NOT?: TicketNoteScalarWhereWithAggregatesInput | TicketNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketNote"> | number
    note?: StringWithAggregatesFilter<"TicketNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketNote"> | Date | string
    userId?: IntWithAggregatesFilter<"TicketNote"> | number
    contactId?: IntWithAggregatesFilter<"TicketNote"> | number
    ticketId?: IntWithAggregatesFilter<"TicketNote"> | number
  }

  export type TicketTagWhereInput = {
    AND?: TicketTagWhereInput | TicketTagWhereInput[]
    OR?: TicketTagWhereInput[]
    NOT?: TicketTagWhereInput | TicketTagWhereInput[]
    ticketId?: IntFilter<"TicketTag"> | number
    tagId?: IntFilter<"TicketTag"> | number
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    updatedAt?: DateTimeFilter<"TicketTag"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }

  export type TicketTagOrderByWithRelationInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TicketTagWhereUniqueInput = Prisma.AtLeast<{
    ticketId_tagId?: TicketTagTicketIdTagIdCompoundUniqueInput
    AND?: TicketTagWhereInput | TicketTagWhereInput[]
    OR?: TicketTagWhereInput[]
    NOT?: TicketTagWhereInput | TicketTagWhereInput[]
    ticketId?: IntFilter<"TicketTag"> | number
    tagId?: IntFilter<"TicketTag"> | number
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    updatedAt?: DateTimeFilter<"TicketTag"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    tag?: XOR<TagRelationFilter, TagWhereInput>
  }, "ticketId_tagId">

  export type TicketTagOrderByWithAggregationInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketTagCountOrderByAggregateInput
    _avg?: TicketTagAvgOrderByAggregateInput
    _max?: TicketTagMaxOrderByAggregateInput
    _min?: TicketTagMinOrderByAggregateInput
    _sum?: TicketTagSumOrderByAggregateInput
  }

  export type TicketTagScalarWhereWithAggregatesInput = {
    AND?: TicketTagScalarWhereWithAggregatesInput | TicketTagScalarWhereWithAggregatesInput[]
    OR?: TicketTagScalarWhereWithAggregatesInput[]
    NOT?: TicketTagScalarWhereWithAggregatesInput | TicketTagScalarWhereWithAggregatesInput[]
    ticketId?: IntWithAggregatesFilter<"TicketTag"> | number
    tagId?: IntWithAggregatesFilter<"TicketTag"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TicketTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketTag"> | Date | string
  }

  export type TicketTrackingWhereInput = {
    AND?: TicketTrackingWhereInput | TicketTrackingWhereInput[]
    OR?: TicketTrackingWhereInput[]
    NOT?: TicketTrackingWhereInput | TicketTrackingWhereInput[]
    id?: IntFilter<"TicketTracking"> | number
    ticketId?: IntFilter<"TicketTracking"> | number
    companyId?: IntFilter<"TicketTracking"> | number
    whatsappId?: IntNullableFilter<"TicketTracking"> | number | null
    userId?: IntNullableFilter<"TicketTracking"> | number | null
    rated?: BoolFilter<"TicketTracking"> | boolean
    createdAt?: DateTimeFilter<"TicketTracking"> | Date | string
    updatedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    startedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    queuedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    finishedAt?: DateTimeNullableFilter<"TicketTracking"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"TicketTracking"> | Date | string | null
    ratingAt?: DateTimeFilter<"TicketTracking"> | Date | string
    chatbotAt?: DateTimeFilter<"TicketTracking"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TicketTrackingOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    rated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    queuedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    ratingAt?: SortOrder
    chatbotAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    whatsapp?: WhatsappOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketTrackingWhereInput | TicketTrackingWhereInput[]
    OR?: TicketTrackingWhereInput[]
    NOT?: TicketTrackingWhereInput | TicketTrackingWhereInput[]
    ticketId?: IntFilter<"TicketTracking"> | number
    companyId?: IntFilter<"TicketTracking"> | number
    whatsappId?: IntNullableFilter<"TicketTracking"> | number | null
    userId?: IntNullableFilter<"TicketTracking"> | number | null
    rated?: BoolFilter<"TicketTracking"> | boolean
    createdAt?: DateTimeFilter<"TicketTracking"> | Date | string
    updatedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    startedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    queuedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    finishedAt?: DateTimeNullableFilter<"TicketTracking"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"TicketTracking"> | Date | string | null
    ratingAt?: DateTimeFilter<"TicketTracking"> | Date | string
    chatbotAt?: DateTimeFilter<"TicketTracking"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TicketTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    rated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    queuedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    ratingAt?: SortOrder
    chatbotAt?: SortOrder
    _count?: TicketTrackingCountOrderByAggregateInput
    _avg?: TicketTrackingAvgOrderByAggregateInput
    _max?: TicketTrackingMaxOrderByAggregateInput
    _min?: TicketTrackingMinOrderByAggregateInput
    _sum?: TicketTrackingSumOrderByAggregateInput
  }

  export type TicketTrackingScalarWhereWithAggregatesInput = {
    AND?: TicketTrackingScalarWhereWithAggregatesInput | TicketTrackingScalarWhereWithAggregatesInput[]
    OR?: TicketTrackingScalarWhereWithAggregatesInput[]
    NOT?: TicketTrackingScalarWhereWithAggregatesInput | TicketTrackingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketTracking"> | number
    ticketId?: IntWithAggregatesFilter<"TicketTracking"> | number
    companyId?: IntWithAggregatesFilter<"TicketTracking"> | number
    whatsappId?: IntNullableWithAggregatesFilter<"TicketTracking"> | number | null
    userId?: IntNullableWithAggregatesFilter<"TicketTracking"> | number | null
    rated?: BoolWithAggregatesFilter<"TicketTracking"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketTracking"> | Date | string
    startedAt?: DateTimeWithAggregatesFilter<"TicketTracking"> | Date | string
    queuedAt?: DateTimeWithAggregatesFilter<"TicketTracking"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"TicketTracking"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"TicketTracking"> | Date | string | null
    ratingAt?: DateTimeWithAggregatesFilter<"TicketTracking"> | Date | string
    chatbotAt?: DateTimeWithAggregatesFilter<"TicketTracking"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    tokenVersion?: IntFilter<"User"> | number
    profile?: StringFilter<"User"> | string
    super?: BoolFilter<"User"> | boolean
    online?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companyId?: IntFilter<"User"> | number
    whatsappId?: IntNullableFilter<"User"> | number | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    tickets?: TicketListRelationFilter
    queues?: QueueListRelationFilter
    quickMessages?: QuickMessageListRelationFilter
    ChatUsers?: ChatUserListRelationFilter
    UserQueue?: UserQueueListRelationFilter
    UserRating?: UserRatingListRelationFilter
    TicketTracking?: TicketTrackingListRelationFilter
    TicketNote?: TicketNoteListRelationFilter
    Schedule?: ScheduleListRelationFilter
    ChatMessage?: ChatMessageListRelationFilter
    Chat?: ChatListRelationFilter
    Action_Logs?: Action_LogsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    tokenVersion?: SortOrder
    profile?: SortOrder
    super?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    whatsapp?: WhatsappOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    queues?: QueueOrderByRelationAggregateInput
    quickMessages?: QuickMessageOrderByRelationAggregateInput
    ChatUsers?: ChatUserOrderByRelationAggregateInput
    UserQueue?: UserQueueOrderByRelationAggregateInput
    UserRating?: UserRatingOrderByRelationAggregateInput
    TicketTracking?: TicketTrackingOrderByRelationAggregateInput
    TicketNote?: TicketNoteOrderByRelationAggregateInput
    Schedule?: ScheduleOrderByRelationAggregateInput
    ChatMessage?: ChatMessageOrderByRelationAggregateInput
    Chat?: ChatOrderByRelationAggregateInput
    Action_Logs?: Action_LogsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    tokenVersion?: IntFilter<"User"> | number
    profile?: StringFilter<"User"> | string
    super?: BoolFilter<"User"> | boolean
    online?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companyId?: IntFilter<"User"> | number
    whatsappId?: IntNullableFilter<"User"> | number | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    whatsapp?: XOR<WhatsappNullableRelationFilter, WhatsappWhereInput> | null
    tickets?: TicketListRelationFilter
    queues?: QueueListRelationFilter
    quickMessages?: QuickMessageListRelationFilter
    ChatUsers?: ChatUserListRelationFilter
    UserQueue?: UserQueueListRelationFilter
    UserRating?: UserRatingListRelationFilter
    TicketTracking?: TicketTrackingListRelationFilter
    TicketNote?: TicketNoteListRelationFilter
    Schedule?: ScheduleListRelationFilter
    ChatMessage?: ChatMessageListRelationFilter
    Chat?: ChatListRelationFilter
    Action_Logs?: Action_LogsListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    tokenVersion?: SortOrder
    profile?: SortOrder
    super?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    tokenVersion?: IntWithAggregatesFilter<"User"> | number
    profile?: StringWithAggregatesFilter<"User"> | string
    super?: BoolWithAggregatesFilter<"User"> | boolean
    online?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    companyId?: IntWithAggregatesFilter<"User"> | number
    whatsappId?: IntNullableWithAggregatesFilter<"User"> | number | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserQueueWhereInput = {
    AND?: UserQueueWhereInput | UserQueueWhereInput[]
    OR?: UserQueueWhereInput[]
    NOT?: UserQueueWhereInput | UserQueueWhereInput[]
    userId?: IntFilter<"UserQueue"> | number
    queueId?: IntFilter<"UserQueue"> | number
    createdAt?: DateTimeFilter<"UserQueue"> | Date | string
    updatedAt?: DateTimeFilter<"UserQueue"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
  }

  export type UserQueueOrderByWithRelationInput = {
    userId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    queue?: QueueOrderByWithRelationInput
  }

  export type UserQueueWhereUniqueInput = Prisma.AtLeast<{
    userId_queueId?: UserQueueUserIdQueueIdCompoundUniqueInput
    AND?: UserQueueWhereInput | UserQueueWhereInput[]
    OR?: UserQueueWhereInput[]
    NOT?: UserQueueWhereInput | UserQueueWhereInput[]
    userId?: IntFilter<"UserQueue"> | number
    queueId?: IntFilter<"UserQueue"> | number
    createdAt?: DateTimeFilter<"UserQueue"> | Date | string
    updatedAt?: DateTimeFilter<"UserQueue"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
  }, "userId_queueId">

  export type UserQueueOrderByWithAggregationInput = {
    userId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserQueueCountOrderByAggregateInput
    _avg?: UserQueueAvgOrderByAggregateInput
    _max?: UserQueueMaxOrderByAggregateInput
    _min?: UserQueueMinOrderByAggregateInput
    _sum?: UserQueueSumOrderByAggregateInput
  }

  export type UserQueueScalarWhereWithAggregatesInput = {
    AND?: UserQueueScalarWhereWithAggregatesInput | UserQueueScalarWhereWithAggregatesInput[]
    OR?: UserQueueScalarWhereWithAggregatesInput[]
    NOT?: UserQueueScalarWhereWithAggregatesInput | UserQueueScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserQueue"> | number
    queueId?: IntWithAggregatesFilter<"UserQueue"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserQueue"> | Date | string
  }

  export type UserRatingWhereInput = {
    AND?: UserRatingWhereInput | UserRatingWhereInput[]
    OR?: UserRatingWhereInput[]
    NOT?: UserRatingWhereInput | UserRatingWhereInput[]
    id?: IntFilter<"UserRating"> | number
    ticketId?: IntFilter<"UserRating"> | number
    companyId?: IntFilter<"UserRating"> | number
    userId?: IntFilter<"UserRating"> | number
    rate?: IntFilter<"UserRating"> | number
    createdAt?: DateTimeFilter<"UserRating"> | Date | string
    updatedAt?: DateTimeFilter<"UserRating"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserRatingOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserRatingWhereInput | UserRatingWhereInput[]
    OR?: UserRatingWhereInput[]
    NOT?: UserRatingWhereInput | UserRatingWhereInput[]
    ticketId?: IntFilter<"UserRating"> | number
    companyId?: IntFilter<"UserRating"> | number
    userId?: IntFilter<"UserRating"> | number
    rate?: IntFilter<"UserRating"> | number
    createdAt?: DateTimeFilter<"UserRating"> | Date | string
    updatedAt?: DateTimeFilter<"UserRating"> | Date | string
    ticket?: XOR<TicketRelationFilter, TicketWhereInput>
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserRatingOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserRatingCountOrderByAggregateInput
    _avg?: UserRatingAvgOrderByAggregateInput
    _max?: UserRatingMaxOrderByAggregateInput
    _min?: UserRatingMinOrderByAggregateInput
    _sum?: UserRatingSumOrderByAggregateInput
  }

  export type UserRatingScalarWhereWithAggregatesInput = {
    AND?: UserRatingScalarWhereWithAggregatesInput | UserRatingScalarWhereWithAggregatesInput[]
    OR?: UserRatingScalarWhereWithAggregatesInput[]
    NOT?: UserRatingScalarWhereWithAggregatesInput | UserRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRating"> | number
    ticketId?: IntWithAggregatesFilter<"UserRating"> | number
    companyId?: IntWithAggregatesFilter<"UserRating"> | number
    userId?: IntWithAggregatesFilter<"UserRating"> | number
    rate?: IntWithAggregatesFilter<"UserRating"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserRating"> | Date | string
  }

  export type WhatsappWhereInput = {
    AND?: WhatsappWhereInput | WhatsappWhereInput[]
    OR?: WhatsappWhereInput[]
    NOT?: WhatsappWhereInput | WhatsappWhereInput[]
    id?: IntFilter<"Whatsapp"> | number
    name?: StringNullableFilter<"Whatsapp"> | string | null
    session?: StringNullableFilter<"Whatsapp"> | string | null
    qrcode?: StringNullableFilter<"Whatsapp"> | string | null
    status?: StringNullableFilter<"Whatsapp"> | string | null
    battery?: StringNullableFilter<"Whatsapp"> | string | null
    plugged?: BoolNullableFilter<"Whatsapp"> | boolean | null
    retries?: IntNullableFilter<"Whatsapp"> | number | null
    greetingMessage?: StringFilter<"Whatsapp"> | string
    farewellMessage?: StringFilter<"Whatsapp"> | string
    complationMessage?: StringFilter<"Whatsapp"> | string
    outOfHoursMessage?: StringFilter<"Whatsapp"> | string
    ratingMessage?: StringFilter<"Whatsapp"> | string
    provider?: StringFilter<"Whatsapp"> | string
    isDefault?: BoolNullableFilter<"Whatsapp"> | boolean | null
    token?: StringNullableFilter<"Whatsapp"> | string | null
    transferQueueId?: IntNullableFilter<"Whatsapp"> | number | null
    timeToTransfer?: IntNullableFilter<"Whatsapp"> | number | null
    maxUseBotQueues?: IntNullableFilter<"Whatsapp"> | number | null
    timeUseBotQueues?: StringNullableFilter<"Whatsapp"> | string | null
    sendIdQueue?: IntNullableFilter<"Whatsapp"> | number | null
    timeSendQueue?: IntNullableFilter<"Whatsapp"> | number | null
    integrationId?: IntNullableFilter<"Whatsapp"> | number | null
    expiresTicket?: IntNullableFilter<"Whatsapp"> | number | null
    expiresInactiveMessage?: StringNullableFilter<"Whatsapp"> | string | null
    createdAt?: DateTimeFilter<"Whatsapp"> | Date | string
    updatedAt?: DateTimeFilter<"Whatsapp"> | Date | string
    companyId?: IntFilter<"Whatsapp"> | number
    promptId?: IntNullableFilter<"Whatsapp"> | number | null
    tickets?: TicketListRelationFilter
    queues?: QueueListRelationFilter
    whatsappQueues?: WhatsappQueueListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    prompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    User?: UserListRelationFilter
    TicketTracking?: TicketTrackingListRelationFilter
    Contact?: ContactListRelationFilter
    Campaign?: CampaignListRelationFilter
    BaileysChats?: BaileysChatsListRelationFilter
    Baileys?: BaileysListRelationFilter
  }

  export type WhatsappOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    session?: SortOrderInput | SortOrder
    qrcode?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    battery?: SortOrderInput | SortOrder
    plugged?: SortOrderInput | SortOrder
    retries?: SortOrderInput | SortOrder
    greetingMessage?: SortOrder
    farewellMessage?: SortOrder
    complationMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    ratingMessage?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    transferQueueId?: SortOrderInput | SortOrder
    timeToTransfer?: SortOrderInput | SortOrder
    maxUseBotQueues?: SortOrderInput | SortOrder
    timeUseBotQueues?: SortOrderInput | SortOrder
    sendIdQueue?: SortOrderInput | SortOrder
    timeSendQueue?: SortOrderInput | SortOrder
    integrationId?: SortOrderInput | SortOrder
    expiresTicket?: SortOrderInput | SortOrder
    expiresInactiveMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrderInput | SortOrder
    tickets?: TicketOrderByRelationAggregateInput
    queues?: QueueOrderByRelationAggregateInput
    whatsappQueues?: WhatsappQueueOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
    TicketTracking?: TicketTrackingOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
    Campaign?: CampaignOrderByRelationAggregateInput
    BaileysChats?: BaileysChatsOrderByRelationAggregateInput
    Baileys?: BaileysOrderByRelationAggregateInput
  }

  export type WhatsappWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: WhatsappWhereInput | WhatsappWhereInput[]
    OR?: WhatsappWhereInput[]
    NOT?: WhatsappWhereInput | WhatsappWhereInput[]
    session?: StringNullableFilter<"Whatsapp"> | string | null
    qrcode?: StringNullableFilter<"Whatsapp"> | string | null
    status?: StringNullableFilter<"Whatsapp"> | string | null
    battery?: StringNullableFilter<"Whatsapp"> | string | null
    plugged?: BoolNullableFilter<"Whatsapp"> | boolean | null
    retries?: IntNullableFilter<"Whatsapp"> | number | null
    greetingMessage?: StringFilter<"Whatsapp"> | string
    farewellMessage?: StringFilter<"Whatsapp"> | string
    complationMessage?: StringFilter<"Whatsapp"> | string
    outOfHoursMessage?: StringFilter<"Whatsapp"> | string
    ratingMessage?: StringFilter<"Whatsapp"> | string
    provider?: StringFilter<"Whatsapp"> | string
    isDefault?: BoolNullableFilter<"Whatsapp"> | boolean | null
    token?: StringNullableFilter<"Whatsapp"> | string | null
    transferQueueId?: IntNullableFilter<"Whatsapp"> | number | null
    timeToTransfer?: IntNullableFilter<"Whatsapp"> | number | null
    maxUseBotQueues?: IntNullableFilter<"Whatsapp"> | number | null
    timeUseBotQueues?: StringNullableFilter<"Whatsapp"> | string | null
    sendIdQueue?: IntNullableFilter<"Whatsapp"> | number | null
    timeSendQueue?: IntNullableFilter<"Whatsapp"> | number | null
    integrationId?: IntNullableFilter<"Whatsapp"> | number | null
    expiresTicket?: IntNullableFilter<"Whatsapp"> | number | null
    expiresInactiveMessage?: StringNullableFilter<"Whatsapp"> | string | null
    createdAt?: DateTimeFilter<"Whatsapp"> | Date | string
    updatedAt?: DateTimeFilter<"Whatsapp"> | Date | string
    companyId?: IntFilter<"Whatsapp"> | number
    promptId?: IntNullableFilter<"Whatsapp"> | number | null
    tickets?: TicketListRelationFilter
    queues?: QueueListRelationFilter
    whatsappQueues?: WhatsappQueueListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    prompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    User?: UserListRelationFilter
    TicketTracking?: TicketTrackingListRelationFilter
    Contact?: ContactListRelationFilter
    Campaign?: CampaignListRelationFilter
    BaileysChats?: BaileysChatsListRelationFilter
    Baileys?: BaileysListRelationFilter
  }, "id" | "name">

  export type WhatsappOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    session?: SortOrderInput | SortOrder
    qrcode?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    battery?: SortOrderInput | SortOrder
    plugged?: SortOrderInput | SortOrder
    retries?: SortOrderInput | SortOrder
    greetingMessage?: SortOrder
    farewellMessage?: SortOrder
    complationMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    ratingMessage?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    transferQueueId?: SortOrderInput | SortOrder
    timeToTransfer?: SortOrderInput | SortOrder
    maxUseBotQueues?: SortOrderInput | SortOrder
    timeUseBotQueues?: SortOrderInput | SortOrder
    sendIdQueue?: SortOrderInput | SortOrder
    timeSendQueue?: SortOrderInput | SortOrder
    integrationId?: SortOrderInput | SortOrder
    expiresTicket?: SortOrderInput | SortOrder
    expiresInactiveMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrderInput | SortOrder
    _count?: WhatsappCountOrderByAggregateInput
    _avg?: WhatsappAvgOrderByAggregateInput
    _max?: WhatsappMaxOrderByAggregateInput
    _min?: WhatsappMinOrderByAggregateInput
    _sum?: WhatsappSumOrderByAggregateInput
  }

  export type WhatsappScalarWhereWithAggregatesInput = {
    AND?: WhatsappScalarWhereWithAggregatesInput | WhatsappScalarWhereWithAggregatesInput[]
    OR?: WhatsappScalarWhereWithAggregatesInput[]
    NOT?: WhatsappScalarWhereWithAggregatesInput | WhatsappScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Whatsapp"> | number
    name?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    session?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    qrcode?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    status?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    battery?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    plugged?: BoolNullableWithAggregatesFilter<"Whatsapp"> | boolean | null
    retries?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    greetingMessage?: StringWithAggregatesFilter<"Whatsapp"> | string
    farewellMessage?: StringWithAggregatesFilter<"Whatsapp"> | string
    complationMessage?: StringWithAggregatesFilter<"Whatsapp"> | string
    outOfHoursMessage?: StringWithAggregatesFilter<"Whatsapp"> | string
    ratingMessage?: StringWithAggregatesFilter<"Whatsapp"> | string
    provider?: StringWithAggregatesFilter<"Whatsapp"> | string
    isDefault?: BoolNullableWithAggregatesFilter<"Whatsapp"> | boolean | null
    token?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    transferQueueId?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    timeToTransfer?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    maxUseBotQueues?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    timeUseBotQueues?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    sendIdQueue?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    timeSendQueue?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    integrationId?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    expiresTicket?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
    expiresInactiveMessage?: StringNullableWithAggregatesFilter<"Whatsapp"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Whatsapp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Whatsapp"> | Date | string
    companyId?: IntWithAggregatesFilter<"Whatsapp"> | number
    promptId?: IntNullableWithAggregatesFilter<"Whatsapp"> | number | null
  }

  export type WhatsappQueueWhereInput = {
    AND?: WhatsappQueueWhereInput | WhatsappQueueWhereInput[]
    OR?: WhatsappQueueWhereInput[]
    NOT?: WhatsappQueueWhereInput | WhatsappQueueWhereInput[]
    whatsappId?: IntFilter<"WhatsappQueue"> | number
    queueId?: IntFilter<"WhatsappQueue"> | number
    createdAt?: DateTimeFilter<"WhatsappQueue"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappQueue"> | Date | string
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
  }

  export type WhatsappQueueOrderByWithRelationInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsapp?: WhatsappOrderByWithRelationInput
    queue?: QueueOrderByWithRelationInput
  }

  export type WhatsappQueueWhereUniqueInput = Prisma.AtLeast<{
    whatsappId_queueId?: WhatsappQueueWhatsappIdQueueIdCompoundUniqueInput
    AND?: WhatsappQueueWhereInput | WhatsappQueueWhereInput[]
    OR?: WhatsappQueueWhereInput[]
    NOT?: WhatsappQueueWhereInput | WhatsappQueueWhereInput[]
    whatsappId?: IntFilter<"WhatsappQueue"> | number
    queueId?: IntFilter<"WhatsappQueue"> | number
    createdAt?: DateTimeFilter<"WhatsappQueue"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappQueue"> | Date | string
    whatsapp?: XOR<WhatsappRelationFilter, WhatsappWhereInput>
    queue?: XOR<QueueRelationFilter, QueueWhereInput>
  }, "whatsappId_queueId">

  export type WhatsappQueueOrderByWithAggregationInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsappQueueCountOrderByAggregateInput
    _avg?: WhatsappQueueAvgOrderByAggregateInput
    _max?: WhatsappQueueMaxOrderByAggregateInput
    _min?: WhatsappQueueMinOrderByAggregateInput
    _sum?: WhatsappQueueSumOrderByAggregateInput
  }

  export type WhatsappQueueScalarWhereWithAggregatesInput = {
    AND?: WhatsappQueueScalarWhereWithAggregatesInput | WhatsappQueueScalarWhereWithAggregatesInput[]
    OR?: WhatsappQueueScalarWhereWithAggregatesInput[]
    NOT?: WhatsappQueueScalarWhereWithAggregatesInput | WhatsappQueueScalarWhereWithAggregatesInput[]
    whatsappId?: IntWithAggregatesFilter<"WhatsappQueue"> | number
    queueId?: IntWithAggregatesFilter<"WhatsappQueue"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WhatsappQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsappQueue"> | Date | string
  }

  export type AnnouncementCreateInput = {
    priority: number
    title: string
    text: string
    mediaPath?: string | null
    mediaName?: string | null
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: number
    priority: number
    title: string
    text: string
    mediaPath?: string | null
    mediaName?: string | null
    companyId: number
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: number
    priority: number
    title: string
    text: string
    mediaPath?: string | null
    mediaName?: string | null
    companyId: number
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysCreateInput = {
    contacts?: string | null
    chats?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsapp: WhatsappCreateNestedOneWithoutBaileysInput
  }

  export type BaileysUncheckedCreateInput = {
    id?: number
    contacts?: string | null
    chats?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId: number
  }

  export type BaileysUpdateInput = {
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsapp?: WhatsappUpdateOneRequiredWithoutBaileysNestedInput
  }

  export type BaileysUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: IntFieldUpdateOperationsInput | number
  }

  export type BaileysCreateManyInput = {
    id?: number
    contacts?: string | null
    chats?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId: number
  }

  export type BaileysUpdateManyMutationInput = {
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: IntFieldUpdateOperationsInput | number
  }

  export type BaileysChatsCreateInput = {
    jid: string
    conversationTimestamp: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsapp: WhatsappCreateNestedOneWithoutBaileysChatsInput
  }

  export type BaileysChatsUncheckedCreateInput = {
    id?: number
    jid: string
    conversationTimestamp: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId: number
  }

  export type BaileysChatsUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsapp?: WhatsappUpdateOneRequiredWithoutBaileysChatsNestedInput
  }

  export type BaileysChatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: IntFieldUpdateOperationsInput | number
  }

  export type BaileysChatsCreateManyInput = {
    id?: number
    jid: string
    conversationTimestamp: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId: number
  }

  export type BaileysChatsUpdateManyMutationInput = {
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysChatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignCreateInput = {
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCampaignsInput
    contactList?: ContactListCreateNestedOneWithoutCampaignInput
    whatsapp?: WhatsappCreateNestedOneWithoutCampaignInput
    fileList: FilesCreateNestedOneWithoutCampaignInput
    shipping?: CampaignShippingCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    whatsappId?: number | null
    fileListId: number
    shipping?: CampaignShippingUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCampaignsNestedInput
    contactList?: ContactListUpdateOneWithoutCampaignNestedInput
    whatsapp?: WhatsappUpdateOneWithoutCampaignNestedInput
    fileList?: FilesUpdateOneRequiredWithoutCampaignNestedInput
    shipping?: CampaignShippingUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
    shipping?: CampaignShippingUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    whatsappId?: number | null
    fileListId: number
  }

  export type CampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignSettingCreateInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCampaignSettingsInput
  }

  export type CampaignSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type CampaignSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCampaignSettingsNestedInput
  }

  export type CampaignSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignSettingCreateManyInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type CampaignSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignShippingCreateInput = {
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactListItemCreateNestedOneWithoutCampaignShippingInput
    campaign: CampaignCreateNestedOneWithoutShippingInput
  }

  export type CampaignShippingUncheckedCreateInput = {
    id?: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    contactId: number
    campaignId: number
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignShippingUpdateInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactListItemUpdateOneRequiredWithoutCampaignShippingNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutShippingNestedInput
  }

  export type CampaignShippingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    contactId?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignShippingCreateManyInput = {
    id?: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    contactId: number
    campaignId: number
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignShippingUpdateManyMutationInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignShippingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    contactId?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    uuid?: string
    title?: string
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutChatsInput
    owner: UserCreateNestedOneWithoutChatInput
    users?: ChatUserCreateNestedManyWithoutChatInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: number
    uuid?: string
    title?: string
    ownerId: number
    lastMessage?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: ChatUserUncheckedCreateNestedManyWithoutChatInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
    owner?: UserUpdateOneRequiredWithoutChatNestedInput
    users?: ChatUserUpdateManyWithoutChatNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    lastMessage?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: ChatUserUncheckedUpdateManyWithoutChatNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: number
    uuid?: string
    title?: string
    ownerId: number
    lastMessage?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    lastMessage?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutChatMessageInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: number
    chatId: number
    senderId: number
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutChatMessageNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: number
    chatId: number
    senderId: number
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserCreateInput = {
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutChatUsersInput
  }

  export type ChatUserUncheckedCreateInput = {
    id?: number
    chatId: number
    userId: number
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUserUpdateInput = {
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutChatUsersNestedInput
  }

  export type ChatUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserCreateManyInput = {
    id?: number
    chatId: number
    userId: number
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUserUpdateManyMutationInput = {
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
  }

  export type ContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContactCustomFieldCreateInput = {
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutExtraInfoInput
  }

  export type ContactCustomFieldUncheckedCreateInput = {
    id?: number
    name: string
    value: string
    contactId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCustomFieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutExtraInfoNestedInput
  }

  export type ContactCustomFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCustomFieldCreateManyInput = {
    id?: number
    name: string
    value: string
    contactId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCustomFieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCustomFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactListCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactListsInput
    items?: ContactListItemCreateNestedManyWithoutContactListInput
    Campaign?: CampaignCreateNestedManyWithoutContactListInput
  }

  export type ContactListUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    items?: ContactListItemUncheckedCreateNestedManyWithoutContactListInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutContactListInput
  }

  export type ContactListUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactListsNestedInput
    items?: ContactListItemUpdateManyWithoutContactListNestedInput
    Campaign?: CampaignUpdateManyWithoutContactListNestedInput
  }

  export type ContactListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    items?: ContactListItemUncheckedUpdateManyWithoutContactListNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutContactListNestedInput
  }

  export type ContactListCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type ContactListUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactListItemCreateInput = {
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactListItemsInput
    contactList: ContactListCreateNestedOneWithoutItemsInput
    CampaignShipping?: CampaignShippingCreateNestedManyWithoutContactInput
  }

  export type ContactListItemUncheckedCreateInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId: number
    CampaignShipping?: CampaignShippingUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactListItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactListItemsNestedInput
    contactList?: ContactListUpdateOneRequiredWithoutItemsNestedInput
    CampaignShipping?: CampaignShippingUpdateManyWithoutContactNestedInput
  }

  export type ContactListItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: IntFieldUpdateOperationsInput | number
    CampaignShipping?: CampaignShippingUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactListItemCreateManyInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId: number
  }

  export type ContactListItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactListItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: IntFieldUpdateOperationsInput | number
  }

  export type FilesCreateInput = {
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFilessInput
    options?: FilesOptionsCreateNestedManyWithoutFileInput
    Campaign?: CampaignCreateNestedManyWithoutFileListInput
  }

  export type FilesUncheckedCreateInput = {
    id?: number
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    options?: FilesOptionsUncheckedCreateNestedManyWithoutFileInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutFileListInput
  }

  export type FilesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFilessNestedInput
    options?: FilesOptionsUpdateManyWithoutFileNestedInput
    Campaign?: CampaignUpdateManyWithoutFileListNestedInput
  }

  export type FilesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    options?: FilesOptionsUncheckedUpdateManyWithoutFileNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutFileListNestedInput
  }

  export type FilesCreateManyInput = {
    id?: number
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type FilesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type FilesOptionsCreateInput = {
    name: string
    path: string
    mediaType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    file: FilesCreateNestedOneWithoutOptionsInput
  }

  export type FilesOptionsUncheckedCreateInput = {
    id?: number
    name: string
    path: string
    mediaType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fileId: number
  }

  export type FilesOptionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FilesUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type FilesOptionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileId?: IntFieldUpdateOperationsInput | number
  }

  export type FilesOptionsCreateManyInput = {
    id?: number
    name: string
    path: string
    mediaType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fileId: number
  }

  export type FilesOptionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesOptionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileId?: IntFieldUpdateOperationsInput | number
  }

  export type HelpCreateInput = {
    title: string
    description: string
    video: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    video: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCreateManyInput = {
    id?: number
    title: string
    description: string
    video: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    detail: string
    status: string
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate: string
    companyId: number
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    detail: string
    status: string
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate: string
    companyId: number
  }

  export type InvoiceUpdateInput = {
    detail?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateManyInput = {
    id?: number
    detail: string
    status: string
    value: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dueDate: string
    companyId: number
  }

  export type InvoiceUpdateManyMutationInput = {
    detail?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type System_LogsCreateInput = {
    level: string
    message: string
    createdAt?: Date | string
    actionLog?: Action_LogsCreateNestedOneWithoutSystem_LogsInput
  }

  export type System_LogsUncheckedCreateInput = {
    id?: number
    level: string
    message: string
    createdAt?: Date | string
    actionLogId?: number | null
  }

  export type System_LogsUpdateInput = {
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionLog?: Action_LogsUpdateOneWithoutSystem_LogsNestedInput
  }

  export type System_LogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionLogId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type System_LogsCreateManyInput = {
    id?: number
    level: string
    message: string
    createdAt?: Date | string
    actionLogId?: number | null
  }

  export type System_LogsUpdateManyMutationInput = {
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type System_LogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actionLogId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Action_LogsCreateInput = {
    action: string
    message?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAction_LogsInput
    ticket?: TicketCreateNestedOneWithoutAction_LogsInput
    System_Logs?: System_LogsCreateNestedManyWithoutActionLogInput
  }

  export type Action_LogsUncheckedCreateInput = {
    id?: number
    userId: number
    ticketId?: number | null
    action: string
    message?: string | null
    createdAt?: Date | string
    System_Logs?: System_LogsUncheckedCreateNestedManyWithoutActionLogInput
  }

  export type Action_LogsUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAction_LogsNestedInput
    ticket?: TicketUpdateOneWithoutAction_LogsNestedInput
    System_Logs?: System_LogsUpdateManyWithoutActionLogNestedInput
  }

  export type Action_LogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    System_Logs?: System_LogsUncheckedUpdateManyWithoutActionLogNestedInput
  }

  export type Action_LogsCreateManyInput = {
    id?: number
    userId: number
    ticketId?: number | null
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type Action_LogsUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Action_LogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsg?: MessageCreateNestedOneWithoutMessageInput
    ticket?: TicketCreateNestedOneWithoutMessagesInput
    contact?: ContactCreateNestedOneWithoutMessageInput
    company: CompanyCreateNestedOneWithoutMessagesInput
    queue?: QueueCreateNestedOneWithoutMessageInput
    Message?: MessageCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
    Message?: MessageUncheckedCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsg?: MessageUpdateOneWithoutMessageNestedInput
    ticket?: TicketUpdateOneWithoutMessagesNestedInput
    contact?: ContactUpdateOneWithoutMessageNestedInput
    company?: CompanyUpdateOneRequiredWithoutMessagesNestedInput
    queue?: QueueUpdateOneWithoutMessageNestedInput
    Message?: MessageUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    Message?: MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PlanCreateInput = {
    name: string
    users?: number | null
    connections?: number | null
    queues?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    useSchedules: boolean
    useCampaigns: boolean
    useInternalChat: boolean
    useExternalApi: boolean
    useKanban: boolean
    useOpenAi: boolean
    useIntegrations: boolean
    Company?: CompanyCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: number
    name: string
    users?: number | null
    connections?: number | null
    queues?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    useSchedules: boolean
    useCampaigns: boolean
    useInternalChat: boolean
    useExternalApi: boolean
    useKanban: boolean
    useOpenAi: boolean
    useIntegrations: boolean
    Company?: CompanyUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: NullableIntFieldUpdateOperationsInput | number | null
    connections?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useSchedules?: BoolFieldUpdateOperationsInput | boolean
    useCampaigns?: BoolFieldUpdateOperationsInput | boolean
    useInternalChat?: BoolFieldUpdateOperationsInput | boolean
    useExternalApi?: BoolFieldUpdateOperationsInput | boolean
    useKanban?: BoolFieldUpdateOperationsInput | boolean
    useOpenAi?: BoolFieldUpdateOperationsInput | boolean
    useIntegrations?: BoolFieldUpdateOperationsInput | boolean
    Company?: CompanyUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: NullableIntFieldUpdateOperationsInput | number | null
    connections?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useSchedules?: BoolFieldUpdateOperationsInput | boolean
    useCampaigns?: BoolFieldUpdateOperationsInput | boolean
    useInternalChat?: BoolFieldUpdateOperationsInput | boolean
    useExternalApi?: BoolFieldUpdateOperationsInput | boolean
    useKanban?: BoolFieldUpdateOperationsInput | boolean
    useOpenAi?: BoolFieldUpdateOperationsInput | boolean
    useIntegrations?: BoolFieldUpdateOperationsInput | boolean
    Company?: CompanyUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: number
    name: string
    users?: number | null
    connections?: number | null
    queues?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    useSchedules: boolean
    useCampaigns: boolean
    useInternalChat: boolean
    useExternalApi: boolean
    useKanban: boolean
    useOpenAi: boolean
    useIntegrations: boolean
  }

  export type PlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: NullableIntFieldUpdateOperationsInput | number | null
    connections?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useSchedules?: BoolFieldUpdateOperationsInput | boolean
    useCampaigns?: BoolFieldUpdateOperationsInput | boolean
    useInternalChat?: BoolFieldUpdateOperationsInput | boolean
    useExternalApi?: BoolFieldUpdateOperationsInput | boolean
    useKanban?: BoolFieldUpdateOperationsInput | boolean
    useOpenAi?: BoolFieldUpdateOperationsInput | boolean
    useIntegrations?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: NullableIntFieldUpdateOperationsInput | number | null
    connections?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useSchedules?: BoolFieldUpdateOperationsInput | boolean
    useCampaigns?: BoolFieldUpdateOperationsInput | boolean
    useInternalChat?: BoolFieldUpdateOperationsInput | boolean
    useExternalApi?: BoolFieldUpdateOperationsInput | boolean
    useKanban?: BoolFieldUpdateOperationsInput | boolean
    useOpenAi?: BoolFieldUpdateOperationsInput | boolean
    useIntegrations?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromptCreateInput = {
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue?: QueueCreateNestedOneWithoutPromptInput
    company: CompanyCreateNestedOneWithoutPromptsInput
    Whatsapp?: WhatsappCreateNestedManyWithoutPromptInput
    Ticket?: TicketCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    queueId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Whatsapp?: WhatsappUncheckedCreateNestedManyWithoutPromptInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneWithoutPromptNestedInput
    company?: CompanyUpdateOneRequiredWithoutPromptsNestedInput
    Whatsapp?: WhatsappUpdateManyWithoutPromptNestedInput
    Ticket?: TicketUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Whatsapp?: WhatsappUncheckedUpdateManyWithoutPromptNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptCreateManyInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    queueId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueCreateInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueCreateManyInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
  }

  export type QueueUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QueueIntegrationsCreateInput = {
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutQueueIntegrationssInput
    Ticket?: TicketCreateNestedManyWithoutQueueIntegrationInput
    Queue?: QueueCreateNestedManyWithoutQueueIntegrationsInput
  }

  export type QueueIntegrationsUncheckedCreateInput = {
    id?: number
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    companyId: number
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueIntegrationInput
    Queue?: QueueUncheckedCreateNestedManyWithoutQueueIntegrationsInput
  }

  export type QueueIntegrationsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutQueueIntegrationssNestedInput
    Ticket?: TicketUpdateManyWithoutQueueIntegrationNestedInput
    Queue?: QueueUpdateManyWithoutQueueIntegrationsNestedInput
  }

  export type QueueIntegrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueIntegrationNestedInput
    Queue?: QueueUncheckedUpdateManyWithoutQueueIntegrationsNestedInput
  }

  export type QueueIntegrationsCreateManyInput = {
    id?: number
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    companyId: number
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueueIntegrationsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueIntegrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueOptionCreateInput = {
    title: string
    message?: string | null
    option?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: QueueCreateNestedOneWithoutOptionsInput
    parent?: QueueOptionCreateNestedOneWithoutQueueOptionInput
    Ticket?: TicketCreateNestedManyWithoutQueueOptionInput
    QueueOption?: QueueOptionCreateNestedManyWithoutParentInput
  }

  export type QueueOptionUncheckedCreateInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    queueId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueOptionInput
    QueueOption?: QueueOptionUncheckedCreateNestedManyWithoutParentInput
  }

  export type QueueOptionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutOptionsNestedInput
    parent?: QueueOptionUpdateOneWithoutQueueOptionNestedInput
    Ticket?: TicketUpdateManyWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionCreateManyInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    queueId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueueOptionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickMessageCreateInput = {
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutQuickMessagesInput
    user: UserCreateNestedOneWithoutQuickMessagesInput
  }

  export type QuickMessageUncheckedCreateInput = {
    id?: number
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    companyId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickMessageUpdateInput = {
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutQuickMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutQuickMessagesNestedInput
  }

  export type QuickMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickMessageCreateManyInput = {
    id?: number
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    companyId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickMessageUpdateManyMutationInput = {
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Company: CompanyCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: number
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: number
    name: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutSchedulesInput
    ticket: TicketCreateNestedOneWithoutScheduleInput
    user: UserCreateNestedOneWithoutScheduleInput
    company: CompanyCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    userId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutSchedulesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutScheduleNestedInput
    user?: UserUpdateOneRequiredWithoutScheduleNestedInput
    company?: CompanyUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    userId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSettingsInput
  }

  export type SettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type SettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type SettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type SettingCreateManyInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type SettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriptionCreateInput = {
    isActive: boolean
    userPriceCents?: number | null
    whatsPriceCents?: number | null
    lastInvoiceUrl?: string | null
    lastPlanChange?: Date | string | null
    expiresAt?: Date | string | null
    providerSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    isActive: boolean
    userPriceCents?: number | null
    whatsPriceCents?: number | null
    lastInvoiceUrl?: string | null
    lastPlanChange?: Date | string | null
    expiresAt?: Date | string | null
    providerSubscriptionId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    isActive: boolean
    userPriceCents?: number | null
    whatsPriceCents?: number | null
    lastInvoiceUrl?: string | null
    lastPlanChange?: Date | string | null
    expiresAt?: Date | string | null
    providerSubscriptionId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    name: string
    color: string
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTagsInput
    ticketTags?: TicketTagCreateNestedManyWithoutTagInput
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    companyId: number
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTagInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTagsNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTagNestedInput
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTagNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    color: string
    companyId: number
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type TicketUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketNoteCreateInput = {
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketNoteInput
    contact: ContactCreateNestedOneWithoutTicketNoteInput
    ticket: TicketCreateNestedOneWithoutTicketNoteInput
  }

  export type TicketNoteUncheckedCreateInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    ticketId: number
  }

  export type TicketNoteUpdateInput = {
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketNoteNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketNoteNestedInput
    ticket?: TicketUpdateOneRequiredWithoutTicketNoteNestedInput
  }

  export type TicketNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketNoteCreateManyInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    ticketId: number
  }

  export type TicketNoteUpdateManyMutationInput = {
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketTagCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutTicketTagsInput
    tag: TagCreateNestedOneWithoutTicketTagsInput
  }

  export type TicketTagUncheckedCreateInput = {
    ticketId: number
    tagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicketTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTicketTagsNestedInput
  }

  export type TicketTagUncheckedUpdateInput = {
    ticketId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagCreateManyInput = {
    ticketId: number
    tagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyInput = {
    ticketId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingCreateInput = {
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
    ticket: TicketCreateNestedOneWithoutTicketTrackingInput
    company: CompanyCreateNestedOneWithoutTicketTrackingsInput
    whatsapp?: WhatsappCreateNestedOneWithoutTicketTrackingInput
    user?: UserCreateNestedOneWithoutTicketTrackingInput
  }

  export type TicketTrackingUncheckedCreateInput = {
    id?: number
    ticketId: number
    companyId: number
    whatsappId?: number | null
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketTrackingUpdateInput = {
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicketTrackingNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketTrackingsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutTicketTrackingNestedInput
    user?: UserUpdateOneWithoutTicketTrackingNestedInput
  }

  export type TicketTrackingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingCreateManyInput = {
    id?: number
    ticketId: number
    companyId: number
    whatsappId?: number | null
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketTrackingUpdateManyMutationInput = {
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserQueueCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserQueueInput
    queue: QueueCreateNestedOneWithoutUserQueueInput
  }

  export type UserQueueUncheckedCreateInput = {
    userId: number
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQueueUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserQueueNestedInput
    queue?: QueueUpdateOneRequiredWithoutUserQueueNestedInput
  }

  export type UserQueueUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQueueCreateManyInput = {
    userId: number
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQueueUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQueueUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingCreateInput = {
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutUserRatingInput
    company: CompanyCreateNestedOneWithoutUserRatingsInput
    user: UserCreateNestedOneWithoutUserRatingInput
  }

  export type UserRatingUncheckedCreateInput = {
    id?: number
    ticketId: number
    companyId: number
    userId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingUpdateInput = {
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutUserRatingNestedInput
    company?: CompanyUpdateOneRequiredWithoutUserRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutUserRatingNestedInput
  }

  export type UserRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingCreateManyInput = {
    id?: number
    ticketId: number
    companyId: number
    userId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingUpdateManyMutationInput = {
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappCreateInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappCreateManyInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
  }

  export type WhatsappUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhatsappQueueCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsapp: WhatsappCreateNestedOneWithoutWhatsappQueuesInput
    queue: QueueCreateNestedOneWithoutWhatsappQueueInput
  }

  export type WhatsappQueueUncheckedCreateInput = {
    whatsappId: number
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappQueueUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsapp?: WhatsappUpdateOneRequiredWithoutWhatsappQueuesNestedInput
    queue?: QueueUpdateOneRequiredWithoutWhatsappQueueNestedInput
  }

  export type WhatsappQueueUncheckedUpdateInput = {
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappQueueCreateManyInput = {
    whatsappId: number
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappQueueUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappQueueUncheckedUpdateManyInput = {
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    text?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    companyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    companyId?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    text?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    companyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    text?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    companyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementSumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    companyId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WhatsappRelationFilter = {
    is?: WhatsappWhereInput
    isNot?: WhatsappWhereInput
  }

  export type BaileysCountOrderByAggregateInput = {
    id?: SortOrder
    contacts?: SortOrder
    chats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysAvgOrderByAggregateInput = {
    id?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysMaxOrderByAggregateInput = {
    id?: SortOrder
    contacts?: SortOrder
    chats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysMinOrderByAggregateInput = {
    id?: SortOrder
    contacts?: SortOrder
    chats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysSumOrderByAggregateInput = {
    id?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysChatsCountOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysChatsAvgOrderByAggregateInput = {
    id?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysChatsMaxOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysChatsMinOrderByAggregateInput = {
    id?: SortOrder
    jid?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappId?: SortOrder
  }

  export type BaileysChatsSumOrderByAggregateInput = {
    id?: SortOrder
    conversationTimestamp?: SortOrder
    unreadCount?: SortOrder
    whatsappId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContactListNullableRelationFilter = {
    is?: ContactListWhereInput | null
    isNot?: ContactListWhereInput | null
  }

  export type WhatsappNullableRelationFilter = {
    is?: WhatsappWhereInput | null
    isNot?: WhatsappWhereInput | null
  }

  export type FilesRelationFilter = {
    is?: FilesWhereInput
    isNot?: FilesWhereInput
  }

  export type CampaignShippingListRelationFilter = {
    every?: CampaignShippingWhereInput
    some?: CampaignShippingWhereInput
    none?: CampaignShippingWhereInput
  }

  export type CampaignShippingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message1?: SortOrder
    message2?: SortOrder
    message3?: SortOrder
    message4?: SortOrder
    message5?: SortOrder
    confirmationMessage1?: SortOrder
    confirmationMessage2?: SortOrder
    confirmationMessage3?: SortOrder
    confirmationMessage4?: SortOrder
    confirmationMessage5?: SortOrder
    status?: SortOrder
    confirmation?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    whatsappId?: SortOrder
    fileListId?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    whatsappId?: SortOrder
    fileListId?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message1?: SortOrder
    message2?: SortOrder
    message3?: SortOrder
    message4?: SortOrder
    message5?: SortOrder
    confirmationMessage1?: SortOrder
    confirmationMessage2?: SortOrder
    confirmationMessage3?: SortOrder
    confirmationMessage4?: SortOrder
    confirmationMessage5?: SortOrder
    status?: SortOrder
    confirmation?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    whatsappId?: SortOrder
    fileListId?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message1?: SortOrder
    message2?: SortOrder
    message3?: SortOrder
    message4?: SortOrder
    message5?: SortOrder
    confirmationMessage1?: SortOrder
    confirmationMessage2?: SortOrder
    confirmationMessage3?: SortOrder
    confirmationMessage4?: SortOrder
    confirmationMessage5?: SortOrder
    status?: SortOrder
    confirmation?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    whatsappId?: SortOrder
    fileListId?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
    whatsappId?: SortOrder
    fileListId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CampaignSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CampaignSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type CampaignSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CampaignSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type CampaignSettingSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ContactListItemRelationFilter = {
    is?: ContactListItemWhereInput
    isNot?: ContactListItemWhereInput
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignShippingContactIdCampaignIdCompoundUniqueInput = {
    contactId: number
    campaignId: number
  }

  export type CampaignShippingCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    number?: SortOrder
    message?: SortOrder
    confirmationMessage?: SortOrder
    confirmation?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
    confirmationRequestedAt?: SortOrder
    confirmedAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignShippingAvgOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
  }

  export type CampaignShippingMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    number?: SortOrder
    message?: SortOrder
    confirmationMessage?: SortOrder
    confirmation?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
    confirmationRequestedAt?: SortOrder
    confirmedAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignShippingMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    number?: SortOrder
    message?: SortOrder
    confirmationMessage?: SortOrder
    confirmation?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
    confirmationRequestedAt?: SortOrder
    confirmedAt?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignShippingSumOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    campaignId?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ChatUserListRelationFilter = {
    every?: ChatUserWhereInput
    some?: ChatUserWhereInput
    none?: ChatUserWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    ownerId?: SortOrder
    lastMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    ownerId?: SortOrder
    lastMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    ownerId?: SortOrder
    lastMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    companyId?: SortOrder
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
  }

  export type ChatUserCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatUserAvgOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
  }

  export type ChatUserMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatUserMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatUserSumOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    unreads?: SortOrder
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserRatingListRelationFilter = {
    every?: UserRatingWhereInput
    some?: UserRatingWhereInput
    none?: UserRatingWhereInput
  }

  export type QueueListRelationFilter = {
    every?: QueueWhereInput
    some?: QueueWhereInput
    none?: QueueWhereInput
  }

  export type WhatsappListRelationFilter = {
    every?: WhatsappWhereInput
    some?: WhatsappWhereInput
    none?: WhatsappWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type SettingListRelationFilter = {
    every?: SettingWhereInput
    some?: SettingWhereInput
    none?: SettingWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketTrackingListRelationFilter = {
    every?: TicketTrackingWhereInput
    some?: TicketTrackingWhereInput
    none?: TicketTrackingWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type QuickMessageListRelationFilter = {
    every?: QuickMessageWhereInput
    some?: QuickMessageWhereInput
    none?: QuickMessageWhereInput
  }

  export type QueueIntegrationsListRelationFilter = {
    every?: QueueIntegrationsWhereInput
    some?: QueueIntegrationsWhereInput
    none?: QueueIntegrationsWhereInput
  }

  export type PromptListRelationFilter = {
    every?: PromptWhereInput
    some?: PromptWhereInput
    none?: PromptWhereInput
  }

  export type FilesListRelationFilter = {
    every?: FilesWhereInput
    some?: FilesWhereInput
    none?: FilesWhereInput
  }

  export type ContactListItemListRelationFilter = {
    every?: ContactListItemWhereInput
    some?: ContactListItemWhereInput
    none?: ContactListItemWhereInput
  }

  export type ContactListListRelationFilter = {
    every?: ContactListWhereInput
    some?: ContactListWhereInput
    none?: ContactListWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type CampaignSettingListRelationFilter = {
    every?: CampaignSettingWhereInput
    some?: CampaignSettingWhereInput
    none?: CampaignSettingWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuickMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueueIntegrationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactListItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    recurrence?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    recurrence?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    recurrence?: SortOrder
    planId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
  }

  export type ContactCustomFieldListRelationFilter = {
    every?: ContactCustomFieldWhereInput
    some?: ContactCustomFieldWhereInput
    none?: ContactCustomFieldWhereInput
  }

  export type TicketNoteListRelationFilter = {
    every?: TicketNoteWhereInput
    some?: TicketNoteWhereInput
    none?: TicketNoteWhereInput
  }

  export type ContactCustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type ContactRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactCustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCustomFieldAvgOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
  }

  export type ContactCustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    contactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCustomFieldSumOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
  }

  export type ContactListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ContactListAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ContactListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ContactListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type ContactListSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ContactListRelationFilter = {
    is?: ContactListWhereInput
    isNot?: ContactListWhereInput
  }

  export type ContactListItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    isWhatsappValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
  }

  export type ContactListItemAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
  }

  export type ContactListItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    isWhatsappValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
  }

  export type ContactListItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    email?: SortOrder
    isWhatsappValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
  }

  export type ContactListItemSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    contactListId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FilesOptionsListRelationFilter = {
    every?: FilesOptionsWhereInput
    some?: FilesOptionsWhereInput
    none?: FilesOptionsWhereInput
  }

  export type FilesOptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type FilesAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type FilesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type FilesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type FilesSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type FilesOptionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileId?: SortOrder
  }

  export type FilesOptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
  }

  export type FilesOptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileId?: SortOrder
  }

  export type FilesOptionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileId?: SortOrder
  }

  export type FilesOptionsSumOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
  }

  export type HelpCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    video?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HelpMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    video?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    video?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dueDate?: SortOrder
    companyId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    companyId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Action_LogsNullableRelationFilter = {
    is?: Action_LogsWhereInput | null
    isNot?: Action_LogsWhereInput | null
  }

  export type System_LogsCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    actionLogId?: SortOrder
  }

  export type System_LogsAvgOrderByAggregateInput = {
    id?: SortOrder
    actionLogId?: SortOrder
  }

  export type System_LogsMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    actionLogId?: SortOrder
  }

  export type System_LogsMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    actionLogId?: SortOrder
  }

  export type System_LogsSumOrderByAggregateInput = {
    id?: SortOrder
    actionLogId?: SortOrder
  }

  export type TicketNullableRelationFilter = {
    is?: TicketWhereInput | null
    isNot?: TicketWhereInput | null
  }

  export type System_LogsListRelationFilter = {
    every?: System_LogsWhereInput
    some?: System_LogsWhereInput
    none?: System_LogsWhereInput
  }

  export type System_LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Action_LogsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type Action_LogsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrder
  }

  export type Action_LogsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type Action_LogsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type Action_LogsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ticketId?: SortOrder
  }

  export type MessageNullableRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type ContactNullableRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type QueueNullableRelationFilter = {
    is?: QueueWhereInput | null
    isNot?: QueueWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    participant?: SortOrder
    dataJson?: SortOrder
    ack?: SortOrder
    read?: SortOrder
    fromMe?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotedMsgId?: SortOrder
    ticketId?: SortOrder
    contactId?: SortOrder
    companyId?: SortOrder
    queueId?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    ack?: SortOrder
    ticketId?: SortOrder
    contactId?: SortOrder
    companyId?: SortOrder
    queueId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    participant?: SortOrder
    dataJson?: SortOrder
    ack?: SortOrder
    read?: SortOrder
    fromMe?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotedMsgId?: SortOrder
    ticketId?: SortOrder
    contactId?: SortOrder
    companyId?: SortOrder
    queueId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    participant?: SortOrder
    dataJson?: SortOrder
    ack?: SortOrder
    read?: SortOrder
    fromMe?: SortOrder
    body?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotedMsgId?: SortOrder
    ticketId?: SortOrder
    contactId?: SortOrder
    companyId?: SortOrder
    queueId?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    ack?: SortOrder
    ticketId?: SortOrder
    contactId?: SortOrder
    companyId?: SortOrder
    queueId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    users?: SortOrder
    connections?: SortOrder
    queues?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    useSchedules?: SortOrder
    useCampaigns?: SortOrder
    useInternalChat?: SortOrder
    useExternalApi?: SortOrder
    useKanban?: SortOrder
    useOpenAi?: SortOrder
    useIntegrations?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    id?: SortOrder
    users?: SortOrder
    connections?: SortOrder
    queues?: SortOrder
    value?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    users?: SortOrder
    connections?: SortOrder
    queues?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    useSchedules?: SortOrder
    useCampaigns?: SortOrder
    useInternalChat?: SortOrder
    useExternalApi?: SortOrder
    useKanban?: SortOrder
    useOpenAi?: SortOrder
    useIntegrations?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    users?: SortOrder
    connections?: SortOrder
    queues?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    useSchedules?: SortOrder
    useCampaigns?: SortOrder
    useInternalChat?: SortOrder
    useExternalApi?: SortOrder
    useKanban?: SortOrder
    useOpenAi?: SortOrder
    useIntegrations?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    id?: SortOrder
    users?: SortOrder
    connections?: SortOrder
    queues?: SortOrder
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PromptCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    apiKey?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    voice?: SortOrder
    voiceKey?: SortOrder
    voiceRegion?: SortOrder
    queueId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptAvgOrderByAggregateInput = {
    id?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    queueId?: SortOrder
    companyId?: SortOrder
  }

  export type PromptMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    apiKey?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    voice?: SortOrder
    voiceKey?: SortOrder
    voiceRegion?: SortOrder
    queueId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    apiKey?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    voice?: SortOrder
    voiceKey?: SortOrder
    voiceRegion?: SortOrder
    queueId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptSumOrderByAggregateInput = {
    id?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    temperature?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    queueId?: SortOrder
    companyId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type QueueOptionListRelationFilter = {
    every?: QueueOptionWhereInput
    some?: QueueOptionWhereInput
    none?: QueueOptionWhereInput
  }

  export type QueueIntegrationsNullableRelationFilter = {
    is?: QueueIntegrationsWhereInput | null
    isNot?: QueueIntegrationsWhereInput | null
  }

  export type UserQueueListRelationFilter = {
    every?: UserQueueWhereInput
    some?: UserQueueWhereInput
    none?: UserQueueWhereInput
  }

  export type WhatsappQueueListRelationFilter = {
    every?: WhatsappQueueWhereInput
    some?: WhatsappQueueWhereInput
    none?: WhatsappQueueWhereInput
  }

  export type QueueOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    greetingMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    schedules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
  }

  export type QueueAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
  }

  export type QueueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    greetingMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
  }

  export type QueueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    greetingMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
  }

  export type QueueSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    orderQueue?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type QueueIntegrationsNameCompanyIdCompoundUniqueInput = {
    name: string
    companyId: number
  }

  export type QueueIntegrationsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    projectName?: SortOrder
    jsonContent?: SortOrder
    language?: SortOrder
    urlN8N?: SortOrder
    companyId?: SortOrder
    typebotSlug?: SortOrder
    typebotExpires?: SortOrder
    typebotKeywordFinish?: SortOrder
    typebotUnknownMessage?: SortOrder
    typebotDelayMessage?: SortOrder
    typebotKeywordRestart?: SortOrder
    typebotRestartMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueIntegrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    typebotExpires?: SortOrder
    typebotDelayMessage?: SortOrder
  }

  export type QueueIntegrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    projectName?: SortOrder
    jsonContent?: SortOrder
    language?: SortOrder
    urlN8N?: SortOrder
    companyId?: SortOrder
    typebotSlug?: SortOrder
    typebotExpires?: SortOrder
    typebotKeywordFinish?: SortOrder
    typebotUnknownMessage?: SortOrder
    typebotDelayMessage?: SortOrder
    typebotKeywordRestart?: SortOrder
    typebotRestartMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueIntegrationsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    projectName?: SortOrder
    jsonContent?: SortOrder
    language?: SortOrder
    urlN8N?: SortOrder
    companyId?: SortOrder
    typebotSlug?: SortOrder
    typebotExpires?: SortOrder
    typebotKeywordFinish?: SortOrder
    typebotUnknownMessage?: SortOrder
    typebotDelayMessage?: SortOrder
    typebotKeywordRestart?: SortOrder
    typebotRestartMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueIntegrationsSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    typebotExpires?: SortOrder
    typebotDelayMessage?: SortOrder
  }

  export type QueueRelationFilter = {
    is?: QueueWhereInput
    isNot?: QueueWhereInput
  }

  export type QueueOptionNullableRelationFilter = {
    is?: QueueOptionWhereInput | null
    isNot?: QueueOptionWhereInput | null
  }

  export type QueueOptionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    option?: SortOrder
    queueId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    queueId?: SortOrder
    parentId?: SortOrder
  }

  export type QueueOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    option?: SortOrder
    queueId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueOptionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    option?: SortOrder
    queueId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueOptionSumOrderByAggregateInput = {
    id?: SortOrder
    queueId?: SortOrder
    parentId?: SortOrder
  }

  export type QuickMessageCountOrderByAggregateInput = {
    id?: SortOrder
    shortcode?: SortOrder
    message?: SortOrder
    mediaName?: SortOrder
    mediaPath?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuickMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type QuickMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    shortcode?: SortOrder
    message?: SortOrder
    mediaName?: SortOrder
    mediaPath?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuickMessageMinOrderByAggregateInput = {
    id?: SortOrder
    shortcode?: SortOrder
    message?: SortOrder
    mediaName?: SortOrder
    mediaPath?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuickMessageSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type TicketRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrder
    status?: SortOrder
    mediaPath?: SortOrder
    mediaName?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type SettingCompanyIdKeyCompoundUniqueInput = {
    companyId: number
    key: string
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SettingAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SettingSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    userPriceCents?: SortOrder
    whatsPriceCents?: SortOrder
    lastInvoiceUrl?: SortOrder
    lastPlanChange?: SortOrder
    expiresAt?: SortOrder
    providerSubscriptionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    userPriceCents?: SortOrder
    whatsPriceCents?: SortOrder
    companyId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    userPriceCents?: SortOrder
    whatsPriceCents?: SortOrder
    lastInvoiceUrl?: SortOrder
    lastPlanChange?: SortOrder
    expiresAt?: SortOrder
    providerSubscriptionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    userPriceCents?: SortOrder
    whatsPriceCents?: SortOrder
    lastInvoiceUrl?: SortOrder
    lastPlanChange?: SortOrder
    expiresAt?: SortOrder
    providerSubscriptionId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    userPriceCents?: SortOrder
    whatsPriceCents?: SortOrder
    companyId?: SortOrder
  }

  export type TicketTagListRelationFilter = {
    every?: TicketTagWhereInput
    some?: TicketTagWhereInput
    none?: TicketTagWhereInput
  }

  export type TicketTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    kanban?: SortOrder
  }

  export type QueueOptionRelationFilter = {
    is?: QueueOptionWhereInput
    isNot?: QueueOptionWhereInput
  }

  export type PromptNullableRelationFilter = {
    is?: PromptWhereInput | null
    isNot?: PromptWhereInput | null
  }

  export type Action_LogsListRelationFilter = {
    every?: Action_LogsWhereInput
    some?: Action_LogsWhereInput
    none?: Action_LogsWhereInput
  }

  export type Action_LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    unreadMessages?: SortOrder
    lastMessage?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    chatbot?: SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    uuid?: SortOrder
    useIntegration?: SortOrder
    integrationId?: SortOrder
    typebotSessionId?: SortOrder
    typebotStatus?: SortOrder
    promptId?: SortOrder
    fromMe?: SortOrder
    amountUsedBotQueues?: SortOrder
    isBot?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    id?: SortOrder
    unreadMessages?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
    amountUsedBotQueues?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    unreadMessages?: SortOrder
    lastMessage?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    chatbot?: SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    uuid?: SortOrder
    useIntegration?: SortOrder
    integrationId?: SortOrder
    typebotSessionId?: SortOrder
    typebotStatus?: SortOrder
    promptId?: SortOrder
    fromMe?: SortOrder
    amountUsedBotQueues?: SortOrder
    isBot?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    unreadMessages?: SortOrder
    lastMessage?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    chatbot?: SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    uuid?: SortOrder
    useIntegration?: SortOrder
    integrationId?: SortOrder
    typebotSessionId?: SortOrder
    typebotStatus?: SortOrder
    promptId?: SortOrder
    fromMe?: SortOrder
    amountUsedBotQueues?: SortOrder
    isBot?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    id?: SortOrder
    unreadMessages?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    whatsappId?: SortOrder
    queueId?: SortOrder
    queueOptionId?: SortOrder
    companyId?: SortOrder
    integrationId?: SortOrder
    promptId?: SortOrder
    amountUsedBotQueues?: SortOrder
  }

  export type TicketNoteCountOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketNoteMinOrderByAggregateInput = {
    id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
  }

  export type TicketNoteSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    ticketId?: SortOrder
  }

  export type TagRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TicketTagTicketIdTagIdCompoundUniqueInput = {
    ticketId: number
    tagId: number
  }

  export type TicketTagCountOrderByAggregateInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketTagAvgOrderByAggregateInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
  }

  export type TicketTagMaxOrderByAggregateInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketTagMinOrderByAggregateInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketTagSumOrderByAggregateInput = {
    ticketId?: SortOrder
    tagId?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TicketTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    userId?: SortOrder
    rated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    queuedAt?: SortOrder
    finishedAt?: SortOrder
    closedAt?: SortOrder
    ratingAt?: SortOrder
    chatbotAt?: SortOrder
  }

  export type TicketTrackingAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    userId?: SortOrder
  }

  export type TicketTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    userId?: SortOrder
    rated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    queuedAt?: SortOrder
    finishedAt?: SortOrder
    closedAt?: SortOrder
    ratingAt?: SortOrder
    chatbotAt?: SortOrder
  }

  export type TicketTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    userId?: SortOrder
    rated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    queuedAt?: SortOrder
    finishedAt?: SortOrder
    closedAt?: SortOrder
    ratingAt?: SortOrder
    chatbotAt?: SortOrder
  }

  export type TicketTrackingSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    userId?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    tokenVersion?: SortOrder
    profile?: SortOrder
    super?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    tokenVersion?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    tokenVersion?: SortOrder
    profile?: SortOrder
    super?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    tokenVersion?: SortOrder
    profile?: SortOrder
    super?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    tokenVersion?: SortOrder
    companyId?: SortOrder
    whatsappId?: SortOrder
  }

  export type UserQueueUserIdQueueIdCompoundUniqueInput = {
    userId: number
    queueId: number
  }

  export type UserQueueCountOrderByAggregateInput = {
    userId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQueueAvgOrderByAggregateInput = {
    userId?: SortOrder
    queueId?: SortOrder
  }

  export type UserQueueMaxOrderByAggregateInput = {
    userId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQueueMinOrderByAggregateInput = {
    userId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQueueSumOrderByAggregateInput = {
    userId?: SortOrder
    queueId?: SortOrder
  }

  export type UserRatingCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
  }

  export type UserRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRatingMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRatingSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    rate?: SortOrder
  }

  export type BaileysChatsListRelationFilter = {
    every?: BaileysChatsWhereInput
    some?: BaileysChatsWhereInput
    none?: BaileysChatsWhereInput
  }

  export type BaileysListRelationFilter = {
    every?: BaileysWhereInput
    some?: BaileysWhereInput
    none?: BaileysWhereInput
  }

  export type BaileysChatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BaileysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    session?: SortOrder
    qrcode?: SortOrder
    status?: SortOrder
    battery?: SortOrder
    plugged?: SortOrder
    retries?: SortOrder
    greetingMessage?: SortOrder
    farewellMessage?: SortOrder
    complationMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    ratingMessage?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    transferQueueId?: SortOrder
    timeToTransfer?: SortOrder
    maxUseBotQueues?: SortOrder
    timeUseBotQueues?: SortOrder
    sendIdQueue?: SortOrder
    timeSendQueue?: SortOrder
    integrationId?: SortOrder
    expiresTicket?: SortOrder
    expiresInactiveMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrder
  }

  export type WhatsappAvgOrderByAggregateInput = {
    id?: SortOrder
    retries?: SortOrder
    transferQueueId?: SortOrder
    timeToTransfer?: SortOrder
    maxUseBotQueues?: SortOrder
    sendIdQueue?: SortOrder
    timeSendQueue?: SortOrder
    integrationId?: SortOrder
    expiresTicket?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrder
  }

  export type WhatsappMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    session?: SortOrder
    qrcode?: SortOrder
    status?: SortOrder
    battery?: SortOrder
    plugged?: SortOrder
    retries?: SortOrder
    greetingMessage?: SortOrder
    farewellMessage?: SortOrder
    complationMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    ratingMessage?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    transferQueueId?: SortOrder
    timeToTransfer?: SortOrder
    maxUseBotQueues?: SortOrder
    timeUseBotQueues?: SortOrder
    sendIdQueue?: SortOrder
    timeSendQueue?: SortOrder
    integrationId?: SortOrder
    expiresTicket?: SortOrder
    expiresInactiveMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrder
  }

  export type WhatsappMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    session?: SortOrder
    qrcode?: SortOrder
    status?: SortOrder
    battery?: SortOrder
    plugged?: SortOrder
    retries?: SortOrder
    greetingMessage?: SortOrder
    farewellMessage?: SortOrder
    complationMessage?: SortOrder
    outOfHoursMessage?: SortOrder
    ratingMessage?: SortOrder
    provider?: SortOrder
    isDefault?: SortOrder
    token?: SortOrder
    transferQueueId?: SortOrder
    timeToTransfer?: SortOrder
    maxUseBotQueues?: SortOrder
    timeUseBotQueues?: SortOrder
    sendIdQueue?: SortOrder
    timeSendQueue?: SortOrder
    integrationId?: SortOrder
    expiresTicket?: SortOrder
    expiresInactiveMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrder
  }

  export type WhatsappSumOrderByAggregateInput = {
    id?: SortOrder
    retries?: SortOrder
    transferQueueId?: SortOrder
    timeToTransfer?: SortOrder
    maxUseBotQueues?: SortOrder
    sendIdQueue?: SortOrder
    timeSendQueue?: SortOrder
    integrationId?: SortOrder
    expiresTicket?: SortOrder
    companyId?: SortOrder
    promptId?: SortOrder
  }

  export type WhatsappQueueWhatsappIdQueueIdCompoundUniqueInput = {
    whatsappId: number
    queueId: number
  }

  export type WhatsappQueueCountOrderByAggregateInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappQueueAvgOrderByAggregateInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
  }

  export type WhatsappQueueMaxOrderByAggregateInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappQueueMinOrderByAggregateInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappQueueSumOrderByAggregateInput = {
    whatsappId?: SortOrder
    queueId?: SortOrder
  }

  export type CompanyCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<CompanyCreateWithoutAnnouncementsInput, CompanyUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAnnouncementsInput
    connect?: CompanyWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<CompanyCreateWithoutAnnouncementsInput, CompanyUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAnnouncementsInput
    upsert?: CompanyUpsertWithoutAnnouncementsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAnnouncementsInput, CompanyUpdateWithoutAnnouncementsInput>, CompanyUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type WhatsappCreateNestedOneWithoutBaileysInput = {
    create?: XOR<WhatsappCreateWithoutBaileysInput, WhatsappUncheckedCreateWithoutBaileysInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutBaileysInput
    connect?: WhatsappWhereUniqueInput
  }

  export type WhatsappUpdateOneRequiredWithoutBaileysNestedInput = {
    create?: XOR<WhatsappCreateWithoutBaileysInput, WhatsappUncheckedCreateWithoutBaileysInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutBaileysInput
    upsert?: WhatsappUpsertWithoutBaileysInput
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutBaileysInput, WhatsappUpdateWithoutBaileysInput>, WhatsappUncheckedUpdateWithoutBaileysInput>
  }

  export type WhatsappCreateNestedOneWithoutBaileysChatsInput = {
    create?: XOR<WhatsappCreateWithoutBaileysChatsInput, WhatsappUncheckedCreateWithoutBaileysChatsInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutBaileysChatsInput
    connect?: WhatsappWhereUniqueInput
  }

  export type WhatsappUpdateOneRequiredWithoutBaileysChatsNestedInput = {
    create?: XOR<WhatsappCreateWithoutBaileysChatsInput, WhatsappUncheckedCreateWithoutBaileysChatsInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutBaileysChatsInput
    upsert?: WhatsappUpsertWithoutBaileysChatsInput
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutBaileysChatsInput, WhatsappUpdateWithoutBaileysChatsInput>, WhatsappUncheckedUpdateWithoutBaileysChatsInput>
  }

  export type CompanyCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<CompanyCreateWithoutCampaignsInput, CompanyUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCampaignsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactListCreateNestedOneWithoutCampaignInput = {
    create?: XOR<ContactListCreateWithoutCampaignInput, ContactListUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: ContactListCreateOrConnectWithoutCampaignInput
    connect?: ContactListWhereUniqueInput
  }

  export type WhatsappCreateNestedOneWithoutCampaignInput = {
    create?: XOR<WhatsappCreateWithoutCampaignInput, WhatsappUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutCampaignInput
    connect?: WhatsappWhereUniqueInput
  }

  export type FilesCreateNestedOneWithoutCampaignInput = {
    create?: XOR<FilesCreateWithoutCampaignInput, FilesUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: FilesCreateOrConnectWithoutCampaignInput
    connect?: FilesWhereUniqueInput
  }

  export type CampaignShippingCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignShippingCreateWithoutCampaignInput, CampaignShippingUncheckedCreateWithoutCampaignInput> | CampaignShippingCreateWithoutCampaignInput[] | CampaignShippingUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutCampaignInput | CampaignShippingCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignShippingCreateManyCampaignInputEnvelope
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
  }

  export type CampaignShippingUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignShippingCreateWithoutCampaignInput, CampaignShippingUncheckedCreateWithoutCampaignInput> | CampaignShippingCreateWithoutCampaignInput[] | CampaignShippingUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutCampaignInput | CampaignShippingCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignShippingCreateManyCampaignInputEnvelope
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CompanyUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<CompanyCreateWithoutCampaignsInput, CompanyUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCampaignsInput
    upsert?: CompanyUpsertWithoutCampaignsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCampaignsInput, CompanyUpdateWithoutCampaignsInput>, CompanyUncheckedUpdateWithoutCampaignsInput>
  }

  export type ContactListUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<ContactListCreateWithoutCampaignInput, ContactListUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: ContactListCreateOrConnectWithoutCampaignInput
    upsert?: ContactListUpsertWithoutCampaignInput
    disconnect?: ContactListWhereInput | boolean
    delete?: ContactListWhereInput | boolean
    connect?: ContactListWhereUniqueInput
    update?: XOR<XOR<ContactListUpdateToOneWithWhereWithoutCampaignInput, ContactListUpdateWithoutCampaignInput>, ContactListUncheckedUpdateWithoutCampaignInput>
  }

  export type WhatsappUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<WhatsappCreateWithoutCampaignInput, WhatsappUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutCampaignInput
    upsert?: WhatsappUpsertWithoutCampaignInput
    disconnect?: WhatsappWhereInput | boolean
    delete?: WhatsappWhereInput | boolean
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutCampaignInput, WhatsappUpdateWithoutCampaignInput>, WhatsappUncheckedUpdateWithoutCampaignInput>
  }

  export type FilesUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<FilesCreateWithoutCampaignInput, FilesUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: FilesCreateOrConnectWithoutCampaignInput
    upsert?: FilesUpsertWithoutCampaignInput
    connect?: FilesWhereUniqueInput
    update?: XOR<XOR<FilesUpdateToOneWithWhereWithoutCampaignInput, FilesUpdateWithoutCampaignInput>, FilesUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignShippingUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignShippingCreateWithoutCampaignInput, CampaignShippingUncheckedCreateWithoutCampaignInput> | CampaignShippingCreateWithoutCampaignInput[] | CampaignShippingUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutCampaignInput | CampaignShippingCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignShippingUpsertWithWhereUniqueWithoutCampaignInput | CampaignShippingUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignShippingCreateManyCampaignInputEnvelope
    set?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    disconnect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    delete?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    update?: CampaignShippingUpdateWithWhereUniqueWithoutCampaignInput | CampaignShippingUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignShippingUpdateManyWithWhereWithoutCampaignInput | CampaignShippingUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignShippingScalarWhereInput | CampaignShippingScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignShippingUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignShippingCreateWithoutCampaignInput, CampaignShippingUncheckedCreateWithoutCampaignInput> | CampaignShippingCreateWithoutCampaignInput[] | CampaignShippingUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutCampaignInput | CampaignShippingCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignShippingUpsertWithWhereUniqueWithoutCampaignInput | CampaignShippingUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignShippingCreateManyCampaignInputEnvelope
    set?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    disconnect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    delete?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    update?: CampaignShippingUpdateWithWhereUniqueWithoutCampaignInput | CampaignShippingUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignShippingUpdateManyWithWhereWithoutCampaignInput | CampaignShippingUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignShippingScalarWhereInput | CampaignShippingScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCampaignSettingsInput = {
    create?: XOR<CompanyCreateWithoutCampaignSettingsInput, CompanyUncheckedCreateWithoutCampaignSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCampaignSettingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCampaignSettingsNestedInput = {
    create?: XOR<CompanyCreateWithoutCampaignSettingsInput, CompanyUncheckedCreateWithoutCampaignSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCampaignSettingsInput
    upsert?: CompanyUpsertWithoutCampaignSettingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCampaignSettingsInput, CompanyUpdateWithoutCampaignSettingsInput>, CompanyUncheckedUpdateWithoutCampaignSettingsInput>
  }

  export type ContactListItemCreateNestedOneWithoutCampaignShippingInput = {
    create?: XOR<ContactListItemCreateWithoutCampaignShippingInput, ContactListItemUncheckedCreateWithoutCampaignShippingInput>
    connectOrCreate?: ContactListItemCreateOrConnectWithoutCampaignShippingInput
    connect?: ContactListItemWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutShippingInput = {
    create?: XOR<CampaignCreateWithoutShippingInput, CampaignUncheckedCreateWithoutShippingInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutShippingInput
    connect?: CampaignWhereUniqueInput
  }

  export type ContactListItemUpdateOneRequiredWithoutCampaignShippingNestedInput = {
    create?: XOR<ContactListItemCreateWithoutCampaignShippingInput, ContactListItemUncheckedCreateWithoutCampaignShippingInput>
    connectOrCreate?: ContactListItemCreateOrConnectWithoutCampaignShippingInput
    upsert?: ContactListItemUpsertWithoutCampaignShippingInput
    connect?: ContactListItemWhereUniqueInput
    update?: XOR<XOR<ContactListItemUpdateToOneWithWhereWithoutCampaignShippingInput, ContactListItemUpdateWithoutCampaignShippingInput>, ContactListItemUncheckedUpdateWithoutCampaignShippingInput>
  }

  export type CampaignUpdateOneRequiredWithoutShippingNestedInput = {
    create?: XOR<CampaignCreateWithoutShippingInput, CampaignUncheckedCreateWithoutShippingInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutShippingInput
    upsert?: CampaignUpsertWithoutShippingInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutShippingInput, CampaignUpdateWithoutShippingInput>, CampaignUncheckedUpdateWithoutShippingInput>
  }

  export type CompanyCreateNestedOneWithoutChatsInput = {
    create?: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutChatsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatInput = {
    create?: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUserCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatUserCreateWithoutChatInput, ChatUserUncheckedCreateWithoutChatInput> | ChatUserCreateWithoutChatInput[] | ChatUserUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutChatInput | ChatUserCreateOrConnectWithoutChatInput[]
    createMany?: ChatUserCreateManyChatInputEnvelope
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatUserUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatUserCreateWithoutChatInput, ChatUserUncheckedCreateWithoutChatInput> | ChatUserCreateWithoutChatInput[] | ChatUserUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutChatInput | ChatUserCreateOrConnectWithoutChatInput[]
    createMany?: ChatUserCreateManyChatInputEnvelope
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutChatsInput
    upsert?: CompanyUpsertWithoutChatsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutChatsInput, CompanyUpdateWithoutChatsInput>, CompanyUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatInput
    upsert?: UserUpsertWithoutChatInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatInput, UserUpdateWithoutChatInput>, UserUncheckedUpdateWithoutChatInput>
  }

  export type ChatUserUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatUserCreateWithoutChatInput, ChatUserUncheckedCreateWithoutChatInput> | ChatUserCreateWithoutChatInput[] | ChatUserUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutChatInput | ChatUserCreateOrConnectWithoutChatInput[]
    upsert?: ChatUserUpsertWithWhereUniqueWithoutChatInput | ChatUserUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatUserCreateManyChatInputEnvelope
    set?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    disconnect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    delete?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    update?: ChatUserUpdateWithWhereUniqueWithoutChatInput | ChatUserUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatUserUpdateManyWithWhereWithoutChatInput | ChatUserUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatUserScalarWhereInput | ChatUserScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatUserUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatUserCreateWithoutChatInput, ChatUserUncheckedCreateWithoutChatInput> | ChatUserCreateWithoutChatInput[] | ChatUserUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutChatInput | ChatUserCreateOrConnectWithoutChatInput[]
    upsert?: ChatUserUpsertWithWhereUniqueWithoutChatInput | ChatUserUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatUserCreateManyChatInputEnvelope
    set?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    disconnect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    delete?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    update?: ChatUserUpdateWithWhereUniqueWithoutChatInput | ChatUserUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatUserUpdateManyWithWhereWithoutChatInput | ChatUserUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatUserScalarWhereInput | ChatUserScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatMessageInput = {
    create?: XOR<UserCreateWithoutChatMessageInput, UserUncheckedCreateWithoutChatMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessageInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutChatMessageNestedInput = {
    create?: XOR<UserCreateWithoutChatMessageInput, UserUncheckedCreateWithoutChatMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessageInput
    upsert?: UserUpsertWithoutChatMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatMessageInput, UserUpdateWithoutChatMessageInput>, UserUncheckedUpdateWithoutChatMessageInput>
  }

  export type ChatCreateNestedOneWithoutUsersInput = {
    create?: XOR<ChatCreateWithoutUsersInput, ChatUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutUsersInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatUsersInput = {
    create?: XOR<UserCreateWithoutChatUsersInput, UserUncheckedCreateWithoutChatUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatUsersInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ChatCreateWithoutUsersInput, ChatUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutUsersInput
    upsert?: ChatUpsertWithoutUsersInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutUsersInput, ChatUpdateWithoutUsersInput>, ChatUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutChatUsersNestedInput = {
    create?: XOR<UserCreateWithoutChatUsersInput, UserUncheckedCreateWithoutChatUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatUsersInput
    upsert?: UserUpsertWithoutChatUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatUsersInput, UserUpdateWithoutChatUsersInput>, UserUncheckedUpdateWithoutChatUsersInput>
  }

  export type ScheduleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type PlanCreateNestedOneWithoutCompanyInput = {
    create?: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PlanCreateOrConnectWithoutCompanyInput
    connect?: PlanWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserRatingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserRatingCreateWithoutCompanyInput, UserRatingUncheckedCreateWithoutCompanyInput> | UserRatingCreateWithoutCompanyInput[] | UserRatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutCompanyInput | UserRatingCreateOrConnectWithoutCompanyInput[]
    createMany?: UserRatingCreateManyCompanyInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type QueueCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type WhatsappCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WhatsappCreateWithoutCompanyInput, WhatsappUncheckedCreateWithoutCompanyInput> | WhatsappCreateWithoutCompanyInput[] | WhatsappUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutCompanyInput | WhatsappCreateOrConnectWithoutCompanyInput[]
    createMany?: WhatsappCreateManyCompanyInputEnvelope
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MessageCreateWithoutCompanyInput, MessageUncheckedCreateWithoutCompanyInput> | MessageCreateWithoutCompanyInput[] | MessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCompanyInput | MessageCreateOrConnectWithoutCompanyInput[]
    createMany?: MessageCreateManyCompanyInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type SettingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SettingCreateWithoutCompanyInput, SettingUncheckedCreateWithoutCompanyInput> | SettingCreateWithoutCompanyInput[] | SettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SettingCreateOrConnectWithoutCompanyInput | SettingCreateOrConnectWithoutCompanyInput[]
    createMany?: SettingCreateManyCompanyInputEnvelope
    connect?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TagCreateWithoutCompanyInput, TagUncheckedCreateWithoutCompanyInput> | TagCreateWithoutCompanyInput[] | TagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCompanyInput | TagCreateOrConnectWithoutCompanyInput[]
    createMany?: TagCreateManyCompanyInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketTrackingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TicketTrackingCreateWithoutCompanyInput, TicketTrackingUncheckedCreateWithoutCompanyInput> | TicketTrackingCreateWithoutCompanyInput[] | TicketTrackingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutCompanyInput | TicketTrackingCreateOrConnectWithoutCompanyInput[]
    createMany?: TicketTrackingCreateManyCompanyInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type QuickMessageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QuickMessageCreateWithoutCompanyInput, QuickMessageUncheckedCreateWithoutCompanyInput> | QuickMessageCreateWithoutCompanyInput[] | QuickMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutCompanyInput | QuickMessageCreateOrConnectWithoutCompanyInput[]
    createMany?: QuickMessageCreateManyCompanyInputEnvelope
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
  }

  export type QueueIntegrationsCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QueueIntegrationsCreateWithoutCompanyInput, QueueIntegrationsUncheckedCreateWithoutCompanyInput> | QueueIntegrationsCreateWithoutCompanyInput[] | QueueIntegrationsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutCompanyInput | QueueIntegrationsCreateOrConnectWithoutCompanyInput[]
    createMany?: QueueIntegrationsCreateManyCompanyInputEnvelope
    connect?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
  }

  export type PromptCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PromptCreateWithoutCompanyInput, PromptUncheckedCreateWithoutCompanyInput> | PromptCreateWithoutCompanyInput[] | PromptUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutCompanyInput | PromptCreateOrConnectWithoutCompanyInput[]
    createMany?: PromptCreateManyCompanyInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type FilesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FilesCreateWithoutCompanyInput, FilesUncheckedCreateWithoutCompanyInput> | FilesCreateWithoutCompanyInput[] | FilesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutCompanyInput | FilesCreateOrConnectWithoutCompanyInput[]
    createMany?: FilesCreateManyCompanyInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type ContactListItemCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactListItemCreateWithoutCompanyInput, ContactListItemUncheckedCreateWithoutCompanyInput> | ContactListItemCreateWithoutCompanyInput[] | ContactListItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutCompanyInput | ContactListItemCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactListItemCreateManyCompanyInputEnvelope
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
  }

  export type ContactListCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactListCreateWithoutCompanyInput, ContactListUncheckedCreateWithoutCompanyInput> | ContactListCreateWithoutCompanyInput[] | ContactListUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListCreateOrConnectWithoutCompanyInput | ContactListCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactListCreateManyCompanyInputEnvelope
    connect?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type CampaignSettingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CampaignSettingCreateWithoutCompanyInput, CampaignSettingUncheckedCreateWithoutCompanyInput> | CampaignSettingCreateWithoutCompanyInput[] | CampaignSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignSettingCreateOrConnectWithoutCompanyInput | CampaignSettingCreateOrConnectWithoutCompanyInput[]
    createMany?: CampaignSettingCreateManyCompanyInputEnvelope
    connect?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CampaignCreateWithoutCompanyInput, CampaignUncheckedCreateWithoutCompanyInput> | CampaignCreateWithoutCompanyInput[] | CampaignUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCompanyInput | CampaignCreateOrConnectWithoutCompanyInput[]
    createMany?: CampaignCreateManyCompanyInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AnnouncementCreateWithoutCompanyInput, AnnouncementUncheckedCreateWithoutCompanyInput> | AnnouncementCreateWithoutCompanyInput[] | AnnouncementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCompanyInput | AnnouncementCreateOrConnectWithoutCompanyInput[]
    createMany?: AnnouncementCreateManyCompanyInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type QueueCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    createMany?: QueueCreateManyCompanyInputEnvelope
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RatingCreateWithoutCompanyInput, RatingUncheckedCreateWithoutCompanyInput> | RatingCreateWithoutCompanyInput[] | RatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCompanyInput | RatingCreateOrConnectWithoutCompanyInput[]
    createMany?: RatingCreateManyCompanyInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserRatingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserRatingCreateWithoutCompanyInput, UserRatingUncheckedCreateWithoutCompanyInput> | UserRatingCreateWithoutCompanyInput[] | UserRatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutCompanyInput | UserRatingCreateOrConnectWithoutCompanyInput[]
    createMany?: UserRatingCreateManyCompanyInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type QueueUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type WhatsappUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<WhatsappCreateWithoutCompanyInput, WhatsappUncheckedCreateWithoutCompanyInput> | WhatsappCreateWithoutCompanyInput[] | WhatsappUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutCompanyInput | WhatsappCreateOrConnectWithoutCompanyInput[]
    createMany?: WhatsappCreateManyCompanyInputEnvelope
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MessageCreateWithoutCompanyInput, MessageUncheckedCreateWithoutCompanyInput> | MessageCreateWithoutCompanyInput[] | MessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCompanyInput | MessageCreateOrConnectWithoutCompanyInput[]
    createMany?: MessageCreateManyCompanyInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type SettingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SettingCreateWithoutCompanyInput, SettingUncheckedCreateWithoutCompanyInput> | SettingCreateWithoutCompanyInput[] | SettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SettingCreateOrConnectWithoutCompanyInput | SettingCreateOrConnectWithoutCompanyInput[]
    createMany?: SettingCreateManyCompanyInputEnvelope
    connect?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TagCreateWithoutCompanyInput, TagUncheckedCreateWithoutCompanyInput> | TagCreateWithoutCompanyInput[] | TagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCompanyInput | TagCreateOrConnectWithoutCompanyInput[]
    createMany?: TagCreateManyCompanyInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TicketTrackingCreateWithoutCompanyInput, TicketTrackingUncheckedCreateWithoutCompanyInput> | TicketTrackingCreateWithoutCompanyInput[] | TicketTrackingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutCompanyInput | TicketTrackingCreateOrConnectWithoutCompanyInput[]
    createMany?: TicketTrackingCreateManyCompanyInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type QuickMessageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QuickMessageCreateWithoutCompanyInput, QuickMessageUncheckedCreateWithoutCompanyInput> | QuickMessageCreateWithoutCompanyInput[] | QuickMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutCompanyInput | QuickMessageCreateOrConnectWithoutCompanyInput[]
    createMany?: QuickMessageCreateManyCompanyInputEnvelope
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
  }

  export type QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QueueIntegrationsCreateWithoutCompanyInput, QueueIntegrationsUncheckedCreateWithoutCompanyInput> | QueueIntegrationsCreateWithoutCompanyInput[] | QueueIntegrationsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutCompanyInput | QueueIntegrationsCreateOrConnectWithoutCompanyInput[]
    createMany?: QueueIntegrationsCreateManyCompanyInputEnvelope
    connect?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
  }

  export type PromptUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PromptCreateWithoutCompanyInput, PromptUncheckedCreateWithoutCompanyInput> | PromptCreateWithoutCompanyInput[] | PromptUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutCompanyInput | PromptCreateOrConnectWithoutCompanyInput[]
    createMany?: PromptCreateManyCompanyInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type FilesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FilesCreateWithoutCompanyInput, FilesUncheckedCreateWithoutCompanyInput> | FilesCreateWithoutCompanyInput[] | FilesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutCompanyInput | FilesCreateOrConnectWithoutCompanyInput[]
    createMany?: FilesCreateManyCompanyInputEnvelope
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
  }

  export type ContactListItemUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactListItemCreateWithoutCompanyInput, ContactListItemUncheckedCreateWithoutCompanyInput> | ContactListItemCreateWithoutCompanyInput[] | ContactListItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutCompanyInput | ContactListItemCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactListItemCreateManyCompanyInputEnvelope
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
  }

  export type ContactListUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactListCreateWithoutCompanyInput, ContactListUncheckedCreateWithoutCompanyInput> | ContactListCreateWithoutCompanyInput[] | ContactListUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListCreateOrConnectWithoutCompanyInput | ContactListCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactListCreateManyCompanyInputEnvelope
    connect?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CampaignSettingCreateWithoutCompanyInput, CampaignSettingUncheckedCreateWithoutCompanyInput> | CampaignSettingCreateWithoutCompanyInput[] | CampaignSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignSettingCreateOrConnectWithoutCompanyInput | CampaignSettingCreateOrConnectWithoutCompanyInput[]
    createMany?: CampaignSettingCreateManyCompanyInputEnvelope
    connect?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CampaignCreateWithoutCompanyInput, CampaignUncheckedCreateWithoutCompanyInput> | CampaignCreateWithoutCompanyInput[] | CampaignUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCompanyInput | CampaignCreateOrConnectWithoutCompanyInput[]
    createMany?: CampaignCreateManyCompanyInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AnnouncementCreateWithoutCompanyInput, AnnouncementUncheckedCreateWithoutCompanyInput> | AnnouncementCreateWithoutCompanyInput[] | AnnouncementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCompanyInput | AnnouncementCreateOrConnectWithoutCompanyInput[]
    createMany?: AnnouncementCreateManyCompanyInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type QueueUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    createMany?: QueueCreateManyCompanyInputEnvelope
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<RatingCreateWithoutCompanyInput, RatingUncheckedCreateWithoutCompanyInput> | RatingCreateWithoutCompanyInput[] | RatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCompanyInput | RatingCreateOrConnectWithoutCompanyInput[]
    createMany?: RatingCreateManyCompanyInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type ScheduleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutCompanyInput | ScheduleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutCompanyInput | ScheduleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutCompanyInput | ScheduleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type PlanUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: PlanCreateOrConnectWithoutCompanyInput
    upsert?: PlanUpsertWithoutCompanyInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutCompanyInput, PlanUpdateWithoutCompanyInput>, PlanUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserRatingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserRatingCreateWithoutCompanyInput, UserRatingUncheckedCreateWithoutCompanyInput> | UserRatingCreateWithoutCompanyInput[] | UserRatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutCompanyInput | UserRatingCreateOrConnectWithoutCompanyInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutCompanyInput | UserRatingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserRatingCreateManyCompanyInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutCompanyInput | UserRatingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutCompanyInput | UserRatingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type QueueUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutCompanyInput | QueueUpsertWithWhereUniqueWithoutCompanyInput[]
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutCompanyInput | QueueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutCompanyInput | QueueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type WhatsappUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WhatsappCreateWithoutCompanyInput, WhatsappUncheckedCreateWithoutCompanyInput> | WhatsappCreateWithoutCompanyInput[] | WhatsappUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutCompanyInput | WhatsappCreateOrConnectWithoutCompanyInput[]
    upsert?: WhatsappUpsertWithWhereUniqueWithoutCompanyInput | WhatsappUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WhatsappCreateManyCompanyInputEnvelope
    set?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    disconnect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    delete?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    update?: WhatsappUpdateWithWhereUniqueWithoutCompanyInput | WhatsappUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WhatsappUpdateManyWithWhereWithoutCompanyInput | WhatsappUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MessageCreateWithoutCompanyInput, MessageUncheckedCreateWithoutCompanyInput> | MessageCreateWithoutCompanyInput[] | MessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCompanyInput | MessageCreateOrConnectWithoutCompanyInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCompanyInput | MessageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MessageCreateManyCompanyInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCompanyInput | MessageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCompanyInput | MessageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type SettingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SettingCreateWithoutCompanyInput, SettingUncheckedCreateWithoutCompanyInput> | SettingCreateWithoutCompanyInput[] | SettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SettingCreateOrConnectWithoutCompanyInput | SettingCreateOrConnectWithoutCompanyInput[]
    upsert?: SettingUpsertWithWhereUniqueWithoutCompanyInput | SettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SettingCreateManyCompanyInputEnvelope
    set?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    disconnect?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    delete?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    connect?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    update?: SettingUpdateWithWhereUniqueWithoutCompanyInput | SettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SettingUpdateManyWithWhereWithoutCompanyInput | SettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SettingScalarWhereInput | SettingScalarWhereInput[]
  }

  export type TagUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TagCreateWithoutCompanyInput, TagUncheckedCreateWithoutCompanyInput> | TagCreateWithoutCompanyInput[] | TagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCompanyInput | TagCreateOrConnectWithoutCompanyInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCompanyInput | TagUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TagCreateManyCompanyInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCompanyInput | TagUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCompanyInput | TagUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCompanyInput | TicketUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCompanyInput | TicketUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCompanyInput | TicketUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketTrackingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutCompanyInput, TicketTrackingUncheckedCreateWithoutCompanyInput> | TicketTrackingCreateWithoutCompanyInput[] | TicketTrackingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutCompanyInput | TicketTrackingCreateOrConnectWithoutCompanyInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutCompanyInput | TicketTrackingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TicketTrackingCreateManyCompanyInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutCompanyInput | TicketTrackingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutCompanyInput | TicketTrackingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCompanyInput | SubscriptionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCompanyInput | SubscriptionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCompanyInput | SubscriptionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type QuickMessageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QuickMessageCreateWithoutCompanyInput, QuickMessageUncheckedCreateWithoutCompanyInput> | QuickMessageCreateWithoutCompanyInput[] | QuickMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutCompanyInput | QuickMessageCreateOrConnectWithoutCompanyInput[]
    upsert?: QuickMessageUpsertWithWhereUniqueWithoutCompanyInput | QuickMessageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QuickMessageCreateManyCompanyInputEnvelope
    set?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    disconnect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    delete?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    update?: QuickMessageUpdateWithWhereUniqueWithoutCompanyInput | QuickMessageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QuickMessageUpdateManyWithWhereWithoutCompanyInput | QuickMessageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QuickMessageScalarWhereInput | QuickMessageScalarWhereInput[]
  }

  export type QueueIntegrationsUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QueueIntegrationsCreateWithoutCompanyInput, QueueIntegrationsUncheckedCreateWithoutCompanyInput> | QueueIntegrationsCreateWithoutCompanyInput[] | QueueIntegrationsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutCompanyInput | QueueIntegrationsCreateOrConnectWithoutCompanyInput[]
    upsert?: QueueIntegrationsUpsertWithWhereUniqueWithoutCompanyInput | QueueIntegrationsUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QueueIntegrationsCreateManyCompanyInputEnvelope
    set?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    disconnect?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    delete?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    connect?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    update?: QueueIntegrationsUpdateWithWhereUniqueWithoutCompanyInput | QueueIntegrationsUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QueueIntegrationsUpdateManyWithWhereWithoutCompanyInput | QueueIntegrationsUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QueueIntegrationsScalarWhereInput | QueueIntegrationsScalarWhereInput[]
  }

  export type PromptUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PromptCreateWithoutCompanyInput, PromptUncheckedCreateWithoutCompanyInput> | PromptCreateWithoutCompanyInput[] | PromptUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutCompanyInput | PromptCreateOrConnectWithoutCompanyInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutCompanyInput | PromptUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PromptCreateManyCompanyInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutCompanyInput | PromptUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutCompanyInput | PromptUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type FilesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FilesCreateWithoutCompanyInput, FilesUncheckedCreateWithoutCompanyInput> | FilesCreateWithoutCompanyInput[] | FilesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutCompanyInput | FilesCreateOrConnectWithoutCompanyInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutCompanyInput | FilesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FilesCreateManyCompanyInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutCompanyInput | FilesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutCompanyInput | FilesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type ContactListItemUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactListItemCreateWithoutCompanyInput, ContactListItemUncheckedCreateWithoutCompanyInput> | ContactListItemCreateWithoutCompanyInput[] | ContactListItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutCompanyInput | ContactListItemCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactListItemUpsertWithWhereUniqueWithoutCompanyInput | ContactListItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactListItemCreateManyCompanyInputEnvelope
    set?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    disconnect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    delete?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    update?: ContactListItemUpdateWithWhereUniqueWithoutCompanyInput | ContactListItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactListItemUpdateManyWithWhereWithoutCompanyInput | ContactListItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactListItemScalarWhereInput | ContactListItemScalarWhereInput[]
  }

  export type ContactListUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactListCreateWithoutCompanyInput, ContactListUncheckedCreateWithoutCompanyInput> | ContactListCreateWithoutCompanyInput[] | ContactListUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListCreateOrConnectWithoutCompanyInput | ContactListCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactListUpsertWithWhereUniqueWithoutCompanyInput | ContactListUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactListCreateManyCompanyInputEnvelope
    set?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    disconnect?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    delete?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    connect?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    update?: ContactListUpdateWithWhereUniqueWithoutCompanyInput | ContactListUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactListUpdateManyWithWhereWithoutCompanyInput | ContactListUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactListScalarWhereInput | ContactListScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutCompanyInput | ChatUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutCompanyInput | ChatUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutCompanyInput | ChatUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type CampaignSettingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CampaignSettingCreateWithoutCompanyInput, CampaignSettingUncheckedCreateWithoutCompanyInput> | CampaignSettingCreateWithoutCompanyInput[] | CampaignSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignSettingCreateOrConnectWithoutCompanyInput | CampaignSettingCreateOrConnectWithoutCompanyInput[]
    upsert?: CampaignSettingUpsertWithWhereUniqueWithoutCompanyInput | CampaignSettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CampaignSettingCreateManyCompanyInputEnvelope
    set?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    disconnect?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    delete?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    connect?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    update?: CampaignSettingUpdateWithWhereUniqueWithoutCompanyInput | CampaignSettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CampaignSettingUpdateManyWithWhereWithoutCompanyInput | CampaignSettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CampaignSettingScalarWhereInput | CampaignSettingScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CampaignCreateWithoutCompanyInput, CampaignUncheckedCreateWithoutCompanyInput> | CampaignCreateWithoutCompanyInput[] | CampaignUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCompanyInput | CampaignCreateOrConnectWithoutCompanyInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCompanyInput | CampaignUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CampaignCreateManyCompanyInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCompanyInput | CampaignUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCompanyInput | CampaignUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCompanyInput, AnnouncementUncheckedCreateWithoutCompanyInput> | AnnouncementCreateWithoutCompanyInput[] | AnnouncementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCompanyInput | AnnouncementCreateOrConnectWithoutCompanyInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCompanyInput | AnnouncementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AnnouncementCreateManyCompanyInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCompanyInput | AnnouncementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCompanyInput | AnnouncementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type QueueUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutCompanyInput | QueueUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QueueCreateManyCompanyInputEnvelope
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutCompanyInput | QueueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutCompanyInput | QueueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RatingCreateWithoutCompanyInput, RatingUncheckedCreateWithoutCompanyInput> | RatingCreateWithoutCompanyInput[] | RatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCompanyInput | RatingCreateOrConnectWithoutCompanyInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutCompanyInput | RatingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RatingCreateManyCompanyInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutCompanyInput | RatingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutCompanyInput | RatingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput> | ScheduleCreateWithoutCompanyInput[] | ScheduleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutCompanyInput | ScheduleCreateOrConnectWithoutCompanyInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutCompanyInput | ScheduleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ScheduleCreateManyCompanyInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutCompanyInput | ScheduleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutCompanyInput | ScheduleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserRatingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserRatingCreateWithoutCompanyInput, UserRatingUncheckedCreateWithoutCompanyInput> | UserRatingCreateWithoutCompanyInput[] | UserRatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutCompanyInput | UserRatingCreateOrConnectWithoutCompanyInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutCompanyInput | UserRatingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserRatingCreateManyCompanyInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutCompanyInput | UserRatingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutCompanyInput | UserRatingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type QueueUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutCompanyInput | QueueUpsertWithWhereUniqueWithoutCompanyInput[]
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutCompanyInput | QueueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutCompanyInput | QueueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type WhatsappUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<WhatsappCreateWithoutCompanyInput, WhatsappUncheckedCreateWithoutCompanyInput> | WhatsappCreateWithoutCompanyInput[] | WhatsappUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutCompanyInput | WhatsappCreateOrConnectWithoutCompanyInput[]
    upsert?: WhatsappUpsertWithWhereUniqueWithoutCompanyInput | WhatsappUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: WhatsappCreateManyCompanyInputEnvelope
    set?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    disconnect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    delete?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    update?: WhatsappUpdateWithWhereUniqueWithoutCompanyInput | WhatsappUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: WhatsappUpdateManyWithWhereWithoutCompanyInput | WhatsappUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MessageCreateWithoutCompanyInput, MessageUncheckedCreateWithoutCompanyInput> | MessageCreateWithoutCompanyInput[] | MessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCompanyInput | MessageCreateOrConnectWithoutCompanyInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCompanyInput | MessageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MessageCreateManyCompanyInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCompanyInput | MessageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCompanyInput | MessageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type SettingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SettingCreateWithoutCompanyInput, SettingUncheckedCreateWithoutCompanyInput> | SettingCreateWithoutCompanyInput[] | SettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SettingCreateOrConnectWithoutCompanyInput | SettingCreateOrConnectWithoutCompanyInput[]
    upsert?: SettingUpsertWithWhereUniqueWithoutCompanyInput | SettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SettingCreateManyCompanyInputEnvelope
    set?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    disconnect?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    delete?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    connect?: SettingWhereUniqueInput | SettingWhereUniqueInput[]
    update?: SettingUpdateWithWhereUniqueWithoutCompanyInput | SettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SettingUpdateManyWithWhereWithoutCompanyInput | SettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SettingScalarWhereInput | SettingScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TagCreateWithoutCompanyInput, TagUncheckedCreateWithoutCompanyInput> | TagCreateWithoutCompanyInput[] | TagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCompanyInput | TagCreateOrConnectWithoutCompanyInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCompanyInput | TagUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TagCreateManyCompanyInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCompanyInput | TagUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCompanyInput | TagUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCompanyInput | TicketUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCompanyInput | TicketUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCompanyInput | TicketUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutCompanyInput, TicketTrackingUncheckedCreateWithoutCompanyInput> | TicketTrackingCreateWithoutCompanyInput[] | TicketTrackingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutCompanyInput | TicketTrackingCreateOrConnectWithoutCompanyInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutCompanyInput | TicketTrackingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TicketTrackingCreateManyCompanyInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutCompanyInput | TicketTrackingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutCompanyInput | TicketTrackingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCompanyInput | SubscriptionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCompanyInput | SubscriptionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCompanyInput | SubscriptionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QuickMessageCreateWithoutCompanyInput, QuickMessageUncheckedCreateWithoutCompanyInput> | QuickMessageCreateWithoutCompanyInput[] | QuickMessageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutCompanyInput | QuickMessageCreateOrConnectWithoutCompanyInput[]
    upsert?: QuickMessageUpsertWithWhereUniqueWithoutCompanyInput | QuickMessageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QuickMessageCreateManyCompanyInputEnvelope
    set?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    disconnect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    delete?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    update?: QuickMessageUpdateWithWhereUniqueWithoutCompanyInput | QuickMessageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QuickMessageUpdateManyWithWhereWithoutCompanyInput | QuickMessageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QuickMessageScalarWhereInput | QuickMessageScalarWhereInput[]
  }

  export type QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QueueIntegrationsCreateWithoutCompanyInput, QueueIntegrationsUncheckedCreateWithoutCompanyInput> | QueueIntegrationsCreateWithoutCompanyInput[] | QueueIntegrationsUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutCompanyInput | QueueIntegrationsCreateOrConnectWithoutCompanyInput[]
    upsert?: QueueIntegrationsUpsertWithWhereUniqueWithoutCompanyInput | QueueIntegrationsUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QueueIntegrationsCreateManyCompanyInputEnvelope
    set?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    disconnect?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    delete?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    connect?: QueueIntegrationsWhereUniqueInput | QueueIntegrationsWhereUniqueInput[]
    update?: QueueIntegrationsUpdateWithWhereUniqueWithoutCompanyInput | QueueIntegrationsUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QueueIntegrationsUpdateManyWithWhereWithoutCompanyInput | QueueIntegrationsUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QueueIntegrationsScalarWhereInput | QueueIntegrationsScalarWhereInput[]
  }

  export type PromptUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PromptCreateWithoutCompanyInput, PromptUncheckedCreateWithoutCompanyInput> | PromptCreateWithoutCompanyInput[] | PromptUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutCompanyInput | PromptCreateOrConnectWithoutCompanyInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutCompanyInput | PromptUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PromptCreateManyCompanyInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutCompanyInput | PromptUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutCompanyInput | PromptUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type FilesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FilesCreateWithoutCompanyInput, FilesUncheckedCreateWithoutCompanyInput> | FilesCreateWithoutCompanyInput[] | FilesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FilesCreateOrConnectWithoutCompanyInput | FilesCreateOrConnectWithoutCompanyInput[]
    upsert?: FilesUpsertWithWhereUniqueWithoutCompanyInput | FilesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FilesCreateManyCompanyInputEnvelope
    set?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    disconnect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    delete?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    connect?: FilesWhereUniqueInput | FilesWhereUniqueInput[]
    update?: FilesUpdateWithWhereUniqueWithoutCompanyInput | FilesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FilesUpdateManyWithWhereWithoutCompanyInput | FilesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FilesScalarWhereInput | FilesScalarWhereInput[]
  }

  export type ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactListItemCreateWithoutCompanyInput, ContactListItemUncheckedCreateWithoutCompanyInput> | ContactListItemCreateWithoutCompanyInput[] | ContactListItemUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutCompanyInput | ContactListItemCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactListItemUpsertWithWhereUniqueWithoutCompanyInput | ContactListItemUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactListItemCreateManyCompanyInputEnvelope
    set?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    disconnect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    delete?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    update?: ContactListItemUpdateWithWhereUniqueWithoutCompanyInput | ContactListItemUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactListItemUpdateManyWithWhereWithoutCompanyInput | ContactListItemUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactListItemScalarWhereInput | ContactListItemScalarWhereInput[]
  }

  export type ContactListUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactListCreateWithoutCompanyInput, ContactListUncheckedCreateWithoutCompanyInput> | ContactListCreateWithoutCompanyInput[] | ContactListUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactListCreateOrConnectWithoutCompanyInput | ContactListCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactListUpsertWithWhereUniqueWithoutCompanyInput | ContactListUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactListCreateManyCompanyInputEnvelope
    set?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    disconnect?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    delete?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    connect?: ContactListWhereUniqueInput | ContactListWhereUniqueInput[]
    update?: ContactListUpdateWithWhereUniqueWithoutCompanyInput | ContactListUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactListUpdateManyWithWhereWithoutCompanyInput | ContactListUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactListScalarWhereInput | ContactListScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput> | ChatCreateWithoutCompanyInput[] | ChatUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutCompanyInput | ChatCreateOrConnectWithoutCompanyInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutCompanyInput | ChatUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ChatCreateManyCompanyInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutCompanyInput | ChatUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutCompanyInput | ChatUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CampaignSettingCreateWithoutCompanyInput, CampaignSettingUncheckedCreateWithoutCompanyInput> | CampaignSettingCreateWithoutCompanyInput[] | CampaignSettingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignSettingCreateOrConnectWithoutCompanyInput | CampaignSettingCreateOrConnectWithoutCompanyInput[]
    upsert?: CampaignSettingUpsertWithWhereUniqueWithoutCompanyInput | CampaignSettingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CampaignSettingCreateManyCompanyInputEnvelope
    set?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    disconnect?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    delete?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    connect?: CampaignSettingWhereUniqueInput | CampaignSettingWhereUniqueInput[]
    update?: CampaignSettingUpdateWithWhereUniqueWithoutCompanyInput | CampaignSettingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CampaignSettingUpdateManyWithWhereWithoutCompanyInput | CampaignSettingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CampaignSettingScalarWhereInput | CampaignSettingScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CampaignCreateWithoutCompanyInput, CampaignUncheckedCreateWithoutCompanyInput> | CampaignCreateWithoutCompanyInput[] | CampaignUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCompanyInput | CampaignCreateOrConnectWithoutCompanyInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCompanyInput | CampaignUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CampaignCreateManyCompanyInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCompanyInput | CampaignUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCompanyInput | CampaignUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCompanyInput, AnnouncementUncheckedCreateWithoutCompanyInput> | AnnouncementCreateWithoutCompanyInput[] | AnnouncementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCompanyInput | AnnouncementCreateOrConnectWithoutCompanyInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCompanyInput | AnnouncementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AnnouncementCreateManyCompanyInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCompanyInput | AnnouncementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCompanyInput | AnnouncementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type QueueUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput> | QueueCreateWithoutCompanyInput[] | QueueUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutCompanyInput | QueueCreateOrConnectWithoutCompanyInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutCompanyInput | QueueUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: QueueCreateManyCompanyInputEnvelope
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutCompanyInput | QueueUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutCompanyInput | QueueUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<RatingCreateWithoutCompanyInput, RatingUncheckedCreateWithoutCompanyInput> | RatingCreateWithoutCompanyInput[] | RatingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCompanyInput | RatingCreateOrConnectWithoutCompanyInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutCompanyInput | RatingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: RatingCreateManyCompanyInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutCompanyInput | RatingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutCompanyInput | RatingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutContactsInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    connect?: CompanyWhereUniqueInput
  }

  export type WhatsappCreateNestedOneWithoutContactInput = {
    create?: XOR<WhatsappCreateWithoutContactInput, WhatsappUncheckedCreateWithoutContactInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutContactInput
    connect?: WhatsappWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutContactInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ContactCustomFieldCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactCustomFieldCreateWithoutContactInput, ContactCustomFieldUncheckedCreateWithoutContactInput> | ContactCustomFieldCreateWithoutContactInput[] | ContactCustomFieldUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactCustomFieldCreateOrConnectWithoutContactInput | ContactCustomFieldCreateOrConnectWithoutContactInput[]
    createMany?: ContactCustomFieldCreateManyContactInputEnvelope
    connect?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutContactInput = {
    create?: XOR<ScheduleCreateWithoutContactInput, ScheduleUncheckedCreateWithoutContactInput> | ScheduleCreateWithoutContactInput[] | ScheduleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutContactInput | ScheduleCreateOrConnectWithoutContactInput[]
    createMany?: ScheduleCreateManyContactInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type TicketNoteCreateNestedManyWithoutContactInput = {
    create?: XOR<TicketNoteCreateWithoutContactInput, TicketNoteUncheckedCreateWithoutContactInput> | TicketNoteCreateWithoutContactInput[] | TicketNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutContactInput | TicketNoteCreateOrConnectWithoutContactInput[]
    createMany?: TicketNoteCreateManyContactInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutContactInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactCustomFieldCreateWithoutContactInput, ContactCustomFieldUncheckedCreateWithoutContactInput> | ContactCustomFieldCreateWithoutContactInput[] | ContactCustomFieldUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactCustomFieldCreateOrConnectWithoutContactInput | ContactCustomFieldCreateOrConnectWithoutContactInput[]
    createMany?: ContactCustomFieldCreateManyContactInputEnvelope
    connect?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ScheduleCreateWithoutContactInput, ScheduleUncheckedCreateWithoutContactInput> | ScheduleCreateWithoutContactInput[] | ScheduleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutContactInput | ScheduleCreateOrConnectWithoutContactInput[]
    createMany?: ScheduleCreateManyContactInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type TicketNoteUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<TicketNoteCreateWithoutContactInput, TicketNoteUncheckedCreateWithoutContactInput> | TicketNoteCreateWithoutContactInput[] | TicketNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutContactInput | TicketNoteCreateOrConnectWithoutContactInput[]
    createMany?: TicketNoteCreateManyContactInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    upsert?: CompanyUpsertWithoutContactsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContactsInput, CompanyUpdateWithoutContactsInput>, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type WhatsappUpdateOneWithoutContactNestedInput = {
    create?: XOR<WhatsappCreateWithoutContactInput, WhatsappUncheckedCreateWithoutContactInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutContactInput
    upsert?: WhatsappUpsertWithoutContactInput
    disconnect?: WhatsappWhereInput | boolean
    delete?: WhatsappWhereInput | boolean
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutContactInput, WhatsappUpdateWithoutContactInput>, WhatsappUncheckedUpdateWithoutContactInput>
  }

  export type TicketUpdateManyWithoutContactNestedInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutContactInput | TicketUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutContactInput | TicketUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutContactInput | TicketUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ContactCustomFieldUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactCustomFieldCreateWithoutContactInput, ContactCustomFieldUncheckedCreateWithoutContactInput> | ContactCustomFieldCreateWithoutContactInput[] | ContactCustomFieldUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactCustomFieldCreateOrConnectWithoutContactInput | ContactCustomFieldCreateOrConnectWithoutContactInput[]
    upsert?: ContactCustomFieldUpsertWithWhereUniqueWithoutContactInput | ContactCustomFieldUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactCustomFieldCreateManyContactInputEnvelope
    set?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    disconnect?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    delete?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    connect?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    update?: ContactCustomFieldUpdateWithWhereUniqueWithoutContactInput | ContactCustomFieldUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactCustomFieldUpdateManyWithWhereWithoutContactInput | ContactCustomFieldUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactCustomFieldScalarWhereInput | ContactCustomFieldScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutContactNestedInput = {
    create?: XOR<ScheduleCreateWithoutContactInput, ScheduleUncheckedCreateWithoutContactInput> | ScheduleCreateWithoutContactInput[] | ScheduleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutContactInput | ScheduleCreateOrConnectWithoutContactInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutContactInput | ScheduleUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ScheduleCreateManyContactInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutContactInput | ScheduleUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutContactInput | ScheduleUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type TicketNoteUpdateManyWithoutContactNestedInput = {
    create?: XOR<TicketNoteCreateWithoutContactInput, TicketNoteUncheckedCreateWithoutContactInput> | TicketNoteCreateWithoutContactInput[] | TicketNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutContactInput | TicketNoteCreateOrConnectWithoutContactInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutContactInput | TicketNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TicketNoteCreateManyContactInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutContactInput | TicketNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutContactInput | TicketNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContactInput | MessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContactInput | MessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContactInput | MessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutContactInput | TicketUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutContactInput | TicketUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutContactInput | TicketUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactCustomFieldCreateWithoutContactInput, ContactCustomFieldUncheckedCreateWithoutContactInput> | ContactCustomFieldCreateWithoutContactInput[] | ContactCustomFieldUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactCustomFieldCreateOrConnectWithoutContactInput | ContactCustomFieldCreateOrConnectWithoutContactInput[]
    upsert?: ContactCustomFieldUpsertWithWhereUniqueWithoutContactInput | ContactCustomFieldUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactCustomFieldCreateManyContactInputEnvelope
    set?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    disconnect?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    delete?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    connect?: ContactCustomFieldWhereUniqueInput | ContactCustomFieldWhereUniqueInput[]
    update?: ContactCustomFieldUpdateWithWhereUniqueWithoutContactInput | ContactCustomFieldUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactCustomFieldUpdateManyWithWhereWithoutContactInput | ContactCustomFieldUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactCustomFieldScalarWhereInput | ContactCustomFieldScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ScheduleCreateWithoutContactInput, ScheduleUncheckedCreateWithoutContactInput> | ScheduleCreateWithoutContactInput[] | ScheduleUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutContactInput | ScheduleCreateOrConnectWithoutContactInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutContactInput | ScheduleUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ScheduleCreateManyContactInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutContactInput | ScheduleUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutContactInput | ScheduleUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type TicketNoteUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<TicketNoteCreateWithoutContactInput, TicketNoteUncheckedCreateWithoutContactInput> | TicketNoteCreateWithoutContactInput[] | TicketNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutContactInput | TicketNoteCreateOrConnectWithoutContactInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutContactInput | TicketNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TicketNoteCreateManyContactInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutContactInput | TicketNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutContactInput | TicketNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContactInput | MessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContactInput | MessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContactInput | MessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutExtraInfoInput = {
    create?: XOR<ContactCreateWithoutExtraInfoInput, ContactUncheckedCreateWithoutExtraInfoInput>
    connectOrCreate?: ContactCreateOrConnectWithoutExtraInfoInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutExtraInfoNestedInput = {
    create?: XOR<ContactCreateWithoutExtraInfoInput, ContactUncheckedCreateWithoutExtraInfoInput>
    connectOrCreate?: ContactCreateOrConnectWithoutExtraInfoInput
    upsert?: ContactUpsertWithoutExtraInfoInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutExtraInfoInput, ContactUpdateWithoutExtraInfoInput>, ContactUncheckedUpdateWithoutExtraInfoInput>
  }

  export type CompanyCreateNestedOneWithoutContactListsInput = {
    create?: XOR<CompanyCreateWithoutContactListsInput, CompanyUncheckedCreateWithoutContactListsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactListsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactListItemCreateNestedManyWithoutContactListInput = {
    create?: XOR<ContactListItemCreateWithoutContactListInput, ContactListItemUncheckedCreateWithoutContactListInput> | ContactListItemCreateWithoutContactListInput[] | ContactListItemUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutContactListInput | ContactListItemCreateOrConnectWithoutContactListInput[]
    createMany?: ContactListItemCreateManyContactListInputEnvelope
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutContactListInput = {
    create?: XOR<CampaignCreateWithoutContactListInput, CampaignUncheckedCreateWithoutContactListInput> | CampaignCreateWithoutContactListInput[] | CampaignUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactListInput | CampaignCreateOrConnectWithoutContactListInput[]
    createMany?: CampaignCreateManyContactListInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ContactListItemUncheckedCreateNestedManyWithoutContactListInput = {
    create?: XOR<ContactListItemCreateWithoutContactListInput, ContactListItemUncheckedCreateWithoutContactListInput> | ContactListItemCreateWithoutContactListInput[] | ContactListItemUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutContactListInput | ContactListItemCreateOrConnectWithoutContactListInput[]
    createMany?: ContactListItemCreateManyContactListInputEnvelope
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutContactListInput = {
    create?: XOR<CampaignCreateWithoutContactListInput, CampaignUncheckedCreateWithoutContactListInput> | CampaignCreateWithoutContactListInput[] | CampaignUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactListInput | CampaignCreateOrConnectWithoutContactListInput[]
    createMany?: CampaignCreateManyContactListInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutContactListsNestedInput = {
    create?: XOR<CompanyCreateWithoutContactListsInput, CompanyUncheckedCreateWithoutContactListsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactListsInput
    upsert?: CompanyUpsertWithoutContactListsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContactListsInput, CompanyUpdateWithoutContactListsInput>, CompanyUncheckedUpdateWithoutContactListsInput>
  }

  export type ContactListItemUpdateManyWithoutContactListNestedInput = {
    create?: XOR<ContactListItemCreateWithoutContactListInput, ContactListItemUncheckedCreateWithoutContactListInput> | ContactListItemCreateWithoutContactListInput[] | ContactListItemUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutContactListInput | ContactListItemCreateOrConnectWithoutContactListInput[]
    upsert?: ContactListItemUpsertWithWhereUniqueWithoutContactListInput | ContactListItemUpsertWithWhereUniqueWithoutContactListInput[]
    createMany?: ContactListItemCreateManyContactListInputEnvelope
    set?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    disconnect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    delete?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    update?: ContactListItemUpdateWithWhereUniqueWithoutContactListInput | ContactListItemUpdateWithWhereUniqueWithoutContactListInput[]
    updateMany?: ContactListItemUpdateManyWithWhereWithoutContactListInput | ContactListItemUpdateManyWithWhereWithoutContactListInput[]
    deleteMany?: ContactListItemScalarWhereInput | ContactListItemScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutContactListNestedInput = {
    create?: XOR<CampaignCreateWithoutContactListInput, CampaignUncheckedCreateWithoutContactListInput> | CampaignCreateWithoutContactListInput[] | CampaignUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactListInput | CampaignCreateOrConnectWithoutContactListInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutContactListInput | CampaignUpsertWithWhereUniqueWithoutContactListInput[]
    createMany?: CampaignCreateManyContactListInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutContactListInput | CampaignUpdateWithWhereUniqueWithoutContactListInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutContactListInput | CampaignUpdateManyWithWhereWithoutContactListInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ContactListItemUncheckedUpdateManyWithoutContactListNestedInput = {
    create?: XOR<ContactListItemCreateWithoutContactListInput, ContactListItemUncheckedCreateWithoutContactListInput> | ContactListItemCreateWithoutContactListInput[] | ContactListItemUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: ContactListItemCreateOrConnectWithoutContactListInput | ContactListItemCreateOrConnectWithoutContactListInput[]
    upsert?: ContactListItemUpsertWithWhereUniqueWithoutContactListInput | ContactListItemUpsertWithWhereUniqueWithoutContactListInput[]
    createMany?: ContactListItemCreateManyContactListInputEnvelope
    set?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    disconnect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    delete?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    connect?: ContactListItemWhereUniqueInput | ContactListItemWhereUniqueInput[]
    update?: ContactListItemUpdateWithWhereUniqueWithoutContactListInput | ContactListItemUpdateWithWhereUniqueWithoutContactListInput[]
    updateMany?: ContactListItemUpdateManyWithWhereWithoutContactListInput | ContactListItemUpdateManyWithWhereWithoutContactListInput[]
    deleteMany?: ContactListItemScalarWhereInput | ContactListItemScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutContactListNestedInput = {
    create?: XOR<CampaignCreateWithoutContactListInput, CampaignUncheckedCreateWithoutContactListInput> | CampaignCreateWithoutContactListInput[] | CampaignUncheckedCreateWithoutContactListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactListInput | CampaignCreateOrConnectWithoutContactListInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutContactListInput | CampaignUpsertWithWhereUniqueWithoutContactListInput[]
    createMany?: CampaignCreateManyContactListInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutContactListInput | CampaignUpdateWithWhereUniqueWithoutContactListInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutContactListInput | CampaignUpdateManyWithWhereWithoutContactListInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutContactListItemsInput = {
    create?: XOR<CompanyCreateWithoutContactListItemsInput, CompanyUncheckedCreateWithoutContactListItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactListItemsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactListCreateNestedOneWithoutItemsInput = {
    create?: XOR<ContactListCreateWithoutItemsInput, ContactListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ContactListCreateOrConnectWithoutItemsInput
    connect?: ContactListWhereUniqueInput
  }

  export type CampaignShippingCreateNestedManyWithoutContactInput = {
    create?: XOR<CampaignShippingCreateWithoutContactInput, CampaignShippingUncheckedCreateWithoutContactInput> | CampaignShippingCreateWithoutContactInput[] | CampaignShippingUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutContactInput | CampaignShippingCreateOrConnectWithoutContactInput[]
    createMany?: CampaignShippingCreateManyContactInputEnvelope
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
  }

  export type CampaignShippingUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CampaignShippingCreateWithoutContactInput, CampaignShippingUncheckedCreateWithoutContactInput> | CampaignShippingCreateWithoutContactInput[] | CampaignShippingUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutContactInput | CampaignShippingCreateOrConnectWithoutContactInput[]
    createMany?: CampaignShippingCreateManyContactInputEnvelope
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CompanyUpdateOneRequiredWithoutContactListItemsNestedInput = {
    create?: XOR<CompanyCreateWithoutContactListItemsInput, CompanyUncheckedCreateWithoutContactListItemsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactListItemsInput
    upsert?: CompanyUpsertWithoutContactListItemsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContactListItemsInput, CompanyUpdateWithoutContactListItemsInput>, CompanyUncheckedUpdateWithoutContactListItemsInput>
  }

  export type ContactListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ContactListCreateWithoutItemsInput, ContactListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ContactListCreateOrConnectWithoutItemsInput
    upsert?: ContactListUpsertWithoutItemsInput
    connect?: ContactListWhereUniqueInput
    update?: XOR<XOR<ContactListUpdateToOneWithWhereWithoutItemsInput, ContactListUpdateWithoutItemsInput>, ContactListUncheckedUpdateWithoutItemsInput>
  }

  export type CampaignShippingUpdateManyWithoutContactNestedInput = {
    create?: XOR<CampaignShippingCreateWithoutContactInput, CampaignShippingUncheckedCreateWithoutContactInput> | CampaignShippingCreateWithoutContactInput[] | CampaignShippingUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutContactInput | CampaignShippingCreateOrConnectWithoutContactInput[]
    upsert?: CampaignShippingUpsertWithWhereUniqueWithoutContactInput | CampaignShippingUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CampaignShippingCreateManyContactInputEnvelope
    set?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    disconnect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    delete?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    update?: CampaignShippingUpdateWithWhereUniqueWithoutContactInput | CampaignShippingUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CampaignShippingUpdateManyWithWhereWithoutContactInput | CampaignShippingUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CampaignShippingScalarWhereInput | CampaignShippingScalarWhereInput[]
  }

  export type CampaignShippingUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CampaignShippingCreateWithoutContactInput, CampaignShippingUncheckedCreateWithoutContactInput> | CampaignShippingCreateWithoutContactInput[] | CampaignShippingUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CampaignShippingCreateOrConnectWithoutContactInput | CampaignShippingCreateOrConnectWithoutContactInput[]
    upsert?: CampaignShippingUpsertWithWhereUniqueWithoutContactInput | CampaignShippingUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CampaignShippingCreateManyContactInputEnvelope
    set?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    disconnect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    delete?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    connect?: CampaignShippingWhereUniqueInput | CampaignShippingWhereUniqueInput[]
    update?: CampaignShippingUpdateWithWhereUniqueWithoutContactInput | CampaignShippingUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CampaignShippingUpdateManyWithWhereWithoutContactInput | CampaignShippingUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CampaignShippingScalarWhereInput | CampaignShippingScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutFilessInput = {
    create?: XOR<CompanyCreateWithoutFilessInput, CompanyUncheckedCreateWithoutFilessInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFilessInput
    connect?: CompanyWhereUniqueInput
  }

  export type FilesOptionsCreateNestedManyWithoutFileInput = {
    create?: XOR<FilesOptionsCreateWithoutFileInput, FilesOptionsUncheckedCreateWithoutFileInput> | FilesOptionsCreateWithoutFileInput[] | FilesOptionsUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FilesOptionsCreateOrConnectWithoutFileInput | FilesOptionsCreateOrConnectWithoutFileInput[]
    createMany?: FilesOptionsCreateManyFileInputEnvelope
    connect?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutFileListInput = {
    create?: XOR<CampaignCreateWithoutFileListInput, CampaignUncheckedCreateWithoutFileListInput> | CampaignCreateWithoutFileListInput[] | CampaignUncheckedCreateWithoutFileListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutFileListInput | CampaignCreateOrConnectWithoutFileListInput[]
    createMany?: CampaignCreateManyFileListInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type FilesOptionsUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<FilesOptionsCreateWithoutFileInput, FilesOptionsUncheckedCreateWithoutFileInput> | FilesOptionsCreateWithoutFileInput[] | FilesOptionsUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FilesOptionsCreateOrConnectWithoutFileInput | FilesOptionsCreateOrConnectWithoutFileInput[]
    createMany?: FilesOptionsCreateManyFileInputEnvelope
    connect?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutFileListInput = {
    create?: XOR<CampaignCreateWithoutFileListInput, CampaignUncheckedCreateWithoutFileListInput> | CampaignCreateWithoutFileListInput[] | CampaignUncheckedCreateWithoutFileListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutFileListInput | CampaignCreateOrConnectWithoutFileListInput[]
    createMany?: CampaignCreateManyFileListInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutFilessNestedInput = {
    create?: XOR<CompanyCreateWithoutFilessInput, CompanyUncheckedCreateWithoutFilessInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFilessInput
    upsert?: CompanyUpsertWithoutFilessInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFilessInput, CompanyUpdateWithoutFilessInput>, CompanyUncheckedUpdateWithoutFilessInput>
  }

  export type FilesOptionsUpdateManyWithoutFileNestedInput = {
    create?: XOR<FilesOptionsCreateWithoutFileInput, FilesOptionsUncheckedCreateWithoutFileInput> | FilesOptionsCreateWithoutFileInput[] | FilesOptionsUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FilesOptionsCreateOrConnectWithoutFileInput | FilesOptionsCreateOrConnectWithoutFileInput[]
    upsert?: FilesOptionsUpsertWithWhereUniqueWithoutFileInput | FilesOptionsUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FilesOptionsCreateManyFileInputEnvelope
    set?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    disconnect?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    delete?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    connect?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    update?: FilesOptionsUpdateWithWhereUniqueWithoutFileInput | FilesOptionsUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FilesOptionsUpdateManyWithWhereWithoutFileInput | FilesOptionsUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FilesOptionsScalarWhereInput | FilesOptionsScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutFileListNestedInput = {
    create?: XOR<CampaignCreateWithoutFileListInput, CampaignUncheckedCreateWithoutFileListInput> | CampaignCreateWithoutFileListInput[] | CampaignUncheckedCreateWithoutFileListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutFileListInput | CampaignCreateOrConnectWithoutFileListInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutFileListInput | CampaignUpsertWithWhereUniqueWithoutFileListInput[]
    createMany?: CampaignCreateManyFileListInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutFileListInput | CampaignUpdateWithWhereUniqueWithoutFileListInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutFileListInput | CampaignUpdateManyWithWhereWithoutFileListInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type FilesOptionsUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<FilesOptionsCreateWithoutFileInput, FilesOptionsUncheckedCreateWithoutFileInput> | FilesOptionsCreateWithoutFileInput[] | FilesOptionsUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FilesOptionsCreateOrConnectWithoutFileInput | FilesOptionsCreateOrConnectWithoutFileInput[]
    upsert?: FilesOptionsUpsertWithWhereUniqueWithoutFileInput | FilesOptionsUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FilesOptionsCreateManyFileInputEnvelope
    set?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    disconnect?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    delete?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    connect?: FilesOptionsWhereUniqueInput | FilesOptionsWhereUniqueInput[]
    update?: FilesOptionsUpdateWithWhereUniqueWithoutFileInput | FilesOptionsUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FilesOptionsUpdateManyWithWhereWithoutFileInput | FilesOptionsUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FilesOptionsScalarWhereInput | FilesOptionsScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutFileListNestedInput = {
    create?: XOR<CampaignCreateWithoutFileListInput, CampaignUncheckedCreateWithoutFileListInput> | CampaignCreateWithoutFileListInput[] | CampaignUncheckedCreateWithoutFileListInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutFileListInput | CampaignCreateOrConnectWithoutFileListInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutFileListInput | CampaignUpsertWithWhereUniqueWithoutFileListInput[]
    createMany?: CampaignCreateManyFileListInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutFileListInput | CampaignUpdateWithWhereUniqueWithoutFileListInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutFileListInput | CampaignUpdateManyWithWhereWithoutFileListInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type FilesCreateNestedOneWithoutOptionsInput = {
    create?: XOR<FilesCreateWithoutOptionsInput, FilesUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: FilesCreateOrConnectWithoutOptionsInput
    connect?: FilesWhereUniqueInput
  }

  export type FilesUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<FilesCreateWithoutOptionsInput, FilesUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: FilesCreateOrConnectWithoutOptionsInput
    upsert?: FilesUpsertWithoutOptionsInput
    connect?: FilesWhereUniqueInput
    update?: XOR<XOR<FilesUpdateToOneWithWhereWithoutOptionsInput, FilesUpdateWithoutOptionsInput>, FilesUncheckedUpdateWithoutOptionsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Action_LogsCreateNestedOneWithoutSystem_LogsInput = {
    create?: XOR<Action_LogsCreateWithoutSystem_LogsInput, Action_LogsUncheckedCreateWithoutSystem_LogsInput>
    connectOrCreate?: Action_LogsCreateOrConnectWithoutSystem_LogsInput
    connect?: Action_LogsWhereUniqueInput
  }

  export type Action_LogsUpdateOneWithoutSystem_LogsNestedInput = {
    create?: XOR<Action_LogsCreateWithoutSystem_LogsInput, Action_LogsUncheckedCreateWithoutSystem_LogsInput>
    connectOrCreate?: Action_LogsCreateOrConnectWithoutSystem_LogsInput
    upsert?: Action_LogsUpsertWithoutSystem_LogsInput
    disconnect?: Action_LogsWhereInput | boolean
    delete?: Action_LogsWhereInput | boolean
    connect?: Action_LogsWhereUniqueInput
    update?: XOR<XOR<Action_LogsUpdateToOneWithWhereWithoutSystem_LogsInput, Action_LogsUpdateWithoutSystem_LogsInput>, Action_LogsUncheckedUpdateWithoutSystem_LogsInput>
  }

  export type UserCreateNestedOneWithoutAction_LogsInput = {
    create?: XOR<UserCreateWithoutAction_LogsInput, UserUncheckedCreateWithoutAction_LogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAction_LogsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutAction_LogsInput = {
    create?: XOR<TicketCreateWithoutAction_LogsInput, TicketUncheckedCreateWithoutAction_LogsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAction_LogsInput
    connect?: TicketWhereUniqueInput
  }

  export type System_LogsCreateNestedManyWithoutActionLogInput = {
    create?: XOR<System_LogsCreateWithoutActionLogInput, System_LogsUncheckedCreateWithoutActionLogInput> | System_LogsCreateWithoutActionLogInput[] | System_LogsUncheckedCreateWithoutActionLogInput[]
    connectOrCreate?: System_LogsCreateOrConnectWithoutActionLogInput | System_LogsCreateOrConnectWithoutActionLogInput[]
    createMany?: System_LogsCreateManyActionLogInputEnvelope
    connect?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
  }

  export type System_LogsUncheckedCreateNestedManyWithoutActionLogInput = {
    create?: XOR<System_LogsCreateWithoutActionLogInput, System_LogsUncheckedCreateWithoutActionLogInput> | System_LogsCreateWithoutActionLogInput[] | System_LogsUncheckedCreateWithoutActionLogInput[]
    connectOrCreate?: System_LogsCreateOrConnectWithoutActionLogInput | System_LogsCreateOrConnectWithoutActionLogInput[]
    createMany?: System_LogsCreateManyActionLogInputEnvelope
    connect?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAction_LogsNestedInput = {
    create?: XOR<UserCreateWithoutAction_LogsInput, UserUncheckedCreateWithoutAction_LogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAction_LogsInput
    upsert?: UserUpsertWithoutAction_LogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAction_LogsInput, UserUpdateWithoutAction_LogsInput>, UserUncheckedUpdateWithoutAction_LogsInput>
  }

  export type TicketUpdateOneWithoutAction_LogsNestedInput = {
    create?: XOR<TicketCreateWithoutAction_LogsInput, TicketUncheckedCreateWithoutAction_LogsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAction_LogsInput
    upsert?: TicketUpsertWithoutAction_LogsInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutAction_LogsInput, TicketUpdateWithoutAction_LogsInput>, TicketUncheckedUpdateWithoutAction_LogsInput>
  }

  export type System_LogsUpdateManyWithoutActionLogNestedInput = {
    create?: XOR<System_LogsCreateWithoutActionLogInput, System_LogsUncheckedCreateWithoutActionLogInput> | System_LogsCreateWithoutActionLogInput[] | System_LogsUncheckedCreateWithoutActionLogInput[]
    connectOrCreate?: System_LogsCreateOrConnectWithoutActionLogInput | System_LogsCreateOrConnectWithoutActionLogInput[]
    upsert?: System_LogsUpsertWithWhereUniqueWithoutActionLogInput | System_LogsUpsertWithWhereUniqueWithoutActionLogInput[]
    createMany?: System_LogsCreateManyActionLogInputEnvelope
    set?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    disconnect?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    delete?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    connect?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    update?: System_LogsUpdateWithWhereUniqueWithoutActionLogInput | System_LogsUpdateWithWhereUniqueWithoutActionLogInput[]
    updateMany?: System_LogsUpdateManyWithWhereWithoutActionLogInput | System_LogsUpdateManyWithWhereWithoutActionLogInput[]
    deleteMany?: System_LogsScalarWhereInput | System_LogsScalarWhereInput[]
  }

  export type System_LogsUncheckedUpdateManyWithoutActionLogNestedInput = {
    create?: XOR<System_LogsCreateWithoutActionLogInput, System_LogsUncheckedCreateWithoutActionLogInput> | System_LogsCreateWithoutActionLogInput[] | System_LogsUncheckedCreateWithoutActionLogInput[]
    connectOrCreate?: System_LogsCreateOrConnectWithoutActionLogInput | System_LogsCreateOrConnectWithoutActionLogInput[]
    upsert?: System_LogsUpsertWithWhereUniqueWithoutActionLogInput | System_LogsUpsertWithWhereUniqueWithoutActionLogInput[]
    createMany?: System_LogsCreateManyActionLogInputEnvelope
    set?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    disconnect?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    delete?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    connect?: System_LogsWhereUniqueInput | System_LogsWhereUniqueInput[]
    update?: System_LogsUpdateWithWhereUniqueWithoutActionLogInput | System_LogsUpdateWithWhereUniqueWithoutActionLogInput[]
    updateMany?: System_LogsUpdateManyWithWhereWithoutActionLogInput | System_LogsUpdateManyWithWhereWithoutActionLogInput[]
    deleteMany?: System_LogsScalarWhereInput | System_LogsScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutMessageInput = {
    create?: XOR<MessageCreateWithoutMessageInput, MessageUncheckedCreateWithoutMessageInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessageInput
    connect?: MessageWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    connect?: TicketWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutMessageInput = {
    create?: XOR<ContactCreateWithoutMessageInput, ContactUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ContactCreateOrConnectWithoutMessageInput
    connect?: ContactWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CompanyCreateWithoutMessagesInput, CompanyUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMessagesInput
    connect?: CompanyWhereUniqueInput
  }

  export type QueueCreateNestedOneWithoutMessageInput = {
    create?: XOR<QueueCreateWithoutMessageInput, QueueUncheckedCreateWithoutMessageInput>
    connectOrCreate?: QueueCreateOrConnectWithoutMessageInput
    connect?: QueueWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutQuotedMsgInput = {
    create?: XOR<MessageCreateWithoutQuotedMsgInput, MessageUncheckedCreateWithoutQuotedMsgInput> | MessageCreateWithoutQuotedMsgInput[] | MessageUncheckedCreateWithoutQuotedMsgInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQuotedMsgInput | MessageCreateOrConnectWithoutQuotedMsgInput[]
    createMany?: MessageCreateManyQuotedMsgInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutQuotedMsgInput = {
    create?: XOR<MessageCreateWithoutQuotedMsgInput, MessageUncheckedCreateWithoutQuotedMsgInput> | MessageCreateWithoutQuotedMsgInput[] | MessageUncheckedCreateWithoutQuotedMsgInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQuotedMsgInput | MessageCreateOrConnectWithoutQuotedMsgInput[]
    createMany?: MessageCreateManyQuotedMsgInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUpdateOneWithoutMessageNestedInput = {
    create?: XOR<MessageCreateWithoutMessageInput, MessageUncheckedCreateWithoutMessageInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessageInput
    upsert?: MessageUpsertWithoutMessageInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutMessageInput, MessageUpdateWithoutMessageInput>, MessageUncheckedUpdateWithoutMessageInput>
  }

  export type TicketUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    upsert?: TicketUpsertWithoutMessagesInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutMessagesInput, TicketUpdateWithoutMessagesInput>, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type ContactUpdateOneWithoutMessageNestedInput = {
    create?: XOR<ContactCreateWithoutMessageInput, ContactUncheckedCreateWithoutMessageInput>
    connectOrCreate?: ContactCreateOrConnectWithoutMessageInput
    upsert?: ContactUpsertWithoutMessageInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutMessageInput, ContactUpdateWithoutMessageInput>, ContactUncheckedUpdateWithoutMessageInput>
  }

  export type CompanyUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CompanyCreateWithoutMessagesInput, CompanyUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMessagesInput
    upsert?: CompanyUpsertWithoutMessagesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutMessagesInput, CompanyUpdateWithoutMessagesInput>, CompanyUncheckedUpdateWithoutMessagesInput>
  }

  export type QueueUpdateOneWithoutMessageNestedInput = {
    create?: XOR<QueueCreateWithoutMessageInput, QueueUncheckedCreateWithoutMessageInput>
    connectOrCreate?: QueueCreateOrConnectWithoutMessageInput
    upsert?: QueueUpsertWithoutMessageInput
    disconnect?: QueueWhereInput | boolean
    delete?: QueueWhereInput | boolean
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutMessageInput, QueueUpdateWithoutMessageInput>, QueueUncheckedUpdateWithoutMessageInput>
  }

  export type MessageUpdateManyWithoutQuotedMsgNestedInput = {
    create?: XOR<MessageCreateWithoutQuotedMsgInput, MessageUncheckedCreateWithoutQuotedMsgInput> | MessageCreateWithoutQuotedMsgInput[] | MessageUncheckedCreateWithoutQuotedMsgInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQuotedMsgInput | MessageCreateOrConnectWithoutQuotedMsgInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutQuotedMsgInput | MessageUpsertWithWhereUniqueWithoutQuotedMsgInput[]
    createMany?: MessageCreateManyQuotedMsgInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutQuotedMsgInput | MessageUpdateWithWhereUniqueWithoutQuotedMsgInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutQuotedMsgInput | MessageUpdateManyWithWhereWithoutQuotedMsgInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput = {
    create?: XOR<MessageCreateWithoutQuotedMsgInput, MessageUncheckedCreateWithoutQuotedMsgInput> | MessageCreateWithoutQuotedMsgInput[] | MessageUncheckedCreateWithoutQuotedMsgInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQuotedMsgInput | MessageCreateOrConnectWithoutQuotedMsgInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutQuotedMsgInput | MessageUpsertWithWhereUniqueWithoutQuotedMsgInput[]
    createMany?: MessageCreateManyQuotedMsgInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutQuotedMsgInput | MessageUpdateWithWhereUniqueWithoutQuotedMsgInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutQuotedMsgInput | MessageUpdateManyWithWhereWithoutQuotedMsgInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CompanyCreateNestedManyWithoutPlanInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateManyWithoutPlanNestedInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutPlanInput | CompanyUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutPlanInput | CompanyUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutPlanInput | CompanyUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput> | CompanyCreateWithoutPlanInput[] | CompanyUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutPlanInput | CompanyCreateOrConnectWithoutPlanInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutPlanInput | CompanyUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: CompanyCreateManyPlanInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutPlanInput | CompanyUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutPlanInput | CompanyUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type QueueCreateNestedOneWithoutPromptInput = {
    create?: XOR<QueueCreateWithoutPromptInput, QueueUncheckedCreateWithoutPromptInput>
    connectOrCreate?: QueueCreateOrConnectWithoutPromptInput
    connect?: QueueWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPromptsInput = {
    create?: XOR<CompanyCreateWithoutPromptsInput, CompanyUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPromptsInput
    connect?: CompanyWhereUniqueInput
  }

  export type WhatsappCreateNestedManyWithoutPromptInput = {
    create?: XOR<WhatsappCreateWithoutPromptInput, WhatsappUncheckedCreateWithoutPromptInput> | WhatsappCreateWithoutPromptInput[] | WhatsappUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutPromptInput | WhatsappCreateOrConnectWithoutPromptInput[]
    createMany?: WhatsappCreateManyPromptInputEnvelope
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutPromptInput = {
    create?: XOR<TicketCreateWithoutPromptInput, TicketUncheckedCreateWithoutPromptInput> | TicketCreateWithoutPromptInput[] | TicketUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPromptInput | TicketCreateOrConnectWithoutPromptInput[]
    createMany?: TicketCreateManyPromptInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type WhatsappUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<WhatsappCreateWithoutPromptInput, WhatsappUncheckedCreateWithoutPromptInput> | WhatsappCreateWithoutPromptInput[] | WhatsappUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutPromptInput | WhatsappCreateOrConnectWithoutPromptInput[]
    createMany?: WhatsappCreateManyPromptInputEnvelope
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<TicketCreateWithoutPromptInput, TicketUncheckedCreateWithoutPromptInput> | TicketCreateWithoutPromptInput[] | TicketUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPromptInput | TicketCreateOrConnectWithoutPromptInput[]
    createMany?: TicketCreateManyPromptInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueUpdateOneWithoutPromptNestedInput = {
    create?: XOR<QueueCreateWithoutPromptInput, QueueUncheckedCreateWithoutPromptInput>
    connectOrCreate?: QueueCreateOrConnectWithoutPromptInput
    upsert?: QueueUpsertWithoutPromptInput
    disconnect?: QueueWhereInput | boolean
    delete?: QueueWhereInput | boolean
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutPromptInput, QueueUpdateWithoutPromptInput>, QueueUncheckedUpdateWithoutPromptInput>
  }

  export type CompanyUpdateOneRequiredWithoutPromptsNestedInput = {
    create?: XOR<CompanyCreateWithoutPromptsInput, CompanyUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPromptsInput
    upsert?: CompanyUpsertWithoutPromptsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPromptsInput, CompanyUpdateWithoutPromptsInput>, CompanyUncheckedUpdateWithoutPromptsInput>
  }

  export type WhatsappUpdateManyWithoutPromptNestedInput = {
    create?: XOR<WhatsappCreateWithoutPromptInput, WhatsappUncheckedCreateWithoutPromptInput> | WhatsappCreateWithoutPromptInput[] | WhatsappUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutPromptInput | WhatsappCreateOrConnectWithoutPromptInput[]
    upsert?: WhatsappUpsertWithWhereUniqueWithoutPromptInput | WhatsappUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: WhatsappCreateManyPromptInputEnvelope
    set?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    disconnect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    delete?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    update?: WhatsappUpdateWithWhereUniqueWithoutPromptInput | WhatsappUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: WhatsappUpdateManyWithWhereWithoutPromptInput | WhatsappUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutPromptNestedInput = {
    create?: XOR<TicketCreateWithoutPromptInput, TicketUncheckedCreateWithoutPromptInput> | TicketCreateWithoutPromptInput[] | TicketUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPromptInput | TicketCreateOrConnectWithoutPromptInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPromptInput | TicketUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: TicketCreateManyPromptInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPromptInput | TicketUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPromptInput | TicketUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type WhatsappUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<WhatsappCreateWithoutPromptInput, WhatsappUncheckedCreateWithoutPromptInput> | WhatsappCreateWithoutPromptInput[] | WhatsappUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutPromptInput | WhatsappCreateOrConnectWithoutPromptInput[]
    upsert?: WhatsappUpsertWithWhereUniqueWithoutPromptInput | WhatsappUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: WhatsappCreateManyPromptInputEnvelope
    set?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    disconnect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    delete?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    update?: WhatsappUpdateWithWhereUniqueWithoutPromptInput | WhatsappUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: WhatsappUpdateManyWithWhereWithoutPromptInput | WhatsappUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<TicketCreateWithoutPromptInput, TicketUncheckedCreateWithoutPromptInput> | TicketCreateWithoutPromptInput[] | TicketUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPromptInput | TicketCreateOrConnectWithoutPromptInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPromptInput | TicketUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: TicketCreateManyPromptInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPromptInput | TicketUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPromptInput | TicketUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutQueueInput = {
    create?: XOR<CompanyCreateWithoutQueueInput, CompanyUncheckedCreateWithoutQueueInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQueueInput
    connect?: CompanyWhereUniqueInput
  }

  export type WhatsappCreateNestedManyWithoutQueuesInput = {
    create?: XOR<WhatsappCreateWithoutQueuesInput, WhatsappUncheckedCreateWithoutQueuesInput> | WhatsappCreateWithoutQueuesInput[] | WhatsappUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutQueuesInput | WhatsappCreateOrConnectWithoutQueuesInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutQueuesInput = {
    create?: XOR<UserCreateWithoutQueuesInput, UserUncheckedCreateWithoutQueuesInput> | UserCreateWithoutQueuesInput[] | UserUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutQueuesInput | UserCreateOrConnectWithoutQueuesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type QueueOptionCreateNestedManyWithoutQueueInput = {
    create?: XOR<QueueOptionCreateWithoutQueueInput, QueueOptionUncheckedCreateWithoutQueueInput> | QueueOptionCreateWithoutQueueInput[] | QueueOptionUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutQueueInput | QueueOptionCreateOrConnectWithoutQueueInput[]
    createMany?: QueueOptionCreateManyQueueInputEnvelope
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
  }

  export type QueueIntegrationsCreateNestedOneWithoutQueueInput = {
    create?: XOR<QueueIntegrationsCreateWithoutQueueInput, QueueIntegrationsUncheckedCreateWithoutQueueInput>
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutQueueInput
    connect?: QueueIntegrationsWhereUniqueInput
  }

  export type PromptCreateNestedManyWithoutQueueInput = {
    create?: XOR<PromptCreateWithoutQueueInput, PromptUncheckedCreateWithoutQueueInput> | PromptCreateWithoutQueueInput[] | PromptUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutQueueInput | PromptCreateOrConnectWithoutQueueInput[]
    createMany?: PromptCreateManyQueueInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type UserQueueCreateNestedManyWithoutQueueInput = {
    create?: XOR<UserQueueCreateWithoutQueueInput, UserQueueUncheckedCreateWithoutQueueInput> | UserQueueCreateWithoutQueueInput[] | UserQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutQueueInput | UserQueueCreateOrConnectWithoutQueueInput[]
    createMany?: UserQueueCreateManyQueueInputEnvelope
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
  }

  export type WhatsappQueueCreateNestedManyWithoutQueueInput = {
    create?: XOR<WhatsappQueueCreateWithoutQueueInput, WhatsappQueueUncheckedCreateWithoutQueueInput> | WhatsappQueueCreateWithoutQueueInput[] | WhatsappQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutQueueInput | WhatsappQueueCreateOrConnectWithoutQueueInput[]
    createMany?: WhatsappQueueCreateManyQueueInputEnvelope
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutQueueInput = {
    create?: XOR<TicketCreateWithoutQueueInput, TicketUncheckedCreateWithoutQueueInput> | TicketCreateWithoutQueueInput[] | TicketUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueInput | TicketCreateOrConnectWithoutQueueInput[]
    createMany?: TicketCreateManyQueueInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutQueueInput = {
    create?: XOR<MessageCreateWithoutQueueInput, MessageUncheckedCreateWithoutQueueInput> | MessageCreateWithoutQueueInput[] | MessageUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQueueInput | MessageCreateOrConnectWithoutQueueInput[]
    createMany?: MessageCreateManyQueueInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CompanyCreateNestedManyWithoutQueuesInput = {
    create?: XOR<CompanyCreateWithoutQueuesInput, CompanyUncheckedCreateWithoutQueuesInput> | CompanyCreateWithoutQueuesInput[] | CompanyUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutQueuesInput | CompanyCreateOrConnectWithoutQueuesInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type WhatsappUncheckedCreateNestedManyWithoutQueuesInput = {
    create?: XOR<WhatsappCreateWithoutQueuesInput, WhatsappUncheckedCreateWithoutQueuesInput> | WhatsappCreateWithoutQueuesInput[] | WhatsappUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutQueuesInput | WhatsappCreateOrConnectWithoutQueuesInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutQueuesInput = {
    create?: XOR<UserCreateWithoutQueuesInput, UserUncheckedCreateWithoutQueuesInput> | UserCreateWithoutQueuesInput[] | UserUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutQueuesInput | UserCreateOrConnectWithoutQueuesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type QueueOptionUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<QueueOptionCreateWithoutQueueInput, QueueOptionUncheckedCreateWithoutQueueInput> | QueueOptionCreateWithoutQueueInput[] | QueueOptionUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutQueueInput | QueueOptionCreateOrConnectWithoutQueueInput[]
    createMany?: QueueOptionCreateManyQueueInputEnvelope
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
  }

  export type PromptUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<PromptCreateWithoutQueueInput, PromptUncheckedCreateWithoutQueueInput> | PromptCreateWithoutQueueInput[] | PromptUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutQueueInput | PromptCreateOrConnectWithoutQueueInput[]
    createMany?: PromptCreateManyQueueInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type UserQueueUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<UserQueueCreateWithoutQueueInput, UserQueueUncheckedCreateWithoutQueueInput> | UserQueueCreateWithoutQueueInput[] | UserQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutQueueInput | UserQueueCreateOrConnectWithoutQueueInput[]
    createMany?: UserQueueCreateManyQueueInputEnvelope
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
  }

  export type WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<WhatsappQueueCreateWithoutQueueInput, WhatsappQueueUncheckedCreateWithoutQueueInput> | WhatsappQueueCreateWithoutQueueInput[] | WhatsappQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutQueueInput | WhatsappQueueCreateOrConnectWithoutQueueInput[]
    createMany?: WhatsappQueueCreateManyQueueInputEnvelope
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<TicketCreateWithoutQueueInput, TicketUncheckedCreateWithoutQueueInput> | TicketCreateWithoutQueueInput[] | TicketUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueInput | TicketCreateOrConnectWithoutQueueInput[]
    createMany?: TicketCreateManyQueueInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<MessageCreateWithoutQueueInput, MessageUncheckedCreateWithoutQueueInput> | MessageCreateWithoutQueueInput[] | MessageUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQueueInput | MessageCreateOrConnectWithoutQueueInput[]
    createMany?: MessageCreateManyQueueInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutQueuesInput = {
    create?: XOR<CompanyCreateWithoutQueuesInput, CompanyUncheckedCreateWithoutQueuesInput> | CompanyCreateWithoutQueuesInput[] | CompanyUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutQueuesInput | CompanyCreateOrConnectWithoutQueuesInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutQueueNestedInput = {
    create?: XOR<CompanyCreateWithoutQueueInput, CompanyUncheckedCreateWithoutQueueInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQueueInput
    upsert?: CompanyUpsertWithoutQueueInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutQueueInput, CompanyUpdateWithoutQueueInput>, CompanyUncheckedUpdateWithoutQueueInput>
  }

  export type WhatsappUpdateManyWithoutQueuesNestedInput = {
    create?: XOR<WhatsappCreateWithoutQueuesInput, WhatsappUncheckedCreateWithoutQueuesInput> | WhatsappCreateWithoutQueuesInput[] | WhatsappUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutQueuesInput | WhatsappCreateOrConnectWithoutQueuesInput[]
    upsert?: WhatsappUpsertWithWhereUniqueWithoutQueuesInput | WhatsappUpsertWithWhereUniqueWithoutQueuesInput[]
    set?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    disconnect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    delete?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    update?: WhatsappUpdateWithWhereUniqueWithoutQueuesInput | WhatsappUpdateWithWhereUniqueWithoutQueuesInput[]
    updateMany?: WhatsappUpdateManyWithWhereWithoutQueuesInput | WhatsappUpdateManyWithWhereWithoutQueuesInput[]
    deleteMany?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
  }

  export type UserUpdateManyWithoutQueuesNestedInput = {
    create?: XOR<UserCreateWithoutQueuesInput, UserUncheckedCreateWithoutQueuesInput> | UserCreateWithoutQueuesInput[] | UserUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutQueuesInput | UserCreateOrConnectWithoutQueuesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutQueuesInput | UserUpsertWithWhereUniqueWithoutQueuesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutQueuesInput | UserUpdateWithWhereUniqueWithoutQueuesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutQueuesInput | UserUpdateManyWithWhereWithoutQueuesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type QueueOptionUpdateManyWithoutQueueNestedInput = {
    create?: XOR<QueueOptionCreateWithoutQueueInput, QueueOptionUncheckedCreateWithoutQueueInput> | QueueOptionCreateWithoutQueueInput[] | QueueOptionUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutQueueInput | QueueOptionCreateOrConnectWithoutQueueInput[]
    upsert?: QueueOptionUpsertWithWhereUniqueWithoutQueueInput | QueueOptionUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: QueueOptionCreateManyQueueInputEnvelope
    set?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    disconnect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    delete?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    update?: QueueOptionUpdateWithWhereUniqueWithoutQueueInput | QueueOptionUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: QueueOptionUpdateManyWithWhereWithoutQueueInput | QueueOptionUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: QueueOptionScalarWhereInput | QueueOptionScalarWhereInput[]
  }

  export type QueueIntegrationsUpdateOneWithoutQueueNestedInput = {
    create?: XOR<QueueIntegrationsCreateWithoutQueueInput, QueueIntegrationsUncheckedCreateWithoutQueueInput>
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutQueueInput
    upsert?: QueueIntegrationsUpsertWithoutQueueInput
    disconnect?: QueueIntegrationsWhereInput | boolean
    delete?: QueueIntegrationsWhereInput | boolean
    connect?: QueueIntegrationsWhereUniqueInput
    update?: XOR<XOR<QueueIntegrationsUpdateToOneWithWhereWithoutQueueInput, QueueIntegrationsUpdateWithoutQueueInput>, QueueIntegrationsUncheckedUpdateWithoutQueueInput>
  }

  export type PromptUpdateManyWithoutQueueNestedInput = {
    create?: XOR<PromptCreateWithoutQueueInput, PromptUncheckedCreateWithoutQueueInput> | PromptCreateWithoutQueueInput[] | PromptUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutQueueInput | PromptCreateOrConnectWithoutQueueInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutQueueInput | PromptUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: PromptCreateManyQueueInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutQueueInput | PromptUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutQueueInput | PromptUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type UserQueueUpdateManyWithoutQueueNestedInput = {
    create?: XOR<UserQueueCreateWithoutQueueInput, UserQueueUncheckedCreateWithoutQueueInput> | UserQueueCreateWithoutQueueInput[] | UserQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutQueueInput | UserQueueCreateOrConnectWithoutQueueInput[]
    upsert?: UserQueueUpsertWithWhereUniqueWithoutQueueInput | UserQueueUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: UserQueueCreateManyQueueInputEnvelope
    set?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    disconnect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    delete?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    update?: UserQueueUpdateWithWhereUniqueWithoutQueueInput | UserQueueUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: UserQueueUpdateManyWithWhereWithoutQueueInput | UserQueueUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: UserQueueScalarWhereInput | UserQueueScalarWhereInput[]
  }

  export type WhatsappQueueUpdateManyWithoutQueueNestedInput = {
    create?: XOR<WhatsappQueueCreateWithoutQueueInput, WhatsappQueueUncheckedCreateWithoutQueueInput> | WhatsappQueueCreateWithoutQueueInput[] | WhatsappQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutQueueInput | WhatsappQueueCreateOrConnectWithoutQueueInput[]
    upsert?: WhatsappQueueUpsertWithWhereUniqueWithoutQueueInput | WhatsappQueueUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: WhatsappQueueCreateManyQueueInputEnvelope
    set?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    disconnect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    delete?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    update?: WhatsappQueueUpdateWithWhereUniqueWithoutQueueInput | WhatsappQueueUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: WhatsappQueueUpdateManyWithWhereWithoutQueueInput | WhatsappQueueUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: WhatsappQueueScalarWhereInput | WhatsappQueueScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutQueueNestedInput = {
    create?: XOR<TicketCreateWithoutQueueInput, TicketUncheckedCreateWithoutQueueInput> | TicketCreateWithoutQueueInput[] | TicketUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueInput | TicketCreateOrConnectWithoutQueueInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutQueueInput | TicketUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: TicketCreateManyQueueInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutQueueInput | TicketUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutQueueInput | TicketUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutQueueNestedInput = {
    create?: XOR<MessageCreateWithoutQueueInput, MessageUncheckedCreateWithoutQueueInput> | MessageCreateWithoutQueueInput[] | MessageUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQueueInput | MessageCreateOrConnectWithoutQueueInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutQueueInput | MessageUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: MessageCreateManyQueueInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutQueueInput | MessageUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutQueueInput | MessageUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CompanyUpdateManyWithoutQueuesNestedInput = {
    create?: XOR<CompanyCreateWithoutQueuesInput, CompanyUncheckedCreateWithoutQueuesInput> | CompanyCreateWithoutQueuesInput[] | CompanyUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutQueuesInput | CompanyCreateOrConnectWithoutQueuesInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutQueuesInput | CompanyUpsertWithWhereUniqueWithoutQueuesInput[]
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutQueuesInput | CompanyUpdateWithWhereUniqueWithoutQueuesInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutQueuesInput | CompanyUpdateManyWithWhereWithoutQueuesInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type WhatsappUncheckedUpdateManyWithoutQueuesNestedInput = {
    create?: XOR<WhatsappCreateWithoutQueuesInput, WhatsappUncheckedCreateWithoutQueuesInput> | WhatsappCreateWithoutQueuesInput[] | WhatsappUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: WhatsappCreateOrConnectWithoutQueuesInput | WhatsappCreateOrConnectWithoutQueuesInput[]
    upsert?: WhatsappUpsertWithWhereUniqueWithoutQueuesInput | WhatsappUpsertWithWhereUniqueWithoutQueuesInput[]
    set?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    disconnect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    delete?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    connect?: WhatsappWhereUniqueInput | WhatsappWhereUniqueInput[]
    update?: WhatsappUpdateWithWhereUniqueWithoutQueuesInput | WhatsappUpdateWithWhereUniqueWithoutQueuesInput[]
    updateMany?: WhatsappUpdateManyWithWhereWithoutQueuesInput | WhatsappUpdateManyWithWhereWithoutQueuesInput[]
    deleteMany?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutQueuesNestedInput = {
    create?: XOR<UserCreateWithoutQueuesInput, UserUncheckedCreateWithoutQueuesInput> | UserCreateWithoutQueuesInput[] | UserUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutQueuesInput | UserCreateOrConnectWithoutQueuesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutQueuesInput | UserUpsertWithWhereUniqueWithoutQueuesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutQueuesInput | UserUpdateWithWhereUniqueWithoutQueuesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutQueuesInput | UserUpdateManyWithWhereWithoutQueuesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type QueueOptionUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<QueueOptionCreateWithoutQueueInput, QueueOptionUncheckedCreateWithoutQueueInput> | QueueOptionCreateWithoutQueueInput[] | QueueOptionUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutQueueInput | QueueOptionCreateOrConnectWithoutQueueInput[]
    upsert?: QueueOptionUpsertWithWhereUniqueWithoutQueueInput | QueueOptionUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: QueueOptionCreateManyQueueInputEnvelope
    set?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    disconnect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    delete?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    update?: QueueOptionUpdateWithWhereUniqueWithoutQueueInput | QueueOptionUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: QueueOptionUpdateManyWithWhereWithoutQueueInput | QueueOptionUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: QueueOptionScalarWhereInput | QueueOptionScalarWhereInput[]
  }

  export type PromptUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<PromptCreateWithoutQueueInput, PromptUncheckedCreateWithoutQueueInput> | PromptCreateWithoutQueueInput[] | PromptUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutQueueInput | PromptCreateOrConnectWithoutQueueInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutQueueInput | PromptUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: PromptCreateManyQueueInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutQueueInput | PromptUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutQueueInput | PromptUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type UserQueueUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<UserQueueCreateWithoutQueueInput, UserQueueUncheckedCreateWithoutQueueInput> | UserQueueCreateWithoutQueueInput[] | UserQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutQueueInput | UserQueueCreateOrConnectWithoutQueueInput[]
    upsert?: UserQueueUpsertWithWhereUniqueWithoutQueueInput | UserQueueUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: UserQueueCreateManyQueueInputEnvelope
    set?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    disconnect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    delete?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    update?: UserQueueUpdateWithWhereUniqueWithoutQueueInput | UserQueueUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: UserQueueUpdateManyWithWhereWithoutQueueInput | UserQueueUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: UserQueueScalarWhereInput | UserQueueScalarWhereInput[]
  }

  export type WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<WhatsappQueueCreateWithoutQueueInput, WhatsappQueueUncheckedCreateWithoutQueueInput> | WhatsappQueueCreateWithoutQueueInput[] | WhatsappQueueUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutQueueInput | WhatsappQueueCreateOrConnectWithoutQueueInput[]
    upsert?: WhatsappQueueUpsertWithWhereUniqueWithoutQueueInput | WhatsappQueueUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: WhatsappQueueCreateManyQueueInputEnvelope
    set?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    disconnect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    delete?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    update?: WhatsappQueueUpdateWithWhereUniqueWithoutQueueInput | WhatsappQueueUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: WhatsappQueueUpdateManyWithWhereWithoutQueueInput | WhatsappQueueUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: WhatsappQueueScalarWhereInput | WhatsappQueueScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<TicketCreateWithoutQueueInput, TicketUncheckedCreateWithoutQueueInput> | TicketCreateWithoutQueueInput[] | TicketUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueInput | TicketCreateOrConnectWithoutQueueInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutQueueInput | TicketUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: TicketCreateManyQueueInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutQueueInput | TicketUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutQueueInput | TicketUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<MessageCreateWithoutQueueInput, MessageUncheckedCreateWithoutQueueInput> | MessageCreateWithoutQueueInput[] | MessageUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutQueueInput | MessageCreateOrConnectWithoutQueueInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutQueueInput | MessageUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: MessageCreateManyQueueInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutQueueInput | MessageUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutQueueInput | MessageUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutQueuesNestedInput = {
    create?: XOR<CompanyCreateWithoutQueuesInput, CompanyUncheckedCreateWithoutQueuesInput> | CompanyCreateWithoutQueuesInput[] | CompanyUncheckedCreateWithoutQueuesInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutQueuesInput | CompanyCreateOrConnectWithoutQueuesInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutQueuesInput | CompanyUpsertWithWhereUniqueWithoutQueuesInput[]
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutQueuesInput | CompanyUpdateWithWhereUniqueWithoutQueuesInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutQueuesInput | CompanyUpdateManyWithWhereWithoutQueuesInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutQueueIntegrationssInput = {
    create?: XOR<CompanyCreateWithoutQueueIntegrationssInput, CompanyUncheckedCreateWithoutQueueIntegrationssInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQueueIntegrationssInput
    connect?: CompanyWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutQueueIntegrationInput = {
    create?: XOR<TicketCreateWithoutQueueIntegrationInput, TicketUncheckedCreateWithoutQueueIntegrationInput> | TicketCreateWithoutQueueIntegrationInput[] | TicketUncheckedCreateWithoutQueueIntegrationInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueIntegrationInput | TicketCreateOrConnectWithoutQueueIntegrationInput[]
    createMany?: TicketCreateManyQueueIntegrationInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueCreateNestedManyWithoutQueueIntegrationsInput = {
    create?: XOR<QueueCreateWithoutQueueIntegrationsInput, QueueUncheckedCreateWithoutQueueIntegrationsInput> | QueueCreateWithoutQueueIntegrationsInput[] | QueueUncheckedCreateWithoutQueueIntegrationsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutQueueIntegrationsInput | QueueCreateOrConnectWithoutQueueIntegrationsInput[]
    createMany?: QueueCreateManyQueueIntegrationsInputEnvelope
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutQueueIntegrationInput = {
    create?: XOR<TicketCreateWithoutQueueIntegrationInput, TicketUncheckedCreateWithoutQueueIntegrationInput> | TicketCreateWithoutQueueIntegrationInput[] | TicketUncheckedCreateWithoutQueueIntegrationInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueIntegrationInput | TicketCreateOrConnectWithoutQueueIntegrationInput[]
    createMany?: TicketCreateManyQueueIntegrationInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueUncheckedCreateNestedManyWithoutQueueIntegrationsInput = {
    create?: XOR<QueueCreateWithoutQueueIntegrationsInput, QueueUncheckedCreateWithoutQueueIntegrationsInput> | QueueCreateWithoutQueueIntegrationsInput[] | QueueUncheckedCreateWithoutQueueIntegrationsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutQueueIntegrationsInput | QueueCreateOrConnectWithoutQueueIntegrationsInput[]
    createMany?: QueueCreateManyQueueIntegrationsInputEnvelope
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutQueueIntegrationssNestedInput = {
    create?: XOR<CompanyCreateWithoutQueueIntegrationssInput, CompanyUncheckedCreateWithoutQueueIntegrationssInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQueueIntegrationssInput
    upsert?: CompanyUpsertWithoutQueueIntegrationssInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutQueueIntegrationssInput, CompanyUpdateWithoutQueueIntegrationssInput>, CompanyUncheckedUpdateWithoutQueueIntegrationssInput>
  }

  export type TicketUpdateManyWithoutQueueIntegrationNestedInput = {
    create?: XOR<TicketCreateWithoutQueueIntegrationInput, TicketUncheckedCreateWithoutQueueIntegrationInput> | TicketCreateWithoutQueueIntegrationInput[] | TicketUncheckedCreateWithoutQueueIntegrationInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueIntegrationInput | TicketCreateOrConnectWithoutQueueIntegrationInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutQueueIntegrationInput | TicketUpsertWithWhereUniqueWithoutQueueIntegrationInput[]
    createMany?: TicketCreateManyQueueIntegrationInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutQueueIntegrationInput | TicketUpdateWithWhereUniqueWithoutQueueIntegrationInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutQueueIntegrationInput | TicketUpdateManyWithWhereWithoutQueueIntegrationInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueUpdateManyWithoutQueueIntegrationsNestedInput = {
    create?: XOR<QueueCreateWithoutQueueIntegrationsInput, QueueUncheckedCreateWithoutQueueIntegrationsInput> | QueueCreateWithoutQueueIntegrationsInput[] | QueueUncheckedCreateWithoutQueueIntegrationsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutQueueIntegrationsInput | QueueCreateOrConnectWithoutQueueIntegrationsInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutQueueIntegrationsInput | QueueUpsertWithWhereUniqueWithoutQueueIntegrationsInput[]
    createMany?: QueueCreateManyQueueIntegrationsInputEnvelope
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutQueueIntegrationsInput | QueueUpdateWithWhereUniqueWithoutQueueIntegrationsInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutQueueIntegrationsInput | QueueUpdateManyWithWhereWithoutQueueIntegrationsInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutQueueIntegrationNestedInput = {
    create?: XOR<TicketCreateWithoutQueueIntegrationInput, TicketUncheckedCreateWithoutQueueIntegrationInput> | TicketCreateWithoutQueueIntegrationInput[] | TicketUncheckedCreateWithoutQueueIntegrationInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueIntegrationInput | TicketCreateOrConnectWithoutQueueIntegrationInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutQueueIntegrationInput | TicketUpsertWithWhereUniqueWithoutQueueIntegrationInput[]
    createMany?: TicketCreateManyQueueIntegrationInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutQueueIntegrationInput | TicketUpdateWithWhereUniqueWithoutQueueIntegrationInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutQueueIntegrationInput | TicketUpdateManyWithWhereWithoutQueueIntegrationInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueUncheckedUpdateManyWithoutQueueIntegrationsNestedInput = {
    create?: XOR<QueueCreateWithoutQueueIntegrationsInput, QueueUncheckedCreateWithoutQueueIntegrationsInput> | QueueCreateWithoutQueueIntegrationsInput[] | QueueUncheckedCreateWithoutQueueIntegrationsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutQueueIntegrationsInput | QueueCreateOrConnectWithoutQueueIntegrationsInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutQueueIntegrationsInput | QueueUpsertWithWhereUniqueWithoutQueueIntegrationsInput[]
    createMany?: QueueCreateManyQueueIntegrationsInputEnvelope
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutQueueIntegrationsInput | QueueUpdateWithWhereUniqueWithoutQueueIntegrationsInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutQueueIntegrationsInput | QueueUpdateManyWithWhereWithoutQueueIntegrationsInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type QueueCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QueueCreateWithoutOptionsInput, QueueUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QueueCreateOrConnectWithoutOptionsInput
    connect?: QueueWhereUniqueInput
  }

  export type QueueOptionCreateNestedOneWithoutQueueOptionInput = {
    create?: XOR<QueueOptionCreateWithoutQueueOptionInput, QueueOptionUncheckedCreateWithoutQueueOptionInput>
    connectOrCreate?: QueueOptionCreateOrConnectWithoutQueueOptionInput
    connect?: QueueOptionWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutQueueOptionInput = {
    create?: XOR<TicketCreateWithoutQueueOptionInput, TicketUncheckedCreateWithoutQueueOptionInput> | TicketCreateWithoutQueueOptionInput[] | TicketUncheckedCreateWithoutQueueOptionInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueOptionInput | TicketCreateOrConnectWithoutQueueOptionInput[]
    createMany?: TicketCreateManyQueueOptionInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueOptionCreateNestedManyWithoutParentInput = {
    create?: XOR<QueueOptionCreateWithoutParentInput, QueueOptionUncheckedCreateWithoutParentInput> | QueueOptionCreateWithoutParentInput[] | QueueOptionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutParentInput | QueueOptionCreateOrConnectWithoutParentInput[]
    createMany?: QueueOptionCreateManyParentInputEnvelope
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutQueueOptionInput = {
    create?: XOR<TicketCreateWithoutQueueOptionInput, TicketUncheckedCreateWithoutQueueOptionInput> | TicketCreateWithoutQueueOptionInput[] | TicketUncheckedCreateWithoutQueueOptionInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueOptionInput | TicketCreateOrConnectWithoutQueueOptionInput[]
    createMany?: TicketCreateManyQueueOptionInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueOptionUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<QueueOptionCreateWithoutParentInput, QueueOptionUncheckedCreateWithoutParentInput> | QueueOptionCreateWithoutParentInput[] | QueueOptionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutParentInput | QueueOptionCreateOrConnectWithoutParentInput[]
    createMany?: QueueOptionCreateManyParentInputEnvelope
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
  }

  export type QueueUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QueueCreateWithoutOptionsInput, QueueUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QueueCreateOrConnectWithoutOptionsInput
    upsert?: QueueUpsertWithoutOptionsInput
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutOptionsInput, QueueUpdateWithoutOptionsInput>, QueueUncheckedUpdateWithoutOptionsInput>
  }

  export type QueueOptionUpdateOneWithoutQueueOptionNestedInput = {
    create?: XOR<QueueOptionCreateWithoutQueueOptionInput, QueueOptionUncheckedCreateWithoutQueueOptionInput>
    connectOrCreate?: QueueOptionCreateOrConnectWithoutQueueOptionInput
    upsert?: QueueOptionUpsertWithoutQueueOptionInput
    disconnect?: QueueOptionWhereInput | boolean
    delete?: QueueOptionWhereInput | boolean
    connect?: QueueOptionWhereUniqueInput
    update?: XOR<XOR<QueueOptionUpdateToOneWithWhereWithoutQueueOptionInput, QueueOptionUpdateWithoutQueueOptionInput>, QueueOptionUncheckedUpdateWithoutQueueOptionInput>
  }

  export type TicketUpdateManyWithoutQueueOptionNestedInput = {
    create?: XOR<TicketCreateWithoutQueueOptionInput, TicketUncheckedCreateWithoutQueueOptionInput> | TicketCreateWithoutQueueOptionInput[] | TicketUncheckedCreateWithoutQueueOptionInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueOptionInput | TicketCreateOrConnectWithoutQueueOptionInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutQueueOptionInput | TicketUpsertWithWhereUniqueWithoutQueueOptionInput[]
    createMany?: TicketCreateManyQueueOptionInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutQueueOptionInput | TicketUpdateWithWhereUniqueWithoutQueueOptionInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutQueueOptionInput | TicketUpdateManyWithWhereWithoutQueueOptionInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueOptionUpdateManyWithoutParentNestedInput = {
    create?: XOR<QueueOptionCreateWithoutParentInput, QueueOptionUncheckedCreateWithoutParentInput> | QueueOptionCreateWithoutParentInput[] | QueueOptionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutParentInput | QueueOptionCreateOrConnectWithoutParentInput[]
    upsert?: QueueOptionUpsertWithWhereUniqueWithoutParentInput | QueueOptionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: QueueOptionCreateManyParentInputEnvelope
    set?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    disconnect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    delete?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    update?: QueueOptionUpdateWithWhereUniqueWithoutParentInput | QueueOptionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: QueueOptionUpdateManyWithWhereWithoutParentInput | QueueOptionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: QueueOptionScalarWhereInput | QueueOptionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutQueueOptionNestedInput = {
    create?: XOR<TicketCreateWithoutQueueOptionInput, TicketUncheckedCreateWithoutQueueOptionInput> | TicketCreateWithoutQueueOptionInput[] | TicketUncheckedCreateWithoutQueueOptionInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutQueueOptionInput | TicketCreateOrConnectWithoutQueueOptionInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutQueueOptionInput | TicketUpsertWithWhereUniqueWithoutQueueOptionInput[]
    createMany?: TicketCreateManyQueueOptionInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutQueueOptionInput | TicketUpdateWithWhereUniqueWithoutQueueOptionInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutQueueOptionInput | TicketUpdateManyWithWhereWithoutQueueOptionInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueOptionUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<QueueOptionCreateWithoutParentInput, QueueOptionUncheckedCreateWithoutParentInput> | QueueOptionCreateWithoutParentInput[] | QueueOptionUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QueueOptionCreateOrConnectWithoutParentInput | QueueOptionCreateOrConnectWithoutParentInput[]
    upsert?: QueueOptionUpsertWithWhereUniqueWithoutParentInput | QueueOptionUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: QueueOptionCreateManyParentInputEnvelope
    set?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    disconnect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    delete?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    connect?: QueueOptionWhereUniqueInput | QueueOptionWhereUniqueInput[]
    update?: QueueOptionUpdateWithWhereUniqueWithoutParentInput | QueueOptionUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: QueueOptionUpdateManyWithWhereWithoutParentInput | QueueOptionUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: QueueOptionScalarWhereInput | QueueOptionScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutQuickMessagesInput = {
    create?: XOR<CompanyCreateWithoutQuickMessagesInput, CompanyUncheckedCreateWithoutQuickMessagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQuickMessagesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuickMessagesInput = {
    create?: XOR<UserCreateWithoutQuickMessagesInput, UserUncheckedCreateWithoutQuickMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutQuickMessagesNestedInput = {
    create?: XOR<CompanyCreateWithoutQuickMessagesInput, CompanyUncheckedCreateWithoutQuickMessagesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutQuickMessagesInput
    upsert?: CompanyUpsertWithoutQuickMessagesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutQuickMessagesInput, CompanyUpdateWithoutQuickMessagesInput>, CompanyUncheckedUpdateWithoutQuickMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutQuickMessagesNestedInput = {
    create?: XOR<UserCreateWithoutQuickMessagesInput, UserUncheckedCreateWithoutQuickMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuickMessagesInput
    upsert?: UserUpsertWithoutQuickMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuickMessagesInput, UserUpdateWithoutQuickMessagesInput>, UserUncheckedUpdateWithoutQuickMessagesInput>
  }

  export type CompanyCreateNestedOneWithoutRatingsInput = {
    create?: XOR<CompanyCreateWithoutRatingsInput, CompanyUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRatingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<CompanyCreateWithoutRatingsInput, CompanyUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutRatingsInput
    upsert?: CompanyUpsertWithoutRatingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutRatingsInput, CompanyUpdateWithoutRatingsInput>, CompanyUncheckedUpdateWithoutRatingsInput>
  }

  export type ContactCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<ContactCreateWithoutSchedulesInput, ContactUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutSchedulesInput
    connect?: ContactWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutScheduleInput = {
    create?: XOR<TicketCreateWithoutScheduleInput, TicketUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: TicketCreateOrConnectWithoutScheduleInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutScheduleInput = {
    create?: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduleInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSchedulesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<ContactCreateWithoutSchedulesInput, ContactUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutSchedulesInput
    upsert?: ContactUpsertWithoutSchedulesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutSchedulesInput, ContactUpdateWithoutSchedulesInput>, ContactUncheckedUpdateWithoutSchedulesInput>
  }

  export type TicketUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<TicketCreateWithoutScheduleInput, TicketUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: TicketCreateOrConnectWithoutScheduleInput
    upsert?: TicketUpsertWithoutScheduleInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutScheduleInput, TicketUpdateWithoutScheduleInput>, TicketUncheckedUpdateWithoutScheduleInput>
  }

  export type UserUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduleInput
    upsert?: UserUpsertWithoutScheduleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduleInput, UserUpdateWithoutScheduleInput>, UserUncheckedUpdateWithoutScheduleInput>
  }

  export type CompanyUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSchedulesInput
    upsert?: CompanyUpsertWithoutSchedulesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSchedulesInput, CompanyUpdateWithoutSchedulesInput>, CompanyUncheckedUpdateWithoutSchedulesInput>
  }

  export type CompanyCreateNestedOneWithoutSettingsInput = {
    create?: XOR<CompanyCreateWithoutSettingsInput, CompanyUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSettingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<CompanyCreateWithoutSettingsInput, CompanyUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSettingsInput
    upsert?: CompanyUpsertWithoutSettingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSettingsInput, CompanyUpdateWithoutSettingsInput>, CompanyUncheckedUpdateWithoutSettingsInput>
  }

  export type CompanyCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubscriptionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubscriptionsInput
    upsert?: CompanyUpsertWithoutSubscriptionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSubscriptionsInput, CompanyUpdateWithoutSubscriptionsInput>, CompanyUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CompanyCreateNestedOneWithoutTagsInput = {
    create?: XOR<CompanyCreateWithoutTagsInput, CompanyUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTagsInput
    connect?: CompanyWhereUniqueInput
  }

  export type TicketTagCreateNestedManyWithoutTagInput = {
    create?: XOR<TicketTagCreateWithoutTagInput, TicketTagUncheckedCreateWithoutTagInput> | TicketTagCreateWithoutTagInput[] | TicketTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTagInput | TicketTagCreateOrConnectWithoutTagInput[]
    createMany?: TicketTagCreateManyTagInputEnvelope
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TicketTagCreateWithoutTagInput, TicketTagUncheckedCreateWithoutTagInput> | TicketTagCreateWithoutTagInput[] | TicketTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTagInput | TicketTagCreateOrConnectWithoutTagInput[]
    createMany?: TicketTagCreateManyTagInputEnvelope
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CompanyCreateWithoutTagsInput, CompanyUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTagsInput
    upsert?: CompanyUpsertWithoutTagsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTagsInput, CompanyUpdateWithoutTagsInput>, CompanyUncheckedUpdateWithoutTagsInput>
  }

  export type TicketTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<TicketTagCreateWithoutTagInput, TicketTagUncheckedCreateWithoutTagInput> | TicketTagCreateWithoutTagInput[] | TicketTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTagInput | TicketTagCreateOrConnectWithoutTagInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTagInput | TicketTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TicketTagCreateManyTagInputEnvelope
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTagInput | TicketTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTagInput | TicketTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TicketTagCreateWithoutTagInput, TicketTagUncheckedCreateWithoutTagInput> | TicketTagCreateWithoutTagInput[] | TicketTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTagInput | TicketTagCreateOrConnectWithoutTagInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTagInput | TicketTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TicketTagCreateManyTagInputEnvelope
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTagInput | TicketTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTagInput | TicketTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput> | TicketCreateWithoutTagsInput[] | TicketUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTagsInput | TicketCreateOrConnectWithoutTagsInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTagsInput | TicketUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTagsInput | TicketUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTagsInput | TicketUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    connect?: ContactWhereUniqueInput
  }

  export type WhatsappCreateNestedOneWithoutTicketsInput = {
    create?: XOR<WhatsappCreateWithoutTicketsInput, WhatsappUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutTicketsInput
    connect?: WhatsappWhereUniqueInput
  }

  export type QueueCreateNestedOneWithoutTicketInput = {
    create?: XOR<QueueCreateWithoutTicketInput, QueueUncheckedCreateWithoutTicketInput>
    connectOrCreate?: QueueCreateOrConnectWithoutTicketInput
    connect?: QueueWhereUniqueInput
  }

  export type QueueOptionCreateNestedOneWithoutTicketInput = {
    create?: XOR<QueueOptionCreateWithoutTicketInput, QueueOptionUncheckedCreateWithoutTicketInput>
    connectOrCreate?: QueueOptionCreateOrConnectWithoutTicketInput
    connect?: QueueOptionWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<MessageCreateWithoutTicketInput, MessageUncheckedCreateWithoutTicketInput> | MessageCreateWithoutTicketInput[] | MessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutTicketInput | MessageCreateOrConnectWithoutTicketInput[]
    createMany?: MessageCreateManyTicketInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TicketTagCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketTagCreateWithoutTicketInput, TicketTagUncheckedCreateWithoutTicketInput> | TicketTagCreateWithoutTicketInput[] | TicketTagUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketInput | TicketTagCreateOrConnectWithoutTicketInput[]
    createMany?: TicketTagCreateManyTicketInputEnvelope
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutTicketsInput = {
    create?: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTicketsInput
    connect?: CompanyWhereUniqueInput
  }

  export type QueueIntegrationsCreateNestedOneWithoutTicketInput = {
    create?: XOR<QueueIntegrationsCreateWithoutTicketInput, QueueIntegrationsUncheckedCreateWithoutTicketInput>
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutTicketInput
    connect?: QueueIntegrationsWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutTicketInput = {
    create?: XOR<PromptCreateWithoutTicketInput, PromptUncheckedCreateWithoutTicketInput>
    connectOrCreate?: PromptCreateOrConnectWithoutTicketInput
    connect?: PromptWhereUniqueInput
  }

  export type UserRatingCreateNestedManyWithoutTicketInput = {
    create?: XOR<UserRatingCreateWithoutTicketInput, UserRatingUncheckedCreateWithoutTicketInput> | UserRatingCreateWithoutTicketInput[] | UserRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutTicketInput | UserRatingCreateOrConnectWithoutTicketInput[]
    createMany?: UserRatingCreateManyTicketInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type TicketTrackingCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketTrackingCreateWithoutTicketInput, TicketTrackingUncheckedCreateWithoutTicketInput> | TicketTrackingCreateWithoutTicketInput[] | TicketTrackingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutTicketInput | TicketTrackingCreateOrConnectWithoutTicketInput[]
    createMany?: TicketTrackingCreateManyTicketInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type TicketNoteCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutTicketInput = {
    create?: XOR<ScheduleCreateWithoutTicketInput, ScheduleUncheckedCreateWithoutTicketInput> | ScheduleCreateWithoutTicketInput[] | ScheduleUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTicketInput | ScheduleCreateOrConnectWithoutTicketInput[]
    createMany?: ScheduleCreateManyTicketInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type Action_LogsCreateNestedManyWithoutTicketInput = {
    create?: XOR<Action_LogsCreateWithoutTicketInput, Action_LogsUncheckedCreateWithoutTicketInput> | Action_LogsCreateWithoutTicketInput[] | Action_LogsUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutTicketInput | Action_LogsCreateOrConnectWithoutTicketInput[]
    createMany?: Action_LogsCreateManyTicketInputEnvelope
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<MessageCreateWithoutTicketInput, MessageUncheckedCreateWithoutTicketInput> | MessageCreateWithoutTicketInput[] | MessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutTicketInput | MessageCreateOrConnectWithoutTicketInput[]
    createMany?: MessageCreateManyTicketInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TicketTagUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketTagCreateWithoutTicketInput, TicketTagUncheckedCreateWithoutTicketInput> | TicketTagCreateWithoutTicketInput[] | TicketTagUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketInput | TicketTagCreateOrConnectWithoutTicketInput[]
    createMany?: TicketTagCreateManyTicketInputEnvelope
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type UserRatingUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<UserRatingCreateWithoutTicketInput, UserRatingUncheckedCreateWithoutTicketInput> | UserRatingCreateWithoutTicketInput[] | UserRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutTicketInput | UserRatingCreateOrConnectWithoutTicketInput[]
    createMany?: UserRatingCreateManyTicketInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type TicketTrackingUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketTrackingCreateWithoutTicketInput, TicketTrackingUncheckedCreateWithoutTicketInput> | TicketTrackingCreateWithoutTicketInput[] | TicketTrackingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutTicketInput | TicketTrackingCreateOrConnectWithoutTicketInput[]
    createMany?: TicketTrackingCreateManyTicketInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type TicketNoteUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<ScheduleCreateWithoutTicketInput, ScheduleUncheckedCreateWithoutTicketInput> | ScheduleCreateWithoutTicketInput[] | ScheduleUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTicketInput | ScheduleCreateOrConnectWithoutTicketInput[]
    createMany?: ScheduleCreateManyTicketInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type Action_LogsUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<Action_LogsCreateWithoutTicketInput, Action_LogsUncheckedCreateWithoutTicketInput> | Action_LogsCreateWithoutTicketInput[] | Action_LogsUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutTicketInput | Action_LogsCreateOrConnectWithoutTicketInput[]
    createMany?: Action_LogsCreateManyTicketInputEnvelope
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    upsert?: ContactUpsertWithoutTicketsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTicketsInput, ContactUpdateWithoutTicketsInput>, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type WhatsappUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<WhatsappCreateWithoutTicketsInput, WhatsappUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutTicketsInput
    upsert?: WhatsappUpsertWithoutTicketsInput
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutTicketsInput, WhatsappUpdateWithoutTicketsInput>, WhatsappUncheckedUpdateWithoutTicketsInput>
  }

  export type QueueUpdateOneRequiredWithoutTicketNestedInput = {
    create?: XOR<QueueCreateWithoutTicketInput, QueueUncheckedCreateWithoutTicketInput>
    connectOrCreate?: QueueCreateOrConnectWithoutTicketInput
    upsert?: QueueUpsertWithoutTicketInput
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutTicketInput, QueueUpdateWithoutTicketInput>, QueueUncheckedUpdateWithoutTicketInput>
  }

  export type QueueOptionUpdateOneRequiredWithoutTicketNestedInput = {
    create?: XOR<QueueOptionCreateWithoutTicketInput, QueueOptionUncheckedCreateWithoutTicketInput>
    connectOrCreate?: QueueOptionCreateOrConnectWithoutTicketInput
    upsert?: QueueOptionUpsertWithoutTicketInput
    connect?: QueueOptionWhereUniqueInput
    update?: XOR<XOR<QueueOptionUpdateToOneWithWhereWithoutTicketInput, QueueOptionUpdateWithoutTicketInput>, QueueOptionUncheckedUpdateWithoutTicketInput>
  }

  export type MessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<MessageCreateWithoutTicketInput, MessageUncheckedCreateWithoutTicketInput> | MessageCreateWithoutTicketInput[] | MessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutTicketInput | MessageCreateOrConnectWithoutTicketInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutTicketInput | MessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: MessageCreateManyTicketInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutTicketInput | MessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutTicketInput | MessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TicketTagUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketTagCreateWithoutTicketInput, TicketTagUncheckedCreateWithoutTicketInput> | TicketTagCreateWithoutTicketInput[] | TicketTagUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketInput | TicketTagCreateOrConnectWithoutTicketInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTicketInput | TicketTagUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketTagCreateManyTicketInputEnvelope
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTicketInput | TicketTagUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTicketInput | TicketTagUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TagUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTicketsInput | TagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTicketsInput | TagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTicketsInput | TagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTicketsInput
    upsert?: CompanyUpsertWithoutTicketsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTicketsInput, CompanyUpdateWithoutTicketsInput>, CompanyUncheckedUpdateWithoutTicketsInput>
  }

  export type QueueIntegrationsUpdateOneWithoutTicketNestedInput = {
    create?: XOR<QueueIntegrationsCreateWithoutTicketInput, QueueIntegrationsUncheckedCreateWithoutTicketInput>
    connectOrCreate?: QueueIntegrationsCreateOrConnectWithoutTicketInput
    upsert?: QueueIntegrationsUpsertWithoutTicketInput
    disconnect?: QueueIntegrationsWhereInput | boolean
    delete?: QueueIntegrationsWhereInput | boolean
    connect?: QueueIntegrationsWhereUniqueInput
    update?: XOR<XOR<QueueIntegrationsUpdateToOneWithWhereWithoutTicketInput, QueueIntegrationsUpdateWithoutTicketInput>, QueueIntegrationsUncheckedUpdateWithoutTicketInput>
  }

  export type PromptUpdateOneWithoutTicketNestedInput = {
    create?: XOR<PromptCreateWithoutTicketInput, PromptUncheckedCreateWithoutTicketInput>
    connectOrCreate?: PromptCreateOrConnectWithoutTicketInput
    upsert?: PromptUpsertWithoutTicketInput
    disconnect?: PromptWhereInput | boolean
    delete?: PromptWhereInput | boolean
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutTicketInput, PromptUpdateWithoutTicketInput>, PromptUncheckedUpdateWithoutTicketInput>
  }

  export type UserRatingUpdateManyWithoutTicketNestedInput = {
    create?: XOR<UserRatingCreateWithoutTicketInput, UserRatingUncheckedCreateWithoutTicketInput> | UserRatingCreateWithoutTicketInput[] | UserRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutTicketInput | UserRatingCreateOrConnectWithoutTicketInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutTicketInput | UserRatingUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: UserRatingCreateManyTicketInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutTicketInput | UserRatingUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutTicketInput | UserRatingUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type TicketTrackingUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutTicketInput, TicketTrackingUncheckedCreateWithoutTicketInput> | TicketTrackingCreateWithoutTicketInput[] | TicketTrackingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutTicketInput | TicketTrackingCreateOrConnectWithoutTicketInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutTicketInput | TicketTrackingUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketTrackingCreateManyTicketInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutTicketInput | TicketTrackingUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutTicketInput | TicketTrackingUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type TicketNoteUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutTicketInput | TicketNoteUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutTicketInput | TicketNoteUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutTicketInput | TicketNoteUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutTicketNestedInput = {
    create?: XOR<ScheduleCreateWithoutTicketInput, ScheduleUncheckedCreateWithoutTicketInput> | ScheduleCreateWithoutTicketInput[] | ScheduleUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTicketInput | ScheduleCreateOrConnectWithoutTicketInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutTicketInput | ScheduleUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: ScheduleCreateManyTicketInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutTicketInput | ScheduleUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutTicketInput | ScheduleUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type Action_LogsUpdateManyWithoutTicketNestedInput = {
    create?: XOR<Action_LogsCreateWithoutTicketInput, Action_LogsUncheckedCreateWithoutTicketInput> | Action_LogsCreateWithoutTicketInput[] | Action_LogsUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutTicketInput | Action_LogsCreateOrConnectWithoutTicketInput[]
    upsert?: Action_LogsUpsertWithWhereUniqueWithoutTicketInput | Action_LogsUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: Action_LogsCreateManyTicketInputEnvelope
    set?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    disconnect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    delete?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    update?: Action_LogsUpdateWithWhereUniqueWithoutTicketInput | Action_LogsUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: Action_LogsUpdateManyWithWhereWithoutTicketInput | Action_LogsUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: Action_LogsScalarWhereInput | Action_LogsScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<MessageCreateWithoutTicketInput, MessageUncheckedCreateWithoutTicketInput> | MessageCreateWithoutTicketInput[] | MessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutTicketInput | MessageCreateOrConnectWithoutTicketInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutTicketInput | MessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: MessageCreateManyTicketInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutTicketInput | MessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutTicketInput | MessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TicketTagUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketTagCreateWithoutTicketInput, TicketTagUncheckedCreateWithoutTicketInput> | TicketTagCreateWithoutTicketInput[] | TicketTagUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTagCreateOrConnectWithoutTicketInput | TicketTagCreateOrConnectWithoutTicketInput[]
    upsert?: TicketTagUpsertWithWhereUniqueWithoutTicketInput | TicketTagUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketTagCreateManyTicketInputEnvelope
    set?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    disconnect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    delete?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    connect?: TicketTagWhereUniqueInput | TicketTagWhereUniqueInput[]
    update?: TicketTagUpdateWithWhereUniqueWithoutTicketInput | TicketTagUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketTagUpdateManyWithWhereWithoutTicketInput | TicketTagUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput> | TagCreateWithoutTicketsInput[] | TagUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTicketsInput | TagCreateOrConnectWithoutTicketsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTicketsInput | TagUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTicketsInput | TagUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTicketsInput | TagUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type UserRatingUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<UserRatingCreateWithoutTicketInput, UserRatingUncheckedCreateWithoutTicketInput> | UserRatingCreateWithoutTicketInput[] | UserRatingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutTicketInput | UserRatingCreateOrConnectWithoutTicketInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutTicketInput | UserRatingUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: UserRatingCreateManyTicketInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutTicketInput | UserRatingUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutTicketInput | UserRatingUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutTicketInput, TicketTrackingUncheckedCreateWithoutTicketInput> | TicketTrackingCreateWithoutTicketInput[] | TicketTrackingUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutTicketInput | TicketTrackingCreateOrConnectWithoutTicketInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutTicketInput | TicketTrackingUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketTrackingCreateManyTicketInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutTicketInput | TicketTrackingUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutTicketInput | TicketTrackingUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type TicketNoteUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutTicketInput | TicketNoteUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutTicketInput | TicketNoteUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutTicketInput | TicketNoteUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<ScheduleCreateWithoutTicketInput, ScheduleUncheckedCreateWithoutTicketInput> | ScheduleCreateWithoutTicketInput[] | ScheduleUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTicketInput | ScheduleCreateOrConnectWithoutTicketInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutTicketInput | ScheduleUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: ScheduleCreateManyTicketInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutTicketInput | ScheduleUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutTicketInput | ScheduleUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type Action_LogsUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<Action_LogsCreateWithoutTicketInput, Action_LogsUncheckedCreateWithoutTicketInput> | Action_LogsCreateWithoutTicketInput[] | Action_LogsUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutTicketInput | Action_LogsCreateOrConnectWithoutTicketInput[]
    upsert?: Action_LogsUpsertWithWhereUniqueWithoutTicketInput | Action_LogsUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: Action_LogsCreateManyTicketInputEnvelope
    set?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    disconnect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    delete?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    update?: Action_LogsUpdateWithWhereUniqueWithoutTicketInput | Action_LogsUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: Action_LogsUpdateManyWithWhereWithoutTicketInput | Action_LogsUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: Action_LogsScalarWhereInput | Action_LogsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTicketNoteInput = {
    create?: XOR<UserCreateWithoutTicketNoteInput, UserUncheckedCreateWithoutTicketNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketNoteInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutTicketNoteInput = {
    create?: XOR<ContactCreateWithoutTicketNoteInput, ContactUncheckedCreateWithoutTicketNoteInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketNoteInput
    connect?: ContactWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutTicketNoteInput = {
    create?: XOR<TicketCreateWithoutTicketNoteInput, TicketUncheckedCreateWithoutTicketNoteInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketNoteInput
    connect?: TicketWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTicketNoteNestedInput = {
    create?: XOR<UserCreateWithoutTicketNoteInput, UserUncheckedCreateWithoutTicketNoteInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketNoteInput
    upsert?: UserUpsertWithoutTicketNoteInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketNoteInput, UserUpdateWithoutTicketNoteInput>, UserUncheckedUpdateWithoutTicketNoteInput>
  }

  export type ContactUpdateOneRequiredWithoutTicketNoteNestedInput = {
    create?: XOR<ContactCreateWithoutTicketNoteInput, ContactUncheckedCreateWithoutTicketNoteInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketNoteInput
    upsert?: ContactUpsertWithoutTicketNoteInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTicketNoteInput, ContactUpdateWithoutTicketNoteInput>, ContactUncheckedUpdateWithoutTicketNoteInput>
  }

  export type TicketUpdateOneRequiredWithoutTicketNoteNestedInput = {
    create?: XOR<TicketCreateWithoutTicketNoteInput, TicketUncheckedCreateWithoutTicketNoteInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketNoteInput
    upsert?: TicketUpsertWithoutTicketNoteInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicketNoteInput, TicketUpdateWithoutTicketNoteInput>, TicketUncheckedUpdateWithoutTicketNoteInput>
  }

  export type TicketCreateNestedOneWithoutTicketTagsInput = {
    create?: XOR<TicketCreateWithoutTicketTagsInput, TicketUncheckedCreateWithoutTicketTagsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTagsInput
    connect?: TicketWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTicketTagsInput = {
    create?: XOR<TagCreateWithoutTicketTagsInput, TagUncheckedCreateWithoutTicketTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTicketTagsInput
    connect?: TagWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutTicketTagsNestedInput = {
    create?: XOR<TicketCreateWithoutTicketTagsInput, TicketUncheckedCreateWithoutTicketTagsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTagsInput
    upsert?: TicketUpsertWithoutTicketTagsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicketTagsInput, TicketUpdateWithoutTicketTagsInput>, TicketUncheckedUpdateWithoutTicketTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTicketTagsNestedInput = {
    create?: XOR<TagCreateWithoutTicketTagsInput, TagUncheckedCreateWithoutTicketTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTicketTagsInput
    upsert?: TagUpsertWithoutTicketTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTicketTagsInput, TagUpdateWithoutTicketTagsInput>, TagUncheckedUpdateWithoutTicketTagsInput>
  }

  export type TicketCreateNestedOneWithoutTicketTrackingInput = {
    create?: XOR<TicketCreateWithoutTicketTrackingInput, TicketUncheckedCreateWithoutTicketTrackingInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTrackingInput
    connect?: TicketWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTicketTrackingsInput = {
    create?: XOR<CompanyCreateWithoutTicketTrackingsInput, CompanyUncheckedCreateWithoutTicketTrackingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTicketTrackingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type WhatsappCreateNestedOneWithoutTicketTrackingInput = {
    create?: XOR<WhatsappCreateWithoutTicketTrackingInput, WhatsappUncheckedCreateWithoutTicketTrackingInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutTicketTrackingInput
    connect?: WhatsappWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketTrackingInput = {
    create?: XOR<UserCreateWithoutTicketTrackingInput, UserUncheckedCreateWithoutTicketTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketTrackingInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutTicketTrackingNestedInput = {
    create?: XOR<TicketCreateWithoutTicketTrackingInput, TicketUncheckedCreateWithoutTicketTrackingInput>
    connectOrCreate?: TicketCreateOrConnectWithoutTicketTrackingInput
    upsert?: TicketUpsertWithoutTicketTrackingInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutTicketTrackingInput, TicketUpdateWithoutTicketTrackingInput>, TicketUncheckedUpdateWithoutTicketTrackingInput>
  }

  export type CompanyUpdateOneRequiredWithoutTicketTrackingsNestedInput = {
    create?: XOR<CompanyCreateWithoutTicketTrackingsInput, CompanyUncheckedCreateWithoutTicketTrackingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTicketTrackingsInput
    upsert?: CompanyUpsertWithoutTicketTrackingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTicketTrackingsInput, CompanyUpdateWithoutTicketTrackingsInput>, CompanyUncheckedUpdateWithoutTicketTrackingsInput>
  }

  export type WhatsappUpdateOneWithoutTicketTrackingNestedInput = {
    create?: XOR<WhatsappCreateWithoutTicketTrackingInput, WhatsappUncheckedCreateWithoutTicketTrackingInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutTicketTrackingInput
    upsert?: WhatsappUpsertWithoutTicketTrackingInput
    disconnect?: WhatsappWhereInput | boolean
    delete?: WhatsappWhereInput | boolean
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutTicketTrackingInput, WhatsappUpdateWithoutTicketTrackingInput>, WhatsappUncheckedUpdateWithoutTicketTrackingInput>
  }

  export type UserUpdateOneWithoutTicketTrackingNestedInput = {
    create?: XOR<UserCreateWithoutTicketTrackingInput, UserUncheckedCreateWithoutTicketTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketTrackingInput
    upsert?: UserUpsertWithoutTicketTrackingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketTrackingInput, UserUpdateWithoutTicketTrackingInput>, UserUncheckedUpdateWithoutTicketTrackingInput>
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type WhatsappCreateNestedOneWithoutUserInput = {
    create?: XOR<WhatsappCreateWithoutUserInput, WhatsappUncheckedCreateWithoutUserInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutUserInput
    connect?: WhatsappWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueCreateNestedManyWithoutUsersInput = {
    create?: XOR<QueueCreateWithoutUsersInput, QueueUncheckedCreateWithoutUsersInput> | QueueCreateWithoutUsersInput[] | QueueUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutUsersInput | QueueCreateOrConnectWithoutUsersInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type QuickMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<QuickMessageCreateWithoutUserInput, QuickMessageUncheckedCreateWithoutUserInput> | QuickMessageCreateWithoutUserInput[] | QuickMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutUserInput | QuickMessageCreateOrConnectWithoutUserInput[]
    createMany?: QuickMessageCreateManyUserInputEnvelope
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
  }

  export type ChatUserCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatUserCreateWithoutUserInput, ChatUserUncheckedCreateWithoutUserInput> | ChatUserCreateWithoutUserInput[] | ChatUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutUserInput | ChatUserCreateOrConnectWithoutUserInput[]
    createMany?: ChatUserCreateManyUserInputEnvelope
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
  }

  export type UserQueueCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQueueCreateWithoutUserInput, UserQueueUncheckedCreateWithoutUserInput> | UserQueueCreateWithoutUserInput[] | UserQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutUserInput | UserQueueCreateOrConnectWithoutUserInput[]
    createMany?: UserQueueCreateManyUserInputEnvelope
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
  }

  export type UserRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRatingCreateWithoutUserInput, UserRatingUncheckedCreateWithoutUserInput> | UserRatingCreateWithoutUserInput[] | UserRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutUserInput | UserRatingCreateOrConnectWithoutUserInput[]
    createMany?: UserRatingCreateManyUserInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type TicketTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketTrackingCreateWithoutUserInput, TicketTrackingUncheckedCreateWithoutUserInput> | TicketTrackingCreateWithoutUserInput[] | TicketTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutUserInput | TicketTrackingCreateOrConnectWithoutUserInput[]
    createMany?: TicketTrackingCreateManyUserInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type TicketNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketNoteCreateWithoutUserInput, TicketNoteUncheckedCreateWithoutUserInput> | TicketNoteCreateWithoutUserInput[] | TicketNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutUserInput | TicketNoteCreateOrConnectWithoutUserInput[]
    createMany?: TicketNoteCreateManyUserInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChatCreateWithoutOwnerInput, ChatUncheckedCreateWithoutOwnerInput> | ChatCreateWithoutOwnerInput[] | ChatUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutOwnerInput | ChatCreateOrConnectWithoutOwnerInput[]
    createMany?: ChatCreateManyOwnerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type Action_LogsCreateNestedManyWithoutUserInput = {
    create?: XOR<Action_LogsCreateWithoutUserInput, Action_LogsUncheckedCreateWithoutUserInput> | Action_LogsCreateWithoutUserInput[] | Action_LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutUserInput | Action_LogsCreateOrConnectWithoutUserInput[]
    createMany?: Action_LogsCreateManyUserInputEnvelope
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<QueueCreateWithoutUsersInput, QueueUncheckedCreateWithoutUsersInput> | QueueCreateWithoutUsersInput[] | QueueUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutUsersInput | QueueCreateOrConnectWithoutUsersInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type QuickMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuickMessageCreateWithoutUserInput, QuickMessageUncheckedCreateWithoutUserInput> | QuickMessageCreateWithoutUserInput[] | QuickMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutUserInput | QuickMessageCreateOrConnectWithoutUserInput[]
    createMany?: QuickMessageCreateManyUserInputEnvelope
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
  }

  export type ChatUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatUserCreateWithoutUserInput, ChatUserUncheckedCreateWithoutUserInput> | ChatUserCreateWithoutUserInput[] | ChatUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutUserInput | ChatUserCreateOrConnectWithoutUserInput[]
    createMany?: ChatUserCreateManyUserInputEnvelope
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
  }

  export type UserQueueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserQueueCreateWithoutUserInput, UserQueueUncheckedCreateWithoutUserInput> | UserQueueCreateWithoutUserInput[] | UserQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutUserInput | UserQueueCreateOrConnectWithoutUserInput[]
    createMany?: UserQueueCreateManyUserInputEnvelope
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
  }

  export type UserRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRatingCreateWithoutUserInput, UserRatingUncheckedCreateWithoutUserInput> | UserRatingCreateWithoutUserInput[] | UserRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutUserInput | UserRatingCreateOrConnectWithoutUserInput[]
    createMany?: UserRatingCreateManyUserInputEnvelope
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
  }

  export type TicketTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketTrackingCreateWithoutUserInput, TicketTrackingUncheckedCreateWithoutUserInput> | TicketTrackingCreateWithoutUserInput[] | TicketTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutUserInput | TicketTrackingCreateOrConnectWithoutUserInput[]
    createMany?: TicketTrackingCreateManyUserInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type TicketNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketNoteCreateWithoutUserInput, TicketNoteUncheckedCreateWithoutUserInput> | TicketNoteCreateWithoutUserInput[] | TicketNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutUserInput | TicketNoteCreateOrConnectWithoutUserInput[]
    createMany?: TicketNoteCreateManyUserInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChatCreateWithoutOwnerInput, ChatUncheckedCreateWithoutOwnerInput> | ChatCreateWithoutOwnerInput[] | ChatUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutOwnerInput | ChatCreateOrConnectWithoutOwnerInput[]
    createMany?: ChatCreateManyOwnerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type Action_LogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Action_LogsCreateWithoutUserInput, Action_LogsUncheckedCreateWithoutUserInput> | Action_LogsCreateWithoutUserInput[] | Action_LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutUserInput | Action_LogsCreateOrConnectWithoutUserInput[]
    createMany?: Action_LogsCreateManyUserInputEnvelope
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type WhatsappUpdateOneWithoutUserNestedInput = {
    create?: XOR<WhatsappCreateWithoutUserInput, WhatsappUncheckedCreateWithoutUserInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutUserInput
    upsert?: WhatsappUpsertWithoutUserInput
    disconnect?: WhatsappWhereInput | boolean
    delete?: WhatsappWhereInput | boolean
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutUserInput, WhatsappUpdateWithoutUserInput>, WhatsappUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueUpdateManyWithoutUsersNestedInput = {
    create?: XOR<QueueCreateWithoutUsersInput, QueueUncheckedCreateWithoutUsersInput> | QueueCreateWithoutUsersInput[] | QueueUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutUsersInput | QueueCreateOrConnectWithoutUsersInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutUsersInput | QueueUpsertWithWhereUniqueWithoutUsersInput[]
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutUsersInput | QueueUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutUsersInput | QueueUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type QuickMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuickMessageCreateWithoutUserInput, QuickMessageUncheckedCreateWithoutUserInput> | QuickMessageCreateWithoutUserInput[] | QuickMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutUserInput | QuickMessageCreateOrConnectWithoutUserInput[]
    upsert?: QuickMessageUpsertWithWhereUniqueWithoutUserInput | QuickMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuickMessageCreateManyUserInputEnvelope
    set?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    disconnect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    delete?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    update?: QuickMessageUpdateWithWhereUniqueWithoutUserInput | QuickMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuickMessageUpdateManyWithWhereWithoutUserInput | QuickMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuickMessageScalarWhereInput | QuickMessageScalarWhereInput[]
  }

  export type ChatUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatUserCreateWithoutUserInput, ChatUserUncheckedCreateWithoutUserInput> | ChatUserCreateWithoutUserInput[] | ChatUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutUserInput | ChatUserCreateOrConnectWithoutUserInput[]
    upsert?: ChatUserUpsertWithWhereUniqueWithoutUserInput | ChatUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatUserCreateManyUserInputEnvelope
    set?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    disconnect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    delete?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    update?: ChatUserUpdateWithWhereUniqueWithoutUserInput | ChatUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUserUpdateManyWithWhereWithoutUserInput | ChatUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatUserScalarWhereInput | ChatUserScalarWhereInput[]
  }

  export type UserQueueUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQueueCreateWithoutUserInput, UserQueueUncheckedCreateWithoutUserInput> | UserQueueCreateWithoutUserInput[] | UserQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutUserInput | UserQueueCreateOrConnectWithoutUserInput[]
    upsert?: UserQueueUpsertWithWhereUniqueWithoutUserInput | UserQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQueueCreateManyUserInputEnvelope
    set?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    disconnect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    delete?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    update?: UserQueueUpdateWithWhereUniqueWithoutUserInput | UserQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQueueUpdateManyWithWhereWithoutUserInput | UserQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQueueScalarWhereInput | UserQueueScalarWhereInput[]
  }

  export type UserRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRatingCreateWithoutUserInput, UserRatingUncheckedCreateWithoutUserInput> | UserRatingCreateWithoutUserInput[] | UserRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutUserInput | UserRatingCreateOrConnectWithoutUserInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutUserInput | UserRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRatingCreateManyUserInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutUserInput | UserRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutUserInput | UserRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type TicketTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutUserInput, TicketTrackingUncheckedCreateWithoutUserInput> | TicketTrackingCreateWithoutUserInput[] | TicketTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutUserInput | TicketTrackingCreateOrConnectWithoutUserInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutUserInput | TicketTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketTrackingCreateManyUserInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutUserInput | TicketTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutUserInput | TicketTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type TicketNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketNoteCreateWithoutUserInput, TicketNoteUncheckedCreateWithoutUserInput> | TicketNoteCreateWithoutUserInput[] | TicketNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutUserInput | TicketNoteCreateOrConnectWithoutUserInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutUserInput | TicketNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketNoteCreateManyUserInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutUserInput | TicketNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutUserInput | TicketNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChatCreateWithoutOwnerInput, ChatUncheckedCreateWithoutOwnerInput> | ChatCreateWithoutOwnerInput[] | ChatUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutOwnerInput | ChatCreateOrConnectWithoutOwnerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutOwnerInput | ChatUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChatCreateManyOwnerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutOwnerInput | ChatUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutOwnerInput | ChatUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type Action_LogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Action_LogsCreateWithoutUserInput, Action_LogsUncheckedCreateWithoutUserInput> | Action_LogsCreateWithoutUserInput[] | Action_LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutUserInput | Action_LogsCreateOrConnectWithoutUserInput[]
    upsert?: Action_LogsUpsertWithWhereUniqueWithoutUserInput | Action_LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Action_LogsCreateManyUserInputEnvelope
    set?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    disconnect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    delete?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    update?: Action_LogsUpdateWithWhereUniqueWithoutUserInput | Action_LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Action_LogsUpdateManyWithWhereWithoutUserInput | Action_LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Action_LogsScalarWhereInput | Action_LogsScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<QueueCreateWithoutUsersInput, QueueUncheckedCreateWithoutUsersInput> | QueueCreateWithoutUsersInput[] | QueueUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutUsersInput | QueueCreateOrConnectWithoutUsersInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutUsersInput | QueueUpsertWithWhereUniqueWithoutUsersInput[]
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutUsersInput | QueueUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutUsersInput | QueueUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type QuickMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuickMessageCreateWithoutUserInput, QuickMessageUncheckedCreateWithoutUserInput> | QuickMessageCreateWithoutUserInput[] | QuickMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuickMessageCreateOrConnectWithoutUserInput | QuickMessageCreateOrConnectWithoutUserInput[]
    upsert?: QuickMessageUpsertWithWhereUniqueWithoutUserInput | QuickMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuickMessageCreateManyUserInputEnvelope
    set?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    disconnect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    delete?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    connect?: QuickMessageWhereUniqueInput | QuickMessageWhereUniqueInput[]
    update?: QuickMessageUpdateWithWhereUniqueWithoutUserInput | QuickMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuickMessageUpdateManyWithWhereWithoutUserInput | QuickMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuickMessageScalarWhereInput | QuickMessageScalarWhereInput[]
  }

  export type ChatUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatUserCreateWithoutUserInput, ChatUserUncheckedCreateWithoutUserInput> | ChatUserCreateWithoutUserInput[] | ChatUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatUserCreateOrConnectWithoutUserInput | ChatUserCreateOrConnectWithoutUserInput[]
    upsert?: ChatUserUpsertWithWhereUniqueWithoutUserInput | ChatUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatUserCreateManyUserInputEnvelope
    set?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    disconnect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    delete?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    connect?: ChatUserWhereUniqueInput | ChatUserWhereUniqueInput[]
    update?: ChatUserUpdateWithWhereUniqueWithoutUserInput | ChatUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUserUpdateManyWithWhereWithoutUserInput | ChatUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatUserScalarWhereInput | ChatUserScalarWhereInput[]
  }

  export type UserQueueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserQueueCreateWithoutUserInput, UserQueueUncheckedCreateWithoutUserInput> | UserQueueCreateWithoutUserInput[] | UserQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserQueueCreateOrConnectWithoutUserInput | UserQueueCreateOrConnectWithoutUserInput[]
    upsert?: UserQueueUpsertWithWhereUniqueWithoutUserInput | UserQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserQueueCreateManyUserInputEnvelope
    set?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    disconnect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    delete?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    connect?: UserQueueWhereUniqueInput | UserQueueWhereUniqueInput[]
    update?: UserQueueUpdateWithWhereUniqueWithoutUserInput | UserQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserQueueUpdateManyWithWhereWithoutUserInput | UserQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserQueueScalarWhereInput | UserQueueScalarWhereInput[]
  }

  export type UserRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRatingCreateWithoutUserInput, UserRatingUncheckedCreateWithoutUserInput> | UserRatingCreateWithoutUserInput[] | UserRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRatingCreateOrConnectWithoutUserInput | UserRatingCreateOrConnectWithoutUserInput[]
    upsert?: UserRatingUpsertWithWhereUniqueWithoutUserInput | UserRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRatingCreateManyUserInputEnvelope
    set?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    disconnect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    delete?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    connect?: UserRatingWhereUniqueInput | UserRatingWhereUniqueInput[]
    update?: UserRatingUpdateWithWhereUniqueWithoutUserInput | UserRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRatingUpdateManyWithWhereWithoutUserInput | UserRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
  }

  export type TicketTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutUserInput, TicketTrackingUncheckedCreateWithoutUserInput> | TicketTrackingCreateWithoutUserInput[] | TicketTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutUserInput | TicketTrackingCreateOrConnectWithoutUserInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutUserInput | TicketTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketTrackingCreateManyUserInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutUserInput | TicketTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutUserInput | TicketTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type TicketNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketNoteCreateWithoutUserInput, TicketNoteUncheckedCreateWithoutUserInput> | TicketNoteCreateWithoutUserInput[] | TicketNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutUserInput | TicketNoteCreateOrConnectWithoutUserInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutUserInput | TicketNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketNoteCreateManyUserInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutUserInput | TicketNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutUserInput | TicketNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChatCreateWithoutOwnerInput, ChatUncheckedCreateWithoutOwnerInput> | ChatCreateWithoutOwnerInput[] | ChatUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutOwnerInput | ChatCreateOrConnectWithoutOwnerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutOwnerInput | ChatUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChatCreateManyOwnerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutOwnerInput | ChatUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutOwnerInput | ChatUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type Action_LogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Action_LogsCreateWithoutUserInput, Action_LogsUncheckedCreateWithoutUserInput> | Action_LogsCreateWithoutUserInput[] | Action_LogsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Action_LogsCreateOrConnectWithoutUserInput | Action_LogsCreateOrConnectWithoutUserInput[]
    upsert?: Action_LogsUpsertWithWhereUniqueWithoutUserInput | Action_LogsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Action_LogsCreateManyUserInputEnvelope
    set?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    disconnect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    delete?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    connect?: Action_LogsWhereUniqueInput | Action_LogsWhereUniqueInput[]
    update?: Action_LogsUpdateWithWhereUniqueWithoutUserInput | Action_LogsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Action_LogsUpdateManyWithWhereWithoutUserInput | Action_LogsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Action_LogsScalarWhereInput | Action_LogsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserQueueInput = {
    create?: XOR<UserCreateWithoutUserQueueInput, UserUncheckedCreateWithoutUserQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserQueueInput
    connect?: UserWhereUniqueInput
  }

  export type QueueCreateNestedOneWithoutUserQueueInput = {
    create?: XOR<QueueCreateWithoutUserQueueInput, QueueUncheckedCreateWithoutUserQueueInput>
    connectOrCreate?: QueueCreateOrConnectWithoutUserQueueInput
    connect?: QueueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserQueueNestedInput = {
    create?: XOR<UserCreateWithoutUserQueueInput, UserUncheckedCreateWithoutUserQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserQueueInput
    upsert?: UserUpsertWithoutUserQueueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserQueueInput, UserUpdateWithoutUserQueueInput>, UserUncheckedUpdateWithoutUserQueueInput>
  }

  export type QueueUpdateOneRequiredWithoutUserQueueNestedInput = {
    create?: XOR<QueueCreateWithoutUserQueueInput, QueueUncheckedCreateWithoutUserQueueInput>
    connectOrCreate?: QueueCreateOrConnectWithoutUserQueueInput
    upsert?: QueueUpsertWithoutUserQueueInput
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutUserQueueInput, QueueUpdateWithoutUserQueueInput>, QueueUncheckedUpdateWithoutUserQueueInput>
  }

  export type TicketCreateNestedOneWithoutUserRatingInput = {
    create?: XOR<TicketCreateWithoutUserRatingInput, TicketUncheckedCreateWithoutUserRatingInput>
    connectOrCreate?: TicketCreateOrConnectWithoutUserRatingInput
    connect?: TicketWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUserRatingsInput = {
    create?: XOR<CompanyCreateWithoutUserRatingsInput, CompanyUncheckedCreateWithoutUserRatingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserRatingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserRatingInput = {
    create?: XOR<UserCreateWithoutUserRatingInput, UserUncheckedCreateWithoutUserRatingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRatingInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutUserRatingNestedInput = {
    create?: XOR<TicketCreateWithoutUserRatingInput, TicketUncheckedCreateWithoutUserRatingInput>
    connectOrCreate?: TicketCreateOrConnectWithoutUserRatingInput
    upsert?: TicketUpsertWithoutUserRatingInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutUserRatingInput, TicketUpdateWithoutUserRatingInput>, TicketUncheckedUpdateWithoutUserRatingInput>
  }

  export type CompanyUpdateOneRequiredWithoutUserRatingsNestedInput = {
    create?: XOR<CompanyCreateWithoutUserRatingsInput, CompanyUncheckedCreateWithoutUserRatingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserRatingsInput
    upsert?: CompanyUpsertWithoutUserRatingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUserRatingsInput, CompanyUpdateWithoutUserRatingsInput>, CompanyUncheckedUpdateWithoutUserRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutUserRatingNestedInput = {
    create?: XOR<UserCreateWithoutUserRatingInput, UserUncheckedCreateWithoutUserRatingInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRatingInput
    upsert?: UserUpsertWithoutUserRatingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRatingInput, UserUpdateWithoutUserRatingInput>, UserUncheckedUpdateWithoutUserRatingInput>
  }

  export type TicketCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<TicketCreateWithoutWhatsappInput, TicketUncheckedCreateWithoutWhatsappInput> | TicketCreateWithoutWhatsappInput[] | TicketUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutWhatsappInput | TicketCreateOrConnectWithoutWhatsappInput[]
    createMany?: TicketCreateManyWhatsappInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueCreateNestedManyWithoutWhatsappsInput = {
    create?: XOR<QueueCreateWithoutWhatsappsInput, QueueUncheckedCreateWithoutWhatsappsInput> | QueueCreateWithoutWhatsappsInput[] | QueueUncheckedCreateWithoutWhatsappsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutWhatsappsInput | QueueCreateOrConnectWithoutWhatsappsInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type WhatsappQueueCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<WhatsappQueueCreateWithoutWhatsappInput, WhatsappQueueUncheckedCreateWithoutWhatsappInput> | WhatsappQueueCreateWithoutWhatsappInput[] | WhatsappQueueUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutWhatsappInput | WhatsappQueueCreateOrConnectWithoutWhatsappInput[]
    createMany?: WhatsappQueueCreateManyWhatsappInputEnvelope
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWhatsappsInput = {
    create?: XOR<CompanyCreateWithoutWhatsappsInput, CompanyUncheckedCreateWithoutWhatsappsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatsappsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutWhatsappInput = {
    create?: XOR<PromptCreateWithoutWhatsappInput, PromptUncheckedCreateWithoutWhatsappInput>
    connectOrCreate?: PromptCreateOrConnectWithoutWhatsappInput
    connect?: PromptWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<UserCreateWithoutWhatsappInput, UserUncheckedCreateWithoutWhatsappInput> | UserCreateWithoutWhatsappInput[] | UserUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappInput | UserCreateOrConnectWithoutWhatsappInput[]
    createMany?: UserCreateManyWhatsappInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TicketTrackingCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<TicketTrackingCreateWithoutWhatsappInput, TicketTrackingUncheckedCreateWithoutWhatsappInput> | TicketTrackingCreateWithoutWhatsappInput[] | TicketTrackingUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutWhatsappInput | TicketTrackingCreateOrConnectWithoutWhatsappInput[]
    createMany?: TicketTrackingCreateManyWhatsappInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<ContactCreateWithoutWhatsappInput, ContactUncheckedCreateWithoutWhatsappInput> | ContactCreateWithoutWhatsappInput[] | ContactUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutWhatsappInput | ContactCreateOrConnectWithoutWhatsappInput[]
    createMany?: ContactCreateManyWhatsappInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<CampaignCreateWithoutWhatsappInput, CampaignUncheckedCreateWithoutWhatsappInput> | CampaignCreateWithoutWhatsappInput[] | CampaignUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutWhatsappInput | CampaignCreateOrConnectWithoutWhatsappInput[]
    createMany?: CampaignCreateManyWhatsappInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type BaileysChatsCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<BaileysChatsCreateWithoutWhatsappInput, BaileysChatsUncheckedCreateWithoutWhatsappInput> | BaileysChatsCreateWithoutWhatsappInput[] | BaileysChatsUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysChatsCreateOrConnectWithoutWhatsappInput | BaileysChatsCreateOrConnectWithoutWhatsappInput[]
    createMany?: BaileysChatsCreateManyWhatsappInputEnvelope
    connect?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
  }

  export type BaileysCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<BaileysCreateWithoutWhatsappInput, BaileysUncheckedCreateWithoutWhatsappInput> | BaileysCreateWithoutWhatsappInput[] | BaileysUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysCreateOrConnectWithoutWhatsappInput | BaileysCreateOrConnectWithoutWhatsappInput[]
    createMany?: BaileysCreateManyWhatsappInputEnvelope
    connect?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<TicketCreateWithoutWhatsappInput, TicketUncheckedCreateWithoutWhatsappInput> | TicketCreateWithoutWhatsappInput[] | TicketUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutWhatsappInput | TicketCreateOrConnectWithoutWhatsappInput[]
    createMany?: TicketCreateManyWhatsappInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type QueueUncheckedCreateNestedManyWithoutWhatsappsInput = {
    create?: XOR<QueueCreateWithoutWhatsappsInput, QueueUncheckedCreateWithoutWhatsappsInput> | QueueCreateWithoutWhatsappsInput[] | QueueUncheckedCreateWithoutWhatsappsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutWhatsappsInput | QueueCreateOrConnectWithoutWhatsappsInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
  }

  export type WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<WhatsappQueueCreateWithoutWhatsappInput, WhatsappQueueUncheckedCreateWithoutWhatsappInput> | WhatsappQueueCreateWithoutWhatsappInput[] | WhatsappQueueUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutWhatsappInput | WhatsappQueueCreateOrConnectWithoutWhatsappInput[]
    createMany?: WhatsappQueueCreateManyWhatsappInputEnvelope
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<UserCreateWithoutWhatsappInput, UserUncheckedCreateWithoutWhatsappInput> | UserCreateWithoutWhatsappInput[] | UserUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappInput | UserCreateOrConnectWithoutWhatsappInput[]
    createMany?: UserCreateManyWhatsappInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<TicketTrackingCreateWithoutWhatsappInput, TicketTrackingUncheckedCreateWithoutWhatsappInput> | TicketTrackingCreateWithoutWhatsappInput[] | TicketTrackingUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutWhatsappInput | TicketTrackingCreateOrConnectWithoutWhatsappInput[]
    createMany?: TicketTrackingCreateManyWhatsappInputEnvelope
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<ContactCreateWithoutWhatsappInput, ContactUncheckedCreateWithoutWhatsappInput> | ContactCreateWithoutWhatsappInput[] | ContactUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutWhatsappInput | ContactCreateOrConnectWithoutWhatsappInput[]
    createMany?: ContactCreateManyWhatsappInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<CampaignCreateWithoutWhatsappInput, CampaignUncheckedCreateWithoutWhatsappInput> | CampaignCreateWithoutWhatsappInput[] | CampaignUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutWhatsappInput | CampaignCreateOrConnectWithoutWhatsappInput[]
    createMany?: CampaignCreateManyWhatsappInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<BaileysChatsCreateWithoutWhatsappInput, BaileysChatsUncheckedCreateWithoutWhatsappInput> | BaileysChatsCreateWithoutWhatsappInput[] | BaileysChatsUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysChatsCreateOrConnectWithoutWhatsappInput | BaileysChatsCreateOrConnectWithoutWhatsappInput[]
    createMany?: BaileysChatsCreateManyWhatsappInputEnvelope
    connect?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
  }

  export type BaileysUncheckedCreateNestedManyWithoutWhatsappInput = {
    create?: XOR<BaileysCreateWithoutWhatsappInput, BaileysUncheckedCreateWithoutWhatsappInput> | BaileysCreateWithoutWhatsappInput[] | BaileysUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysCreateOrConnectWithoutWhatsappInput | BaileysCreateOrConnectWithoutWhatsappInput[]
    createMany?: BaileysCreateManyWhatsappInputEnvelope
    connect?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
  }

  export type TicketUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<TicketCreateWithoutWhatsappInput, TicketUncheckedCreateWithoutWhatsappInput> | TicketCreateWithoutWhatsappInput[] | TicketUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutWhatsappInput | TicketCreateOrConnectWithoutWhatsappInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutWhatsappInput | TicketUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: TicketCreateManyWhatsappInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutWhatsappInput | TicketUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutWhatsappInput | TicketUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueUpdateManyWithoutWhatsappsNestedInput = {
    create?: XOR<QueueCreateWithoutWhatsappsInput, QueueUncheckedCreateWithoutWhatsappsInput> | QueueCreateWithoutWhatsappsInput[] | QueueUncheckedCreateWithoutWhatsappsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutWhatsappsInput | QueueCreateOrConnectWithoutWhatsappsInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutWhatsappsInput | QueueUpsertWithWhereUniqueWithoutWhatsappsInput[]
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutWhatsappsInput | QueueUpdateWithWhereUniqueWithoutWhatsappsInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutWhatsappsInput | QueueUpdateManyWithWhereWithoutWhatsappsInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type WhatsappQueueUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<WhatsappQueueCreateWithoutWhatsappInput, WhatsappQueueUncheckedCreateWithoutWhatsappInput> | WhatsappQueueCreateWithoutWhatsappInput[] | WhatsappQueueUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutWhatsappInput | WhatsappQueueCreateOrConnectWithoutWhatsappInput[]
    upsert?: WhatsappQueueUpsertWithWhereUniqueWithoutWhatsappInput | WhatsappQueueUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: WhatsappQueueCreateManyWhatsappInputEnvelope
    set?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    disconnect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    delete?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    update?: WhatsappQueueUpdateWithWhereUniqueWithoutWhatsappInput | WhatsappQueueUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: WhatsappQueueUpdateManyWithWhereWithoutWhatsappInput | WhatsappQueueUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: WhatsappQueueScalarWhereInput | WhatsappQueueScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWhatsappsNestedInput = {
    create?: XOR<CompanyCreateWithoutWhatsappsInput, CompanyUncheckedCreateWithoutWhatsappsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatsappsInput
    upsert?: CompanyUpsertWithoutWhatsappsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWhatsappsInput, CompanyUpdateWithoutWhatsappsInput>, CompanyUncheckedUpdateWithoutWhatsappsInput>
  }

  export type PromptUpdateOneWithoutWhatsappNestedInput = {
    create?: XOR<PromptCreateWithoutWhatsappInput, PromptUncheckedCreateWithoutWhatsappInput>
    connectOrCreate?: PromptCreateOrConnectWithoutWhatsappInput
    upsert?: PromptUpsertWithoutWhatsappInput
    disconnect?: PromptWhereInput | boolean
    delete?: PromptWhereInput | boolean
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutWhatsappInput, PromptUpdateWithoutWhatsappInput>, PromptUncheckedUpdateWithoutWhatsappInput>
  }

  export type UserUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappInput, UserUncheckedCreateWithoutWhatsappInput> | UserCreateWithoutWhatsappInput[] | UserUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappInput | UserCreateOrConnectWithoutWhatsappInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutWhatsappInput | UserUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: UserCreateManyWhatsappInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutWhatsappInput | UserUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: UserUpdateManyWithWhereWithoutWhatsappInput | UserUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TicketTrackingUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutWhatsappInput, TicketTrackingUncheckedCreateWithoutWhatsappInput> | TicketTrackingCreateWithoutWhatsappInput[] | TicketTrackingUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutWhatsappInput | TicketTrackingCreateOrConnectWithoutWhatsappInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutWhatsappInput | TicketTrackingUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: TicketTrackingCreateManyWhatsappInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutWhatsappInput | TicketTrackingUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutWhatsappInput | TicketTrackingUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<ContactCreateWithoutWhatsappInput, ContactUncheckedCreateWithoutWhatsappInput> | ContactCreateWithoutWhatsappInput[] | ContactUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutWhatsappInput | ContactCreateOrConnectWithoutWhatsappInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutWhatsappInput | ContactUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: ContactCreateManyWhatsappInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutWhatsappInput | ContactUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutWhatsappInput | ContactUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<CampaignCreateWithoutWhatsappInput, CampaignUncheckedCreateWithoutWhatsappInput> | CampaignCreateWithoutWhatsappInput[] | CampaignUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutWhatsappInput | CampaignCreateOrConnectWithoutWhatsappInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutWhatsappInput | CampaignUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: CampaignCreateManyWhatsappInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutWhatsappInput | CampaignUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutWhatsappInput | CampaignUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type BaileysChatsUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<BaileysChatsCreateWithoutWhatsappInput, BaileysChatsUncheckedCreateWithoutWhatsappInput> | BaileysChatsCreateWithoutWhatsappInput[] | BaileysChatsUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysChatsCreateOrConnectWithoutWhatsappInput | BaileysChatsCreateOrConnectWithoutWhatsappInput[]
    upsert?: BaileysChatsUpsertWithWhereUniqueWithoutWhatsappInput | BaileysChatsUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: BaileysChatsCreateManyWhatsappInputEnvelope
    set?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    disconnect?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    delete?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    connect?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    update?: BaileysChatsUpdateWithWhereUniqueWithoutWhatsappInput | BaileysChatsUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: BaileysChatsUpdateManyWithWhereWithoutWhatsappInput | BaileysChatsUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: BaileysChatsScalarWhereInput | BaileysChatsScalarWhereInput[]
  }

  export type BaileysUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<BaileysCreateWithoutWhatsappInput, BaileysUncheckedCreateWithoutWhatsappInput> | BaileysCreateWithoutWhatsappInput[] | BaileysUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysCreateOrConnectWithoutWhatsappInput | BaileysCreateOrConnectWithoutWhatsappInput[]
    upsert?: BaileysUpsertWithWhereUniqueWithoutWhatsappInput | BaileysUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: BaileysCreateManyWhatsappInputEnvelope
    set?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    disconnect?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    delete?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    connect?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    update?: BaileysUpdateWithWhereUniqueWithoutWhatsappInput | BaileysUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: BaileysUpdateManyWithWhereWithoutWhatsappInput | BaileysUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: BaileysScalarWhereInput | BaileysScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<TicketCreateWithoutWhatsappInput, TicketUncheckedCreateWithoutWhatsappInput> | TicketCreateWithoutWhatsappInput[] | TicketUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutWhatsappInput | TicketCreateOrConnectWithoutWhatsappInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutWhatsappInput | TicketUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: TicketCreateManyWhatsappInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutWhatsappInput | TicketUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutWhatsappInput | TicketUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type QueueUncheckedUpdateManyWithoutWhatsappsNestedInput = {
    create?: XOR<QueueCreateWithoutWhatsappsInput, QueueUncheckedCreateWithoutWhatsappsInput> | QueueCreateWithoutWhatsappsInput[] | QueueUncheckedCreateWithoutWhatsappsInput[]
    connectOrCreate?: QueueCreateOrConnectWithoutWhatsappsInput | QueueCreateOrConnectWithoutWhatsappsInput[]
    upsert?: QueueUpsertWithWhereUniqueWithoutWhatsappsInput | QueueUpsertWithWhereUniqueWithoutWhatsappsInput[]
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[]
    update?: QueueUpdateWithWhereUniqueWithoutWhatsappsInput | QueueUpdateWithWhereUniqueWithoutWhatsappsInput[]
    updateMany?: QueueUpdateManyWithWhereWithoutWhatsappsInput | QueueUpdateManyWithWhereWithoutWhatsappsInput[]
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[]
  }

  export type WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<WhatsappQueueCreateWithoutWhatsappInput, WhatsappQueueUncheckedCreateWithoutWhatsappInput> | WhatsappQueueCreateWithoutWhatsappInput[] | WhatsappQueueUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: WhatsappQueueCreateOrConnectWithoutWhatsappInput | WhatsappQueueCreateOrConnectWithoutWhatsappInput[]
    upsert?: WhatsappQueueUpsertWithWhereUniqueWithoutWhatsappInput | WhatsappQueueUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: WhatsappQueueCreateManyWhatsappInputEnvelope
    set?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    disconnect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    delete?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    connect?: WhatsappQueueWhereUniqueInput | WhatsappQueueWhereUniqueInput[]
    update?: WhatsappQueueUpdateWithWhereUniqueWithoutWhatsappInput | WhatsappQueueUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: WhatsappQueueUpdateManyWithWhereWithoutWhatsappInput | WhatsappQueueUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: WhatsappQueueScalarWhereInput | WhatsappQueueScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappInput, UserUncheckedCreateWithoutWhatsappInput> | UserCreateWithoutWhatsappInput[] | UserUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappInput | UserCreateOrConnectWithoutWhatsappInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutWhatsappInput | UserUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: UserCreateManyWhatsappInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutWhatsappInput | UserUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: UserUpdateManyWithWhereWithoutWhatsappInput | UserUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<TicketTrackingCreateWithoutWhatsappInput, TicketTrackingUncheckedCreateWithoutWhatsappInput> | TicketTrackingCreateWithoutWhatsappInput[] | TicketTrackingUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: TicketTrackingCreateOrConnectWithoutWhatsappInput | TicketTrackingCreateOrConnectWithoutWhatsappInput[]
    upsert?: TicketTrackingUpsertWithWhereUniqueWithoutWhatsappInput | TicketTrackingUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: TicketTrackingCreateManyWhatsappInputEnvelope
    set?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    disconnect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    delete?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    connect?: TicketTrackingWhereUniqueInput | TicketTrackingWhereUniqueInput[]
    update?: TicketTrackingUpdateWithWhereUniqueWithoutWhatsappInput | TicketTrackingUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: TicketTrackingUpdateManyWithWhereWithoutWhatsappInput | TicketTrackingUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<ContactCreateWithoutWhatsappInput, ContactUncheckedCreateWithoutWhatsappInput> | ContactCreateWithoutWhatsappInput[] | ContactUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutWhatsappInput | ContactCreateOrConnectWithoutWhatsappInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutWhatsappInput | ContactUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: ContactCreateManyWhatsappInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutWhatsappInput | ContactUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutWhatsappInput | ContactUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<CampaignCreateWithoutWhatsappInput, CampaignUncheckedCreateWithoutWhatsappInput> | CampaignCreateWithoutWhatsappInput[] | CampaignUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutWhatsappInput | CampaignCreateOrConnectWithoutWhatsappInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutWhatsappInput | CampaignUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: CampaignCreateManyWhatsappInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutWhatsappInput | CampaignUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutWhatsappInput | CampaignUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<BaileysChatsCreateWithoutWhatsappInput, BaileysChatsUncheckedCreateWithoutWhatsappInput> | BaileysChatsCreateWithoutWhatsappInput[] | BaileysChatsUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysChatsCreateOrConnectWithoutWhatsappInput | BaileysChatsCreateOrConnectWithoutWhatsappInput[]
    upsert?: BaileysChatsUpsertWithWhereUniqueWithoutWhatsappInput | BaileysChatsUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: BaileysChatsCreateManyWhatsappInputEnvelope
    set?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    disconnect?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    delete?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    connect?: BaileysChatsWhereUniqueInput | BaileysChatsWhereUniqueInput[]
    update?: BaileysChatsUpdateWithWhereUniqueWithoutWhatsappInput | BaileysChatsUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: BaileysChatsUpdateManyWithWhereWithoutWhatsappInput | BaileysChatsUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: BaileysChatsScalarWhereInput | BaileysChatsScalarWhereInput[]
  }

  export type BaileysUncheckedUpdateManyWithoutWhatsappNestedInput = {
    create?: XOR<BaileysCreateWithoutWhatsappInput, BaileysUncheckedCreateWithoutWhatsappInput> | BaileysCreateWithoutWhatsappInput[] | BaileysUncheckedCreateWithoutWhatsappInput[]
    connectOrCreate?: BaileysCreateOrConnectWithoutWhatsappInput | BaileysCreateOrConnectWithoutWhatsappInput[]
    upsert?: BaileysUpsertWithWhereUniqueWithoutWhatsappInput | BaileysUpsertWithWhereUniqueWithoutWhatsappInput[]
    createMany?: BaileysCreateManyWhatsappInputEnvelope
    set?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    disconnect?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    delete?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    connect?: BaileysWhereUniqueInput | BaileysWhereUniqueInput[]
    update?: BaileysUpdateWithWhereUniqueWithoutWhatsappInput | BaileysUpdateWithWhereUniqueWithoutWhatsappInput[]
    updateMany?: BaileysUpdateManyWithWhereWithoutWhatsappInput | BaileysUpdateManyWithWhereWithoutWhatsappInput[]
    deleteMany?: BaileysScalarWhereInput | BaileysScalarWhereInput[]
  }

  export type WhatsappCreateNestedOneWithoutWhatsappQueuesInput = {
    create?: XOR<WhatsappCreateWithoutWhatsappQueuesInput, WhatsappUncheckedCreateWithoutWhatsappQueuesInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutWhatsappQueuesInput
    connect?: WhatsappWhereUniqueInput
  }

  export type QueueCreateNestedOneWithoutWhatsappQueueInput = {
    create?: XOR<QueueCreateWithoutWhatsappQueueInput, QueueUncheckedCreateWithoutWhatsappQueueInput>
    connectOrCreate?: QueueCreateOrConnectWithoutWhatsappQueueInput
    connect?: QueueWhereUniqueInput
  }

  export type WhatsappUpdateOneRequiredWithoutWhatsappQueuesNestedInput = {
    create?: XOR<WhatsappCreateWithoutWhatsappQueuesInput, WhatsappUncheckedCreateWithoutWhatsappQueuesInput>
    connectOrCreate?: WhatsappCreateOrConnectWithoutWhatsappQueuesInput
    upsert?: WhatsappUpsertWithoutWhatsappQueuesInput
    connect?: WhatsappWhereUniqueInput
    update?: XOR<XOR<WhatsappUpdateToOneWithWhereWithoutWhatsappQueuesInput, WhatsappUpdateWithoutWhatsappQueuesInput>, WhatsappUncheckedUpdateWithoutWhatsappQueuesInput>
  }

  export type QueueUpdateOneRequiredWithoutWhatsappQueueNestedInput = {
    create?: XOR<QueueCreateWithoutWhatsappQueueInput, QueueUncheckedCreateWithoutWhatsappQueueInput>
    connectOrCreate?: QueueCreateOrConnectWithoutWhatsappQueueInput
    upsert?: QueueUpsertWithoutWhatsappQueueInput
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutWhatsappQueueInput, QueueUpdateWithoutWhatsappQueueInput>, QueueUncheckedUpdateWithoutWhatsappQueueInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CompanyCreateWithoutAnnouncementsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAnnouncementsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAnnouncementsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAnnouncementsInput, CompanyUncheckedCreateWithoutAnnouncementsInput>
  }

  export type CompanyUpsertWithoutAnnouncementsInput = {
    update: XOR<CompanyUpdateWithoutAnnouncementsInput, CompanyUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<CompanyCreateWithoutAnnouncementsInput, CompanyUncheckedCreateWithoutAnnouncementsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAnnouncementsInput, CompanyUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type CompanyUpdateWithoutAnnouncementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAnnouncementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WhatsappCreateWithoutBaileysInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutBaileysInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutBaileysInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutBaileysInput, WhatsappUncheckedCreateWithoutBaileysInput>
  }

  export type WhatsappUpsertWithoutBaileysInput = {
    update: XOR<WhatsappUpdateWithoutBaileysInput, WhatsappUncheckedUpdateWithoutBaileysInput>
    create: XOR<WhatsappCreateWithoutBaileysInput, WhatsappUncheckedCreateWithoutBaileysInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutBaileysInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutBaileysInput, WhatsappUncheckedUpdateWithoutBaileysInput>
  }

  export type WhatsappUpdateWithoutBaileysInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutBaileysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappCreateWithoutBaileysChatsInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutBaileysChatsInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutBaileysChatsInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutBaileysChatsInput, WhatsappUncheckedCreateWithoutBaileysChatsInput>
  }

  export type WhatsappUpsertWithoutBaileysChatsInput = {
    update: XOR<WhatsappUpdateWithoutBaileysChatsInput, WhatsappUncheckedUpdateWithoutBaileysChatsInput>
    create: XOR<WhatsappCreateWithoutBaileysChatsInput, WhatsappUncheckedCreateWithoutBaileysChatsInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutBaileysChatsInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutBaileysChatsInput, WhatsappUncheckedUpdateWithoutBaileysChatsInput>
  }

  export type WhatsappUpdateWithoutBaileysChatsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutBaileysChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type CompanyCreateWithoutCampaignsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCampaignsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCampaignsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCampaignsInput, CompanyUncheckedCreateWithoutCampaignsInput>
  }

  export type ContactListCreateWithoutCampaignInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactListsInput
    items?: ContactListItemCreateNestedManyWithoutContactListInput
  }

  export type ContactListUncheckedCreateWithoutCampaignInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    items?: ContactListItemUncheckedCreateNestedManyWithoutContactListInput
  }

  export type ContactListCreateOrConnectWithoutCampaignInput = {
    where: ContactListWhereUniqueInput
    create: XOR<ContactListCreateWithoutCampaignInput, ContactListUncheckedCreateWithoutCampaignInput>
  }

  export type WhatsappCreateWithoutCampaignInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutCampaignInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutCampaignInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutCampaignInput, WhatsappUncheckedCreateWithoutCampaignInput>
  }

  export type FilesCreateWithoutCampaignInput = {
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFilessInput
    options?: FilesOptionsCreateNestedManyWithoutFileInput
  }

  export type FilesUncheckedCreateWithoutCampaignInput = {
    id?: number
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    options?: FilesOptionsUncheckedCreateNestedManyWithoutFileInput
  }

  export type FilesCreateOrConnectWithoutCampaignInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutCampaignInput, FilesUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignShippingCreateWithoutCampaignInput = {
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactListItemCreateNestedOneWithoutCampaignShippingInput
  }

  export type CampaignShippingUncheckedCreateWithoutCampaignInput = {
    id?: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    contactId: number
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignShippingCreateOrConnectWithoutCampaignInput = {
    where: CampaignShippingWhereUniqueInput
    create: XOR<CampaignShippingCreateWithoutCampaignInput, CampaignShippingUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignShippingCreateManyCampaignInputEnvelope = {
    data: CampaignShippingCreateManyCampaignInput | CampaignShippingCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutCampaignsInput = {
    update: XOR<CompanyUpdateWithoutCampaignsInput, CompanyUncheckedUpdateWithoutCampaignsInput>
    create: XOR<CompanyCreateWithoutCampaignsInput, CompanyUncheckedCreateWithoutCampaignsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCampaignsInput, CompanyUncheckedUpdateWithoutCampaignsInput>
  }

  export type CompanyUpdateWithoutCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCampaignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactListUpsertWithoutCampaignInput = {
    update: XOR<ContactListUpdateWithoutCampaignInput, ContactListUncheckedUpdateWithoutCampaignInput>
    create: XOR<ContactListCreateWithoutCampaignInput, ContactListUncheckedCreateWithoutCampaignInput>
    where?: ContactListWhereInput
  }

  export type ContactListUpdateToOneWithWhereWithoutCampaignInput = {
    where?: ContactListWhereInput
    data: XOR<ContactListUpdateWithoutCampaignInput, ContactListUncheckedUpdateWithoutCampaignInput>
  }

  export type ContactListUpdateWithoutCampaignInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactListsNestedInput
    items?: ContactListItemUpdateManyWithoutContactListNestedInput
  }

  export type ContactListUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    items?: ContactListItemUncheckedUpdateManyWithoutContactListNestedInput
  }

  export type WhatsappUpsertWithoutCampaignInput = {
    update: XOR<WhatsappUpdateWithoutCampaignInput, WhatsappUncheckedUpdateWithoutCampaignInput>
    create: XOR<WhatsappCreateWithoutCampaignInput, WhatsappUncheckedCreateWithoutCampaignInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutCampaignInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutCampaignInput, WhatsappUncheckedUpdateWithoutCampaignInput>
  }

  export type WhatsappUpdateWithoutCampaignInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type FilesUpsertWithoutCampaignInput = {
    update: XOR<FilesUpdateWithoutCampaignInput, FilesUncheckedUpdateWithoutCampaignInput>
    create: XOR<FilesCreateWithoutCampaignInput, FilesUncheckedCreateWithoutCampaignInput>
    where?: FilesWhereInput
  }

  export type FilesUpdateToOneWithWhereWithoutCampaignInput = {
    where?: FilesWhereInput
    data: XOR<FilesUpdateWithoutCampaignInput, FilesUncheckedUpdateWithoutCampaignInput>
  }

  export type FilesUpdateWithoutCampaignInput = {
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFilessNestedInput
    options?: FilesOptionsUpdateManyWithoutFileNestedInput
  }

  export type FilesUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    options?: FilesOptionsUncheckedUpdateManyWithoutFileNestedInput
  }

  export type CampaignShippingUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignShippingWhereUniqueInput
    update: XOR<CampaignShippingUpdateWithoutCampaignInput, CampaignShippingUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignShippingCreateWithoutCampaignInput, CampaignShippingUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignShippingUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignShippingWhereUniqueInput
    data: XOR<CampaignShippingUpdateWithoutCampaignInput, CampaignShippingUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignShippingUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignShippingScalarWhereInput
    data: XOR<CampaignShippingUpdateManyMutationInput, CampaignShippingUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignShippingScalarWhereInput = {
    AND?: CampaignShippingScalarWhereInput | CampaignShippingScalarWhereInput[]
    OR?: CampaignShippingScalarWhereInput[]
    NOT?: CampaignShippingScalarWhereInput | CampaignShippingScalarWhereInput[]
    id?: IntFilter<"CampaignShipping"> | number
    jobId?: StringFilter<"CampaignShipping"> | string
    number?: StringFilter<"CampaignShipping"> | string
    message?: StringFilter<"CampaignShipping"> | string
    confirmationMessage?: StringFilter<"CampaignShipping"> | string
    confirmation?: BoolFilter<"CampaignShipping"> | boolean
    contactId?: IntFilter<"CampaignShipping"> | number
    campaignId?: IntFilter<"CampaignShipping"> | number
    confirmationRequestedAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    confirmedAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignShipping"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignShipping"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignShipping"> | Date | string
  }

  export type CompanyCreateWithoutCampaignSettingsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCampaignSettingsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCampaignSettingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCampaignSettingsInput, CompanyUncheckedCreateWithoutCampaignSettingsInput>
  }

  export type CompanyUpsertWithoutCampaignSettingsInput = {
    update: XOR<CompanyUpdateWithoutCampaignSettingsInput, CompanyUncheckedUpdateWithoutCampaignSettingsInput>
    create: XOR<CompanyCreateWithoutCampaignSettingsInput, CompanyUncheckedCreateWithoutCampaignSettingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCampaignSettingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCampaignSettingsInput, CompanyUncheckedUpdateWithoutCampaignSettingsInput>
  }

  export type CompanyUpdateWithoutCampaignSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCampaignSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactListItemCreateWithoutCampaignShippingInput = {
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactListItemsInput
    contactList: ContactListCreateNestedOneWithoutItemsInput
  }

  export type ContactListItemUncheckedCreateWithoutCampaignShippingInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId: number
  }

  export type ContactListItemCreateOrConnectWithoutCampaignShippingInput = {
    where: ContactListItemWhereUniqueInput
    create: XOR<ContactListItemCreateWithoutCampaignShippingInput, ContactListItemUncheckedCreateWithoutCampaignShippingInput>
  }

  export type CampaignCreateWithoutShippingInput = {
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCampaignsInput
    contactList?: ContactListCreateNestedOneWithoutCampaignInput
    whatsapp?: WhatsappCreateNestedOneWithoutCampaignInput
    fileList: FilesCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutShippingInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    whatsappId?: number | null
    fileListId: number
  }

  export type CampaignCreateOrConnectWithoutShippingInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutShippingInput, CampaignUncheckedCreateWithoutShippingInput>
  }

  export type ContactListItemUpsertWithoutCampaignShippingInput = {
    update: XOR<ContactListItemUpdateWithoutCampaignShippingInput, ContactListItemUncheckedUpdateWithoutCampaignShippingInput>
    create: XOR<ContactListItemCreateWithoutCampaignShippingInput, ContactListItemUncheckedCreateWithoutCampaignShippingInput>
    where?: ContactListItemWhereInput
  }

  export type ContactListItemUpdateToOneWithWhereWithoutCampaignShippingInput = {
    where?: ContactListItemWhereInput
    data: XOR<ContactListItemUpdateWithoutCampaignShippingInput, ContactListItemUncheckedUpdateWithoutCampaignShippingInput>
  }

  export type ContactListItemUpdateWithoutCampaignShippingInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactListItemsNestedInput
    contactList?: ContactListUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ContactListItemUncheckedUpdateWithoutCampaignShippingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignUpsertWithoutShippingInput = {
    update: XOR<CampaignUpdateWithoutShippingInput, CampaignUncheckedUpdateWithoutShippingInput>
    create: XOR<CampaignCreateWithoutShippingInput, CampaignUncheckedCreateWithoutShippingInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutShippingInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutShippingInput, CampaignUncheckedUpdateWithoutShippingInput>
  }

  export type CampaignUpdateWithoutShippingInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCampaignsNestedInput
    contactList?: ContactListUpdateOneWithoutCampaignNestedInput
    whatsapp?: WhatsappUpdateOneWithoutCampaignNestedInput
    fileList?: FilesUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutShippingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyCreateWithoutChatsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutChatsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutChatsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
  }

  export type UserCreateWithoutChatInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
  }

  export type ChatUserCreateWithoutChatInput = {
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChatUsersInput
  }

  export type ChatUserUncheckedCreateWithoutChatInput = {
    id?: number
    userId: number
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUserCreateOrConnectWithoutChatInput = {
    where: ChatUserWhereUniqueInput
    create: XOR<ChatUserCreateWithoutChatInput, ChatUserUncheckedCreateWithoutChatInput>
  }

  export type ChatUserCreateManyChatInputEnvelope = {
    data: ChatUserCreateManyChatInput | ChatUserCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutChatInput = {
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutChatMessageInput
  }

  export type ChatMessageUncheckedCreateWithoutChatInput = {
    id?: number
    senderId: number
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageCreateManyChatInputEnvelope = {
    data: ChatMessageCreateManyChatInput | ChatMessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutChatsInput = {
    update: XOR<CompanyUpdateWithoutChatsInput, CompanyUncheckedUpdateWithoutChatsInput>
    create: XOR<CompanyCreateWithoutChatsInput, CompanyUncheckedCreateWithoutChatsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutChatsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutChatsInput, CompanyUncheckedUpdateWithoutChatsInput>
  }

  export type CompanyUpdateWithoutChatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutChatInput = {
    update: XOR<UserUpdateWithoutChatInput, UserUncheckedUpdateWithoutChatInput>
    create: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatInput, UserUncheckedUpdateWithoutChatInput>
  }

  export type UserUpdateWithoutChatInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatUserUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatUserWhereUniqueInput
    update: XOR<ChatUserUpdateWithoutChatInput, ChatUserUncheckedUpdateWithoutChatInput>
    create: XOR<ChatUserCreateWithoutChatInput, ChatUserUncheckedCreateWithoutChatInput>
  }

  export type ChatUserUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatUserWhereUniqueInput
    data: XOR<ChatUserUpdateWithoutChatInput, ChatUserUncheckedUpdateWithoutChatInput>
  }

  export type ChatUserUpdateManyWithWhereWithoutChatInput = {
    where: ChatUserScalarWhereInput
    data: XOR<ChatUserUpdateManyMutationInput, ChatUserUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatUserScalarWhereInput = {
    AND?: ChatUserScalarWhereInput | ChatUserScalarWhereInput[]
    OR?: ChatUserScalarWhereInput[]
    NOT?: ChatUserScalarWhereInput | ChatUserScalarWhereInput[]
    id?: IntFilter<"ChatUser"> | number
    chatId?: IntFilter<"ChatUser"> | number
    userId?: IntFilter<"ChatUser"> | number
    unreads?: IntFilter<"ChatUser"> | number
    createdAt?: DateTimeFilter<"ChatUser"> | Date | string
    updatedAt?: DateTimeFilter<"ChatUser"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutChatInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: IntFilter<"ChatMessage"> | number
    chatId?: IntFilter<"ChatMessage"> | number
    senderId?: IntFilter<"ChatMessage"> | number
    message?: StringFilter<"ChatMessage"> | string
    mediaPath?: StringNullableFilter<"ChatMessage"> | string | null
    mediaName?: StringNullableFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatCreateWithoutMessagesInput = {
    uuid?: string
    title?: string
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutChatsInput
    owner: UserCreateNestedOneWithoutChatInput
    users?: ChatUserCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: number
    uuid?: string
    title?: string
    ownerId: number
    lastMessage?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: ChatUserUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutChatMessageInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatMessageInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatMessageInput, UserUncheckedCreateWithoutChatMessageInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
    owner?: UserUpdateOneRequiredWithoutChatNestedInput
    users?: ChatUserUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    lastMessage?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: ChatUserUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutChatMessageInput = {
    update: XOR<UserUpdateWithoutChatMessageInput, UserUncheckedUpdateWithoutChatMessageInput>
    create: XOR<UserCreateWithoutChatMessageInput, UserUncheckedCreateWithoutChatMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatMessageInput, UserUncheckedUpdateWithoutChatMessageInput>
  }

  export type UserUpdateWithoutChatMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatCreateWithoutUsersInput = {
    uuid?: string
    title?: string
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutChatsInput
    owner: UserCreateNestedOneWithoutChatInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUsersInput = {
    id?: number
    uuid?: string
    title?: string
    ownerId: number
    lastMessage?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUsersInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUsersInput, ChatUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutChatUsersInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatUsersInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatUsersInput, UserUncheckedCreateWithoutChatUsersInput>
  }

  export type ChatUpsertWithoutUsersInput = {
    update: XOR<ChatUpdateWithoutUsersInput, ChatUncheckedUpdateWithoutUsersInput>
    create: XOR<ChatCreateWithoutUsersInput, ChatUncheckedCreateWithoutUsersInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutUsersInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutUsersInput, ChatUncheckedUpdateWithoutUsersInput>
  }

  export type ChatUpdateWithoutUsersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
    owner?: UserUpdateOneRequiredWithoutChatNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    lastMessage?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutChatUsersInput = {
    update: XOR<UserUpdateWithoutChatUsersInput, UserUncheckedUpdateWithoutChatUsersInput>
    create: XOR<UserCreateWithoutChatUsersInput, UserUncheckedCreateWithoutChatUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatUsersInput, UserUncheckedUpdateWithoutChatUsersInput>
  }

  export type UserUpdateWithoutChatUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduleCreateWithoutCompanyInput = {
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutSchedulesInput
    ticket: TicketCreateNestedOneWithoutScheduleInput
    user: UserCreateNestedOneWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutCompanyInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutCompanyInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput>
  }

  export type ScheduleCreateManyCompanyInputEnvelope = {
    data: ScheduleCreateManyCompanyInput | ScheduleCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutCompanyInput = {
    name: string
    users?: number | null
    connections?: number | null
    queues?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    useSchedules: boolean
    useCampaigns: boolean
    useInternalChat: boolean
    useExternalApi: boolean
    useKanban: boolean
    useOpenAi: boolean
    useIntegrations: boolean
  }

  export type PlanUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    users?: number | null
    connections?: number | null
    queues?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    useSchedules: boolean
    useCampaigns: boolean
    useInternalChat: boolean
    useExternalApi: boolean
    useKanban: boolean
    useOpenAi: boolean
    useIntegrations: boolean
  }

  export type PlanCreateOrConnectWithoutCompanyInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateWithoutCompanyInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserRatingCreateWithoutCompanyInput = {
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutUserRatingInput
    user: UserCreateNestedOneWithoutUserRatingInput
  }

  export type UserRatingUncheckedCreateWithoutCompanyInput = {
    id?: number
    ticketId: number
    userId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingCreateOrConnectWithoutCompanyInput = {
    where: UserRatingWhereUniqueInput
    create: XOR<UserRatingCreateWithoutCompanyInput, UserRatingUncheckedCreateWithoutCompanyInput>
  }

  export type UserRatingCreateManyCompanyInputEnvelope = {
    data: UserRatingCreateManyCompanyInput | UserRatingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type QueueCreateWithoutCompanyInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
  }

  export type QueueUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
  }

  export type QueueCreateOrConnectWithoutCompanyInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput>
  }

  export type WhatsappCreateWithoutCompanyInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutCompanyInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutCompanyInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutCompanyInput, WhatsappUncheckedCreateWithoutCompanyInput>
  }

  export type WhatsappCreateManyCompanyInputEnvelope = {
    data: WhatsappCreateManyCompanyInput | WhatsappCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutCompanyInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsg?: MessageCreateNestedOneWithoutMessageInput
    ticket?: TicketCreateNestedOneWithoutMessagesInput
    contact?: ContactCreateNestedOneWithoutMessageInput
    queue?: QueueCreateNestedOneWithoutMessageInput
    Message?: MessageCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUncheckedCreateWithoutCompanyInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    queueId?: number | null
    Message?: MessageUncheckedCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageCreateOrConnectWithoutCompanyInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCompanyInput, MessageUncheckedCreateWithoutCompanyInput>
  }

  export type MessageCreateManyCompanyInputEnvelope = {
    data: MessageCreateManyCompanyInput | MessageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCompanyInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactCreateManyCompanyInputEnvelope = {
    data: ContactCreateManyCompanyInput | ContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SettingCreateWithoutCompanyInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateWithoutCompanyInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingCreateOrConnectWithoutCompanyInput = {
    where: SettingWhereUniqueInput
    create: XOR<SettingCreateWithoutCompanyInput, SettingUncheckedCreateWithoutCompanyInput>
  }

  export type SettingCreateManyCompanyInputEnvelope = {
    data: SettingCreateManyCompanyInput | SettingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutCompanyInput = {
    name: string
    color: string
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTags?: TicketTagCreateNestedManyWithoutTagInput
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    color: string
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTagInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutCompanyInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCompanyInput, TagUncheckedCreateWithoutCompanyInput>
  }

  export type TagCreateManyCompanyInputEnvelope = {
    data: TagCreateManyCompanyInput | TagCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutCompanyInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutCompanyInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutCompanyInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput>
  }

  export type TicketCreateManyCompanyInputEnvelope = {
    data: TicketCreateManyCompanyInput | TicketCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TicketTrackingCreateWithoutCompanyInput = {
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
    ticket: TicketCreateNestedOneWithoutTicketTrackingInput
    whatsapp?: WhatsappCreateNestedOneWithoutTicketTrackingInput
    user?: UserCreateNestedOneWithoutTicketTrackingInput
  }

  export type TicketTrackingUncheckedCreateWithoutCompanyInput = {
    id?: number
    ticketId: number
    whatsappId?: number | null
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketTrackingCreateOrConnectWithoutCompanyInput = {
    where: TicketTrackingWhereUniqueInput
    create: XOR<TicketTrackingCreateWithoutCompanyInput, TicketTrackingUncheckedCreateWithoutCompanyInput>
  }

  export type TicketTrackingCreateManyCompanyInputEnvelope = {
    data: TicketTrackingCreateManyCompanyInput | TicketTrackingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCompanyInput = {
    isActive: boolean
    userPriceCents?: number | null
    whatsPriceCents?: number | null
    lastInvoiceUrl?: string | null
    lastPlanChange?: Date | string | null
    expiresAt?: Date | string | null
    providerSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutCompanyInput = {
    id?: number
    isActive: boolean
    userPriceCents?: number | null
    whatsPriceCents?: number | null
    lastInvoiceUrl?: string | null
    lastPlanChange?: Date | string | null
    expiresAt?: Date | string | null
    providerSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutCompanyInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput>
  }

  export type SubscriptionCreateManyCompanyInputEnvelope = {
    data: SubscriptionCreateManyCompanyInput | SubscriptionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type QuickMessageCreateWithoutCompanyInput = {
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuickMessagesInput
  }

  export type QuickMessageUncheckedCreateWithoutCompanyInput = {
    id?: number
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickMessageCreateOrConnectWithoutCompanyInput = {
    where: QuickMessageWhereUniqueInput
    create: XOR<QuickMessageCreateWithoutCompanyInput, QuickMessageUncheckedCreateWithoutCompanyInput>
  }

  export type QuickMessageCreateManyCompanyInputEnvelope = {
    data: QuickMessageCreateManyCompanyInput | QuickMessageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type QueueIntegrationsCreateWithoutCompanyInput = {
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketCreateNestedManyWithoutQueueIntegrationInput
    Queue?: QueueCreateNestedManyWithoutQueueIntegrationsInput
  }

  export type QueueIntegrationsUncheckedCreateWithoutCompanyInput = {
    id?: number
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueIntegrationInput
    Queue?: QueueUncheckedCreateNestedManyWithoutQueueIntegrationsInput
  }

  export type QueueIntegrationsCreateOrConnectWithoutCompanyInput = {
    where: QueueIntegrationsWhereUniqueInput
    create: XOR<QueueIntegrationsCreateWithoutCompanyInput, QueueIntegrationsUncheckedCreateWithoutCompanyInput>
  }

  export type QueueIntegrationsCreateManyCompanyInputEnvelope = {
    data: QueueIntegrationsCreateManyCompanyInput | QueueIntegrationsCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PromptCreateWithoutCompanyInput = {
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue?: QueueCreateNestedOneWithoutPromptInput
    Whatsapp?: WhatsappCreateNestedManyWithoutPromptInput
    Ticket?: TicketCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    queueId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Whatsapp?: WhatsappUncheckedCreateNestedManyWithoutPromptInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutCompanyInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutCompanyInput, PromptUncheckedCreateWithoutCompanyInput>
  }

  export type PromptCreateManyCompanyInputEnvelope = {
    data: PromptCreateManyCompanyInput | PromptCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type FilesCreateWithoutCompanyInput = {
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: FilesOptionsCreateNestedManyWithoutFileInput
    Campaign?: CampaignCreateNestedManyWithoutFileListInput
  }

  export type FilesUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: FilesOptionsUncheckedCreateNestedManyWithoutFileInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutFileListInput
  }

  export type FilesCreateOrConnectWithoutCompanyInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutCompanyInput, FilesUncheckedCreateWithoutCompanyInput>
  }

  export type FilesCreateManyCompanyInputEnvelope = {
    data: FilesCreateManyCompanyInput | FilesCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactListItemCreateWithoutCompanyInput = {
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactList: ContactListCreateNestedOneWithoutItemsInput
    CampaignShipping?: CampaignShippingCreateNestedManyWithoutContactInput
  }

  export type ContactListItemUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactListId: number
    CampaignShipping?: CampaignShippingUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactListItemCreateOrConnectWithoutCompanyInput = {
    where: ContactListItemWhereUniqueInput
    create: XOR<ContactListItemCreateWithoutCompanyInput, ContactListItemUncheckedCreateWithoutCompanyInput>
  }

  export type ContactListItemCreateManyCompanyInputEnvelope = {
    data: ContactListItemCreateManyCompanyInput | ContactListItemCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactListCreateWithoutCompanyInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContactListItemCreateNestedManyWithoutContactListInput
    Campaign?: CampaignCreateNestedManyWithoutContactListInput
  }

  export type ContactListUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContactListItemUncheckedCreateNestedManyWithoutContactListInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutContactListInput
  }

  export type ContactListCreateOrConnectWithoutCompanyInput = {
    where: ContactListWhereUniqueInput
    create: XOR<ContactListCreateWithoutCompanyInput, ContactListUncheckedCreateWithoutCompanyInput>
  }

  export type ContactListCreateManyCompanyInputEnvelope = {
    data: ContactListCreateManyCompanyInput | ContactListCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutCompanyInput = {
    uuid?: string
    title?: string
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutChatInput
    users?: ChatUserCreateNestedManyWithoutChatInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutCompanyInput = {
    id?: number
    uuid?: string
    title?: string
    ownerId: number
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: ChatUserUncheckedCreateNestedManyWithoutChatInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutCompanyInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput>
  }

  export type ChatCreateManyCompanyInputEnvelope = {
    data: ChatCreateManyCompanyInput | ChatCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CampaignSettingCreateWithoutCompanyInput = {
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignSettingUncheckedCreateWithoutCompanyInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignSettingCreateOrConnectWithoutCompanyInput = {
    where: CampaignSettingWhereUniqueInput
    create: XOR<CampaignSettingCreateWithoutCompanyInput, CampaignSettingUncheckedCreateWithoutCompanyInput>
  }

  export type CampaignSettingCreateManyCompanyInputEnvelope = {
    data: CampaignSettingCreateManyCompanyInput | CampaignSettingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutCompanyInput = {
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactList?: ContactListCreateNestedOneWithoutCampaignInput
    whatsapp?: WhatsappCreateNestedOneWithoutCampaignInput
    fileList: FilesCreateNestedOneWithoutCampaignInput
    shipping?: CampaignShippingCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactListId?: number | null
    whatsappId?: number | null
    fileListId: number
    shipping?: CampaignShippingUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCompanyInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCompanyInput, CampaignUncheckedCreateWithoutCompanyInput>
  }

  export type CampaignCreateManyCompanyInputEnvelope = {
    data: CampaignCreateManyCompanyInput | CampaignCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutCompanyInput = {
    priority: number
    title: string
    text: string
    mediaPath?: string | null
    mediaName?: string | null
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUncheckedCreateWithoutCompanyInput = {
    id?: number
    priority: number
    title: string
    text: string
    mediaPath?: string | null
    mediaName?: string | null
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutCompanyInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutCompanyInput, AnnouncementUncheckedCreateWithoutCompanyInput>
  }

  export type AnnouncementCreateManyCompanyInputEnvelope = {
    data: AnnouncementCreateManyCompanyInput | AnnouncementCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type QueueCreateWithoutCompanyInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateManyCompanyInputEnvelope = {
    data: QueueCreateManyCompanyInput | QueueCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutCompanyInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutCompanyInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutCompanyInput, RatingUncheckedCreateWithoutCompanyInput>
  }

  export type RatingCreateManyCompanyInputEnvelope = {
    data: RatingCreateManyCompanyInput | RatingCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutCompanyInput, ScheduleUncheckedUpdateWithoutCompanyInput>
    create: XOR<ScheduleCreateWithoutCompanyInput, ScheduleUncheckedCreateWithoutCompanyInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutCompanyInput, ScheduleUncheckedUpdateWithoutCompanyInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutCompanyInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: IntFilter<"Schedule"> | number
    body?: StringFilter<"Schedule"> | string
    sendAt?: DateTimeFilter<"Schedule"> | Date | string
    sentAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    status?: StringFilter<"Schedule"> | string
    mediaPath?: StringFilter<"Schedule"> | string
    mediaName?: StringFilter<"Schedule"> | string
    contactId?: IntFilter<"Schedule"> | number
    ticketId?: IntFilter<"Schedule"> | number
    userId?: IntFilter<"Schedule"> | number
    companyId?: IntFilter<"Schedule"> | number
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type PlanUpsertWithoutCompanyInput = {
    update: XOR<PlanUpdateWithoutCompanyInput, PlanUncheckedUpdateWithoutCompanyInput>
    create: XOR<PlanCreateWithoutCompanyInput, PlanUncheckedCreateWithoutCompanyInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutCompanyInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutCompanyInput, PlanUncheckedUpdateWithoutCompanyInput>
  }

  export type PlanUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: NullableIntFieldUpdateOperationsInput | number | null
    connections?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useSchedules?: BoolFieldUpdateOperationsInput | boolean
    useCampaigns?: BoolFieldUpdateOperationsInput | boolean
    useInternalChat?: BoolFieldUpdateOperationsInput | boolean
    useExternalApi?: BoolFieldUpdateOperationsInput | boolean
    useKanban?: BoolFieldUpdateOperationsInput | boolean
    useOpenAi?: BoolFieldUpdateOperationsInput | boolean
    useIntegrations?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: NullableIntFieldUpdateOperationsInput | number | null
    connections?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    useSchedules?: BoolFieldUpdateOperationsInput | boolean
    useCampaigns?: BoolFieldUpdateOperationsInput | boolean
    useInternalChat?: BoolFieldUpdateOperationsInput | boolean
    useExternalApi?: BoolFieldUpdateOperationsInput | boolean
    useKanban?: BoolFieldUpdateOperationsInput | boolean
    useOpenAi?: BoolFieldUpdateOperationsInput | boolean
    useIntegrations?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    tokenVersion?: IntFilter<"User"> | number
    profile?: StringFilter<"User"> | string
    super?: BoolFilter<"User"> | boolean
    online?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companyId?: IntFilter<"User"> | number
    whatsappId?: IntNullableFilter<"User"> | number | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
  }

  export type UserRatingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserRatingWhereUniqueInput
    update: XOR<UserRatingUpdateWithoutCompanyInput, UserRatingUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserRatingCreateWithoutCompanyInput, UserRatingUncheckedCreateWithoutCompanyInput>
  }

  export type UserRatingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserRatingWhereUniqueInput
    data: XOR<UserRatingUpdateWithoutCompanyInput, UserRatingUncheckedUpdateWithoutCompanyInput>
  }

  export type UserRatingUpdateManyWithWhereWithoutCompanyInput = {
    where: UserRatingScalarWhereInput
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserRatingScalarWhereInput = {
    AND?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
    OR?: UserRatingScalarWhereInput[]
    NOT?: UserRatingScalarWhereInput | UserRatingScalarWhereInput[]
    id?: IntFilter<"UserRating"> | number
    ticketId?: IntFilter<"UserRating"> | number
    companyId?: IntFilter<"UserRating"> | number
    userId?: IntFilter<"UserRating"> | number
    rate?: IntFilter<"UserRating"> | number
    createdAt?: DateTimeFilter<"UserRating"> | Date | string
    updatedAt?: DateTimeFilter<"UserRating"> | Date | string
  }

  export type QueueUpsertWithWhereUniqueWithoutCompanyInput = {
    where: QueueWhereUniqueInput
    update: XOR<QueueUpdateWithoutCompanyInput, QueueUncheckedUpdateWithoutCompanyInput>
    create: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput>
  }

  export type QueueUpdateWithWhereUniqueWithoutCompanyInput = {
    where: QueueWhereUniqueInput
    data: XOR<QueueUpdateWithoutCompanyInput, QueueUncheckedUpdateWithoutCompanyInput>
  }

  export type QueueUpdateManyWithWhereWithoutCompanyInput = {
    where: QueueScalarWhereInput
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyWithoutCompanyInput>
  }

  export type QueueScalarWhereInput = {
    AND?: QueueScalarWhereInput | QueueScalarWhereInput[]
    OR?: QueueScalarWhereInput[]
    NOT?: QueueScalarWhereInput | QueueScalarWhereInput[]
    id?: IntFilter<"Queue"> | number
    name?: StringFilter<"Queue"> | string
    color?: StringFilter<"Queue"> | string
    greetingMessage?: StringFilter<"Queue"> | string
    outOfHoursMessage?: StringFilter<"Queue"> | string
    schedules?: JsonNullableFilter<"Queue">
    createdAt?: DateTimeFilter<"Queue"> | Date | string
    updatedAt?: DateTimeFilter<"Queue"> | Date | string
    companyId?: IntFilter<"Queue"> | number
    orderQueue?: IntFilter<"Queue"> | number
    integrationId?: IntNullableFilter<"Queue"> | number | null
    promptId?: IntNullableFilter<"Queue"> | number | null
  }

  export type WhatsappUpsertWithWhereUniqueWithoutCompanyInput = {
    where: WhatsappWhereUniqueInput
    update: XOR<WhatsappUpdateWithoutCompanyInput, WhatsappUncheckedUpdateWithoutCompanyInput>
    create: XOR<WhatsappCreateWithoutCompanyInput, WhatsappUncheckedCreateWithoutCompanyInput>
  }

  export type WhatsappUpdateWithWhereUniqueWithoutCompanyInput = {
    where: WhatsappWhereUniqueInput
    data: XOR<WhatsappUpdateWithoutCompanyInput, WhatsappUncheckedUpdateWithoutCompanyInput>
  }

  export type WhatsappUpdateManyWithWhereWithoutCompanyInput = {
    where: WhatsappScalarWhereInput
    data: XOR<WhatsappUpdateManyMutationInput, WhatsappUncheckedUpdateManyWithoutCompanyInput>
  }

  export type WhatsappScalarWhereInput = {
    AND?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
    OR?: WhatsappScalarWhereInput[]
    NOT?: WhatsappScalarWhereInput | WhatsappScalarWhereInput[]
    id?: IntFilter<"Whatsapp"> | number
    name?: StringNullableFilter<"Whatsapp"> | string | null
    session?: StringNullableFilter<"Whatsapp"> | string | null
    qrcode?: StringNullableFilter<"Whatsapp"> | string | null
    status?: StringNullableFilter<"Whatsapp"> | string | null
    battery?: StringNullableFilter<"Whatsapp"> | string | null
    plugged?: BoolNullableFilter<"Whatsapp"> | boolean | null
    retries?: IntNullableFilter<"Whatsapp"> | number | null
    greetingMessage?: StringFilter<"Whatsapp"> | string
    farewellMessage?: StringFilter<"Whatsapp"> | string
    complationMessage?: StringFilter<"Whatsapp"> | string
    outOfHoursMessage?: StringFilter<"Whatsapp"> | string
    ratingMessage?: StringFilter<"Whatsapp"> | string
    provider?: StringFilter<"Whatsapp"> | string
    isDefault?: BoolNullableFilter<"Whatsapp"> | boolean | null
    token?: StringNullableFilter<"Whatsapp"> | string | null
    transferQueueId?: IntNullableFilter<"Whatsapp"> | number | null
    timeToTransfer?: IntNullableFilter<"Whatsapp"> | number | null
    maxUseBotQueues?: IntNullableFilter<"Whatsapp"> | number | null
    timeUseBotQueues?: StringNullableFilter<"Whatsapp"> | string | null
    sendIdQueue?: IntNullableFilter<"Whatsapp"> | number | null
    timeSendQueue?: IntNullableFilter<"Whatsapp"> | number | null
    integrationId?: IntNullableFilter<"Whatsapp"> | number | null
    expiresTicket?: IntNullableFilter<"Whatsapp"> | number | null
    expiresInactiveMessage?: StringNullableFilter<"Whatsapp"> | string | null
    createdAt?: DateTimeFilter<"Whatsapp"> | Date | string
    updatedAt?: DateTimeFilter<"Whatsapp"> | Date | string
    companyId?: IntFilter<"Whatsapp"> | number
    promptId?: IntNullableFilter<"Whatsapp"> | number | null
  }

  export type MessageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutCompanyInput, MessageUncheckedUpdateWithoutCompanyInput>
    create: XOR<MessageCreateWithoutCompanyInput, MessageUncheckedCreateWithoutCompanyInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutCompanyInput, MessageUncheckedUpdateWithoutCompanyInput>
  }

  export type MessageUpdateManyWithWhereWithoutCompanyInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    remoteJid?: StringFilter<"Message"> | string
    participant?: StringFilter<"Message"> | string
    dataJson?: StringFilter<"Message"> | string
    ack?: IntFilter<"Message"> | number
    read?: BoolFilter<"Message"> | boolean
    fromMe?: BoolFilter<"Message"> | boolean
    body?: StringFilter<"Message"> | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringFilter<"Message"> | string
    isDeleted?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    quotedMsgId?: StringNullableFilter<"Message"> | string | null
    ticketId?: IntNullableFilter<"Message"> | number | null
    contactId?: IntNullableFilter<"Message"> | number | null
    companyId?: IntFilter<"Message"> | number
    queueId?: IntNullableFilter<"Message"> | number | null
  }

  export type ContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    number?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    profilePicUrl?: StringFilter<"Contact"> | string
    isGroup?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    companyId?: IntFilter<"Contact"> | number
    whatsappId?: IntNullableFilter<"Contact"> | number | null
  }

  export type SettingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SettingWhereUniqueInput
    update: XOR<SettingUpdateWithoutCompanyInput, SettingUncheckedUpdateWithoutCompanyInput>
    create: XOR<SettingCreateWithoutCompanyInput, SettingUncheckedCreateWithoutCompanyInput>
  }

  export type SettingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SettingWhereUniqueInput
    data: XOR<SettingUpdateWithoutCompanyInput, SettingUncheckedUpdateWithoutCompanyInput>
  }

  export type SettingUpdateManyWithWhereWithoutCompanyInput = {
    where: SettingScalarWhereInput
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SettingScalarWhereInput = {
    AND?: SettingScalarWhereInput | SettingScalarWhereInput[]
    OR?: SettingScalarWhereInput[]
    NOT?: SettingScalarWhereInput | SettingScalarWhereInput[]
    id?: IntFilter<"Setting"> | number
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
    companyId?: IntFilter<"Setting"> | number
  }

  export type TagUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutCompanyInput, TagUncheckedUpdateWithoutCompanyInput>
    create: XOR<TagCreateWithoutCompanyInput, TagUncheckedCreateWithoutCompanyInput>
  }

  export type TagUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutCompanyInput, TagUncheckedUpdateWithoutCompanyInput>
  }

  export type TagUpdateManyWithWhereWithoutCompanyInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    companyId?: IntFilter<"Tag"> | number
    kanban?: IntFilter<"Tag"> | number
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCompanyInput, TicketUncheckedUpdateWithoutCompanyInput>
    create: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCompanyInput, TicketUncheckedUpdateWithoutCompanyInput>
  }

  export type TicketUpdateManyWithWhereWithoutCompanyInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: IntFilter<"Ticket"> | number
    status?: StringFilter<"Ticket"> | string
    unreadMessages?: IntNullableFilter<"Ticket"> | number | null
    lastMessage?: StringNullableFilter<"Ticket"> | string | null
    isGroup?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    userId?: IntFilter<"Ticket"> | number
    contactId?: IntFilter<"Ticket"> | number
    whatsappId?: IntFilter<"Ticket"> | number
    queueId?: IntFilter<"Ticket"> | number
    chatbot?: BoolNullableFilter<"Ticket"> | boolean | null
    queueOptionId?: IntFilter<"Ticket"> | number
    companyId?: IntFilter<"Ticket"> | number
    uuid?: StringFilter<"Ticket"> | string
    useIntegration?: BoolNullableFilter<"Ticket"> | boolean | null
    integrationId?: IntNullableFilter<"Ticket"> | number | null
    typebotSessionId?: StringNullableFilter<"Ticket"> | string | null
    typebotStatus?: BoolFilter<"Ticket"> | boolean
    promptId?: IntNullableFilter<"Ticket"> | number | null
    fromMe?: BoolNullableFilter<"Ticket"> | boolean | null
    amountUsedBotQueues?: IntFilter<"Ticket"> | number
    isBot?: BoolNullableFilter<"Ticket"> | boolean | null
  }

  export type TicketTrackingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TicketTrackingWhereUniqueInput
    update: XOR<TicketTrackingUpdateWithoutCompanyInput, TicketTrackingUncheckedUpdateWithoutCompanyInput>
    create: XOR<TicketTrackingCreateWithoutCompanyInput, TicketTrackingUncheckedCreateWithoutCompanyInput>
  }

  export type TicketTrackingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TicketTrackingWhereUniqueInput
    data: XOR<TicketTrackingUpdateWithoutCompanyInput, TicketTrackingUncheckedUpdateWithoutCompanyInput>
  }

  export type TicketTrackingUpdateManyWithWhereWithoutCompanyInput = {
    where: TicketTrackingScalarWhereInput
    data: XOR<TicketTrackingUpdateManyMutationInput, TicketTrackingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TicketTrackingScalarWhereInput = {
    AND?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
    OR?: TicketTrackingScalarWhereInput[]
    NOT?: TicketTrackingScalarWhereInput | TicketTrackingScalarWhereInput[]
    id?: IntFilter<"TicketTracking"> | number
    ticketId?: IntFilter<"TicketTracking"> | number
    companyId?: IntFilter<"TicketTracking"> | number
    whatsappId?: IntNullableFilter<"TicketTracking"> | number | null
    userId?: IntNullableFilter<"TicketTracking"> | number | null
    rated?: BoolFilter<"TicketTracking"> | boolean
    createdAt?: DateTimeFilter<"TicketTracking"> | Date | string
    updatedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    startedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    queuedAt?: DateTimeFilter<"TicketTracking"> | Date | string
    finishedAt?: DateTimeNullableFilter<"TicketTracking"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"TicketTracking"> | Date | string | null
    ratingAt?: DateTimeFilter<"TicketTracking"> | Date | string
    chatbotAt?: DateTimeFilter<"TicketTracking"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCompanyInput, SubscriptionUncheckedUpdateWithoutCompanyInput>
    create: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCompanyInput, SubscriptionUncheckedUpdateWithoutCompanyInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCompanyInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: IntFilter<"Subscription"> | number
    isActive?: BoolFilter<"Subscription"> | boolean
    userPriceCents?: IntNullableFilter<"Subscription"> | number | null
    whatsPriceCents?: IntNullableFilter<"Subscription"> | number | null
    lastInvoiceUrl?: StringNullableFilter<"Subscription"> | string | null
    lastPlanChange?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    providerSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    companyId?: IntFilter<"Subscription"> | number
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type QuickMessageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: QuickMessageWhereUniqueInput
    update: XOR<QuickMessageUpdateWithoutCompanyInput, QuickMessageUncheckedUpdateWithoutCompanyInput>
    create: XOR<QuickMessageCreateWithoutCompanyInput, QuickMessageUncheckedCreateWithoutCompanyInput>
  }

  export type QuickMessageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: QuickMessageWhereUniqueInput
    data: XOR<QuickMessageUpdateWithoutCompanyInput, QuickMessageUncheckedUpdateWithoutCompanyInput>
  }

  export type QuickMessageUpdateManyWithWhereWithoutCompanyInput = {
    where: QuickMessageScalarWhereInput
    data: XOR<QuickMessageUpdateManyMutationInput, QuickMessageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type QuickMessageScalarWhereInput = {
    AND?: QuickMessageScalarWhereInput | QuickMessageScalarWhereInput[]
    OR?: QuickMessageScalarWhereInput[]
    NOT?: QuickMessageScalarWhereInput | QuickMessageScalarWhereInput[]
    id?: IntFilter<"QuickMessage"> | number
    shortcode?: StringFilter<"QuickMessage"> | string
    message?: StringFilter<"QuickMessage"> | string
    mediaName?: StringNullableFilter<"QuickMessage"> | string | null
    mediaPath?: StringNullableFilter<"QuickMessage"> | string | null
    companyId?: IntFilter<"QuickMessage"> | number
    userId?: IntFilter<"QuickMessage"> | number
    createdAt?: DateTimeFilter<"QuickMessage"> | Date | string
    updatedAt?: DateTimeFilter<"QuickMessage"> | Date | string
  }

  export type QueueIntegrationsUpsertWithWhereUniqueWithoutCompanyInput = {
    where: QueueIntegrationsWhereUniqueInput
    update: XOR<QueueIntegrationsUpdateWithoutCompanyInput, QueueIntegrationsUncheckedUpdateWithoutCompanyInput>
    create: XOR<QueueIntegrationsCreateWithoutCompanyInput, QueueIntegrationsUncheckedCreateWithoutCompanyInput>
  }

  export type QueueIntegrationsUpdateWithWhereUniqueWithoutCompanyInput = {
    where: QueueIntegrationsWhereUniqueInput
    data: XOR<QueueIntegrationsUpdateWithoutCompanyInput, QueueIntegrationsUncheckedUpdateWithoutCompanyInput>
  }

  export type QueueIntegrationsUpdateManyWithWhereWithoutCompanyInput = {
    where: QueueIntegrationsScalarWhereInput
    data: XOR<QueueIntegrationsUpdateManyMutationInput, QueueIntegrationsUncheckedUpdateManyWithoutCompanyInput>
  }

  export type QueueIntegrationsScalarWhereInput = {
    AND?: QueueIntegrationsScalarWhereInput | QueueIntegrationsScalarWhereInput[]
    OR?: QueueIntegrationsScalarWhereInput[]
    NOT?: QueueIntegrationsScalarWhereInput | QueueIntegrationsScalarWhereInput[]
    id?: IntFilter<"QueueIntegrations"> | number
    type?: StringFilter<"QueueIntegrations"> | string
    name?: StringFilter<"QueueIntegrations"> | string
    projectName?: StringFilter<"QueueIntegrations"> | string
    jsonContent?: StringNullableFilter<"QueueIntegrations"> | string | null
    language?: StringNullableFilter<"QueueIntegrations"> | string | null
    urlN8N?: StringNullableFilter<"QueueIntegrations"> | string | null
    companyId?: IntFilter<"QueueIntegrations"> | number
    typebotSlug?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotExpires?: IntNullableFilter<"QueueIntegrations"> | number | null
    typebotKeywordFinish?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotUnknownMessage?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotDelayMessage?: IntNullableFilter<"QueueIntegrations"> | number | null
    typebotKeywordRestart?: StringNullableFilter<"QueueIntegrations"> | string | null
    typebotRestartMessage?: StringNullableFilter<"QueueIntegrations"> | string | null
    createdAt?: DateTimeFilter<"QueueIntegrations"> | Date | string
    updatedAt?: DateTimeFilter<"QueueIntegrations"> | Date | string
  }

  export type PromptUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PromptWhereUniqueInput
    update: XOR<PromptUpdateWithoutCompanyInput, PromptUncheckedUpdateWithoutCompanyInput>
    create: XOR<PromptCreateWithoutCompanyInput, PromptUncheckedCreateWithoutCompanyInput>
  }

  export type PromptUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PromptWhereUniqueInput
    data: XOR<PromptUpdateWithoutCompanyInput, PromptUncheckedUpdateWithoutCompanyInput>
  }

  export type PromptUpdateManyWithWhereWithoutCompanyInput = {
    where: PromptScalarWhereInput
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PromptScalarWhereInput = {
    AND?: PromptScalarWhereInput | PromptScalarWhereInput[]
    OR?: PromptScalarWhereInput[]
    NOT?: PromptScalarWhereInput | PromptScalarWhereInput[]
    id?: IntFilter<"Prompt"> | number
    name?: StringFilter<"Prompt"> | string
    prompt?: StringFilter<"Prompt"> | string
    apiKey?: StringFilter<"Prompt"> | string
    maxMessages?: IntFilter<"Prompt"> | number
    maxTokens?: IntFilter<"Prompt"> | number
    temperature?: IntFilter<"Prompt"> | number
    promptTokens?: IntFilter<"Prompt"> | number
    completionTokens?: IntFilter<"Prompt"> | number
    totalTokens?: IntFilter<"Prompt"> | number
    voice?: StringFilter<"Prompt"> | string
    voiceKey?: StringNullableFilter<"Prompt"> | string | null
    voiceRegion?: StringNullableFilter<"Prompt"> | string | null
    queueId?: IntNullableFilter<"Prompt"> | number | null
    companyId?: IntFilter<"Prompt"> | number
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
  }

  export type FilesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FilesWhereUniqueInput
    update: XOR<FilesUpdateWithoutCompanyInput, FilesUncheckedUpdateWithoutCompanyInput>
    create: XOR<FilesCreateWithoutCompanyInput, FilesUncheckedCreateWithoutCompanyInput>
  }

  export type FilesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FilesWhereUniqueInput
    data: XOR<FilesUpdateWithoutCompanyInput, FilesUncheckedUpdateWithoutCompanyInput>
  }

  export type FilesUpdateManyWithWhereWithoutCompanyInput = {
    where: FilesScalarWhereInput
    data: XOR<FilesUpdateManyMutationInput, FilesUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FilesScalarWhereInput = {
    AND?: FilesScalarWhereInput | FilesScalarWhereInput[]
    OR?: FilesScalarWhereInput[]
    NOT?: FilesScalarWhereInput | FilesScalarWhereInput[]
    id?: IntFilter<"Files"> | number
    name?: StringFilter<"Files"> | string
    message?: StringFilter<"Files"> | string
    createdAt?: DateTimeFilter<"Files"> | Date | string
    updatedAt?: DateTimeFilter<"Files"> | Date | string
    companyId?: IntFilter<"Files"> | number
  }

  export type ContactListItemUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactListItemWhereUniqueInput
    update: XOR<ContactListItemUpdateWithoutCompanyInput, ContactListItemUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactListItemCreateWithoutCompanyInput, ContactListItemUncheckedCreateWithoutCompanyInput>
  }

  export type ContactListItemUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactListItemWhereUniqueInput
    data: XOR<ContactListItemUpdateWithoutCompanyInput, ContactListItemUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactListItemUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactListItemScalarWhereInput
    data: XOR<ContactListItemUpdateManyMutationInput, ContactListItemUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactListItemScalarWhereInput = {
    AND?: ContactListItemScalarWhereInput | ContactListItemScalarWhereInput[]
    OR?: ContactListItemScalarWhereInput[]
    NOT?: ContactListItemScalarWhereInput | ContactListItemScalarWhereInput[]
    id?: IntFilter<"ContactListItem"> | number
    name?: StringFilter<"ContactListItem"> | string
    number?: StringFilter<"ContactListItem"> | string
    email?: StringFilter<"ContactListItem"> | string
    isWhatsappValid?: BoolNullableFilter<"ContactListItem"> | boolean | null
    createdAt?: DateTimeFilter<"ContactListItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContactListItem"> | Date | string
    companyId?: IntFilter<"ContactListItem"> | number
    contactListId?: IntFilter<"ContactListItem"> | number
  }

  export type ContactListUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactListWhereUniqueInput
    update: XOR<ContactListUpdateWithoutCompanyInput, ContactListUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactListCreateWithoutCompanyInput, ContactListUncheckedCreateWithoutCompanyInput>
  }

  export type ContactListUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactListWhereUniqueInput
    data: XOR<ContactListUpdateWithoutCompanyInput, ContactListUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactListUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactListScalarWhereInput
    data: XOR<ContactListUpdateManyMutationInput, ContactListUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactListScalarWhereInput = {
    AND?: ContactListScalarWhereInput | ContactListScalarWhereInput[]
    OR?: ContactListScalarWhereInput[]
    NOT?: ContactListScalarWhereInput | ContactListScalarWhereInput[]
    id?: IntFilter<"ContactList"> | number
    name?: StringFilter<"ContactList"> | string
    createdAt?: DateTimeFilter<"ContactList"> | Date | string
    updatedAt?: DateTimeFilter<"ContactList"> | Date | string
    companyId?: IntFilter<"ContactList"> | number
  }

  export type ChatUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutCompanyInput, ChatUncheckedUpdateWithoutCompanyInput>
    create: XOR<ChatCreateWithoutCompanyInput, ChatUncheckedCreateWithoutCompanyInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutCompanyInput, ChatUncheckedUpdateWithoutCompanyInput>
  }

  export type ChatUpdateManyWithWhereWithoutCompanyInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: IntFilter<"Chat"> | number
    uuid?: StringFilter<"Chat"> | string
    title?: StringFilter<"Chat"> | string
    ownerId?: IntFilter<"Chat"> | number
    lastMessage?: StringFilter<"Chat"> | string
    companyId?: IntFilter<"Chat"> | number
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
  }

  export type CampaignSettingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CampaignSettingWhereUniqueInput
    update: XOR<CampaignSettingUpdateWithoutCompanyInput, CampaignSettingUncheckedUpdateWithoutCompanyInput>
    create: XOR<CampaignSettingCreateWithoutCompanyInput, CampaignSettingUncheckedCreateWithoutCompanyInput>
  }

  export type CampaignSettingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CampaignSettingWhereUniqueInput
    data: XOR<CampaignSettingUpdateWithoutCompanyInput, CampaignSettingUncheckedUpdateWithoutCompanyInput>
  }

  export type CampaignSettingUpdateManyWithWhereWithoutCompanyInput = {
    where: CampaignSettingScalarWhereInput
    data: XOR<CampaignSettingUpdateManyMutationInput, CampaignSettingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CampaignSettingScalarWhereInput = {
    AND?: CampaignSettingScalarWhereInput | CampaignSettingScalarWhereInput[]
    OR?: CampaignSettingScalarWhereInput[]
    NOT?: CampaignSettingScalarWhereInput | CampaignSettingScalarWhereInput[]
    id?: IntFilter<"CampaignSetting"> | number
    key?: StringFilter<"CampaignSetting"> | string
    value?: StringFilter<"CampaignSetting"> | string
    createdAt?: DateTimeFilter<"CampaignSetting"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSetting"> | Date | string
    companyId?: IntFilter<"CampaignSetting"> | number
  }

  export type CampaignUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCompanyInput, CampaignUncheckedUpdateWithoutCompanyInput>
    create: XOR<CampaignCreateWithoutCompanyInput, CampaignUncheckedCreateWithoutCompanyInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCompanyInput, CampaignUncheckedUpdateWithoutCompanyInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCompanyInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: IntFilter<"Campaign"> | number
    name?: StringFilter<"Campaign"> | string
    message1?: StringFilter<"Campaign"> | string
    message2?: StringFilter<"Campaign"> | string
    message3?: StringFilter<"Campaign"> | string
    message4?: StringFilter<"Campaign"> | string
    message5?: StringFilter<"Campaign"> | string
    confirmationMessage1?: StringFilter<"Campaign"> | string
    confirmationMessage2?: StringFilter<"Campaign"> | string
    confirmationMessage3?: StringFilter<"Campaign"> | string
    confirmationMessage4?: StringFilter<"Campaign"> | string
    confirmationMessage5?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    confirmation?: BoolFilter<"Campaign"> | boolean
    mediaPath?: StringFilter<"Campaign"> | string
    mediaName?: StringFilter<"Campaign"> | string
    scheduledAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    companyId?: IntFilter<"Campaign"> | number
    contactListId?: IntNullableFilter<"Campaign"> | number | null
    whatsappId?: IntNullableFilter<"Campaign"> | number | null
    fileListId?: IntFilter<"Campaign"> | number
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutCompanyInput, AnnouncementUncheckedUpdateWithoutCompanyInput>
    create: XOR<AnnouncementCreateWithoutCompanyInput, AnnouncementUncheckedCreateWithoutCompanyInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutCompanyInput, AnnouncementUncheckedUpdateWithoutCompanyInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutCompanyInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: IntFilter<"Announcement"> | number
    priority?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    text?: StringFilter<"Announcement"> | string
    mediaPath?: StringNullableFilter<"Announcement"> | string | null
    mediaName?: StringNullableFilter<"Announcement"> | string | null
    companyId?: IntFilter<"Announcement"> | number
    status?: BoolFilter<"Announcement"> | boolean
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type QueueUpsertWithWhereUniqueWithoutCompanyInput = {
    where: QueueWhereUniqueInput
    update: XOR<QueueUpdateWithoutCompanyInput, QueueUncheckedUpdateWithoutCompanyInput>
    create: XOR<QueueCreateWithoutCompanyInput, QueueUncheckedCreateWithoutCompanyInput>
  }

  export type QueueUpdateWithWhereUniqueWithoutCompanyInput = {
    where: QueueWhereUniqueInput
    data: XOR<QueueUpdateWithoutCompanyInput, QueueUncheckedUpdateWithoutCompanyInput>
  }

  export type QueueUpdateManyWithWhereWithoutCompanyInput = {
    where: QueueScalarWhereInput
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyWithoutCompanyInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutCompanyInput, RatingUncheckedUpdateWithoutCompanyInput>
    create: XOR<RatingCreateWithoutCompanyInput, RatingUncheckedCreateWithoutCompanyInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutCompanyInput, RatingUncheckedUpdateWithoutCompanyInput>
  }

  export type RatingUpdateManyWithWhereWithoutCompanyInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: IntFilter<"Rating"> | number
    name?: StringFilter<"Rating"> | string
    companyId?: IntFilter<"Rating"> | number
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
  }

  export type CompanyCreateWithoutContactsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContactsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContactsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
  }

  export type WhatsappCreateWithoutContactInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutContactInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutContactInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutContactInput, WhatsappUncheckedCreateWithoutContactInput>
  }

  export type TicketCreateWithoutContactInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutContactInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutContactInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput>
  }

  export type TicketCreateManyContactInputEnvelope = {
    data: TicketCreateManyContactInput | TicketCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactCustomFieldCreateWithoutContactInput = {
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCustomFieldUncheckedCreateWithoutContactInput = {
    id?: number
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCustomFieldCreateOrConnectWithoutContactInput = {
    where: ContactCustomFieldWhereUniqueInput
    create: XOR<ContactCustomFieldCreateWithoutContactInput, ContactCustomFieldUncheckedCreateWithoutContactInput>
  }

  export type ContactCustomFieldCreateManyContactInputEnvelope = {
    data: ContactCustomFieldCreateManyContactInput | ContactCustomFieldCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutContactInput = {
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutScheduleInput
    user: UserCreateNestedOneWithoutScheduleInput
    company: CompanyCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutContactInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    ticketId: number
    userId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutContactInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutContactInput, ScheduleUncheckedCreateWithoutContactInput>
  }

  export type ScheduleCreateManyContactInputEnvelope = {
    data: ScheduleCreateManyContactInput | ScheduleCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type TicketNoteCreateWithoutContactInput = {
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketNoteInput
    ticket: TicketCreateNestedOneWithoutTicketNoteInput
  }

  export type TicketNoteUncheckedCreateWithoutContactInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    ticketId: number
  }

  export type TicketNoteCreateOrConnectWithoutContactInput = {
    where: TicketNoteWhereUniqueInput
    create: XOR<TicketNoteCreateWithoutContactInput, TicketNoteUncheckedCreateWithoutContactInput>
  }

  export type TicketNoteCreateManyContactInputEnvelope = {
    data: TicketNoteCreateManyContactInput | TicketNoteCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutContactInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsg?: MessageCreateNestedOneWithoutMessageInput
    ticket?: TicketCreateNestedOneWithoutMessagesInput
    company: CompanyCreateNestedOneWithoutMessagesInput
    queue?: QueueCreateNestedOneWithoutMessageInput
    Message?: MessageCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUncheckedCreateWithoutContactInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    companyId: number
    queueId?: number | null
    Message?: MessageUncheckedCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageCreateOrConnectWithoutContactInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput>
  }

  export type MessageCreateManyContactInputEnvelope = {
    data: MessageCreateManyContactInput | MessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutContactsInput = {
    update: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContactsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type CompanyUpdateWithoutContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WhatsappUpsertWithoutContactInput = {
    update: XOR<WhatsappUpdateWithoutContactInput, WhatsappUncheckedUpdateWithoutContactInput>
    create: XOR<WhatsappCreateWithoutContactInput, WhatsappUncheckedCreateWithoutContactInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutContactInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutContactInput, WhatsappUncheckedUpdateWithoutContactInput>
  }

  export type WhatsappUpdateWithoutContactInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutContactInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutContactInput, TicketUncheckedUpdateWithoutContactInput>
    create: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutContactInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutContactInput, TicketUncheckedUpdateWithoutContactInput>
  }

  export type TicketUpdateManyWithWhereWithoutContactInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactCustomFieldUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactCustomFieldWhereUniqueInput
    update: XOR<ContactCustomFieldUpdateWithoutContactInput, ContactCustomFieldUncheckedUpdateWithoutContactInput>
    create: XOR<ContactCustomFieldCreateWithoutContactInput, ContactCustomFieldUncheckedCreateWithoutContactInput>
  }

  export type ContactCustomFieldUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactCustomFieldWhereUniqueInput
    data: XOR<ContactCustomFieldUpdateWithoutContactInput, ContactCustomFieldUncheckedUpdateWithoutContactInput>
  }

  export type ContactCustomFieldUpdateManyWithWhereWithoutContactInput = {
    where: ContactCustomFieldScalarWhereInput
    data: XOR<ContactCustomFieldUpdateManyMutationInput, ContactCustomFieldUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactCustomFieldScalarWhereInput = {
    AND?: ContactCustomFieldScalarWhereInput | ContactCustomFieldScalarWhereInput[]
    OR?: ContactCustomFieldScalarWhereInput[]
    NOT?: ContactCustomFieldScalarWhereInput | ContactCustomFieldScalarWhereInput[]
    id?: IntFilter<"ContactCustomField"> | number
    name?: StringFilter<"ContactCustomField"> | string
    value?: StringFilter<"ContactCustomField"> | string
    contactId?: IntFilter<"ContactCustomField"> | number
    createdAt?: DateTimeFilter<"ContactCustomField"> | Date | string
    updatedAt?: DateTimeFilter<"ContactCustomField"> | Date | string
  }

  export type ScheduleUpsertWithWhereUniqueWithoutContactInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutContactInput, ScheduleUncheckedUpdateWithoutContactInput>
    create: XOR<ScheduleCreateWithoutContactInput, ScheduleUncheckedCreateWithoutContactInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutContactInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutContactInput, ScheduleUncheckedUpdateWithoutContactInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutContactInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutContactInput>
  }

  export type TicketNoteUpsertWithWhereUniqueWithoutContactInput = {
    where: TicketNoteWhereUniqueInput
    update: XOR<TicketNoteUpdateWithoutContactInput, TicketNoteUncheckedUpdateWithoutContactInput>
    create: XOR<TicketNoteCreateWithoutContactInput, TicketNoteUncheckedCreateWithoutContactInput>
  }

  export type TicketNoteUpdateWithWhereUniqueWithoutContactInput = {
    where: TicketNoteWhereUniqueInput
    data: XOR<TicketNoteUpdateWithoutContactInput, TicketNoteUncheckedUpdateWithoutContactInput>
  }

  export type TicketNoteUpdateManyWithWhereWithoutContactInput = {
    where: TicketNoteScalarWhereInput
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyWithoutContactInput>
  }

  export type TicketNoteScalarWhereInput = {
    AND?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
    OR?: TicketNoteScalarWhereInput[]
    NOT?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
    id?: IntFilter<"TicketNote"> | number
    note?: StringFilter<"TicketNote"> | string
    createdAt?: DateTimeFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeFilter<"TicketNote"> | Date | string
    userId?: IntFilter<"TicketNote"> | number
    contactId?: IntFilter<"TicketNote"> | number
    ticketId?: IntFilter<"TicketNote"> | number
  }

  export type MessageUpsertWithWhereUniqueWithoutContactInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutContactInput, MessageUncheckedUpdateWithoutContactInput>
    create: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutContactInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutContactInput, MessageUncheckedUpdateWithoutContactInput>
  }

  export type MessageUpdateManyWithWhereWithoutContactInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactCreateWithoutExtraInfoInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutExtraInfoInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutExtraInfoInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutExtraInfoInput, ContactUncheckedCreateWithoutExtraInfoInput>
  }

  export type ContactUpsertWithoutExtraInfoInput = {
    update: XOR<ContactUpdateWithoutExtraInfoInput, ContactUncheckedUpdateWithoutExtraInfoInput>
    create: XOR<ContactCreateWithoutExtraInfoInput, ContactUncheckedCreateWithoutExtraInfoInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutExtraInfoInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutExtraInfoInput, ContactUncheckedUpdateWithoutExtraInfoInput>
  }

  export type ContactUpdateWithoutExtraInfoInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutExtraInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CompanyCreateWithoutContactListsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContactListsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContactListsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContactListsInput, CompanyUncheckedCreateWithoutContactListsInput>
  }

  export type ContactListItemCreateWithoutContactListInput = {
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactListItemsInput
    CampaignShipping?: CampaignShippingCreateNestedManyWithoutContactInput
  }

  export type ContactListItemUncheckedCreateWithoutContactListInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    CampaignShipping?: CampaignShippingUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactListItemCreateOrConnectWithoutContactListInput = {
    where: ContactListItemWhereUniqueInput
    create: XOR<ContactListItemCreateWithoutContactListInput, ContactListItemUncheckedCreateWithoutContactListInput>
  }

  export type ContactListItemCreateManyContactListInputEnvelope = {
    data: ContactListItemCreateManyContactListInput | ContactListItemCreateManyContactListInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutContactListInput = {
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCampaignsInput
    whatsapp?: WhatsappCreateNestedOneWithoutCampaignInput
    fileList: FilesCreateNestedOneWithoutCampaignInput
    shipping?: CampaignShippingCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutContactListInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    fileListId: number
    shipping?: CampaignShippingUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutContactListInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutContactListInput, CampaignUncheckedCreateWithoutContactListInput>
  }

  export type CampaignCreateManyContactListInputEnvelope = {
    data: CampaignCreateManyContactListInput | CampaignCreateManyContactListInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutContactListsInput = {
    update: XOR<CompanyUpdateWithoutContactListsInput, CompanyUncheckedUpdateWithoutContactListsInput>
    create: XOR<CompanyCreateWithoutContactListsInput, CompanyUncheckedCreateWithoutContactListsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContactListsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContactListsInput, CompanyUncheckedUpdateWithoutContactListsInput>
  }

  export type CompanyUpdateWithoutContactListsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContactListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactListItemUpsertWithWhereUniqueWithoutContactListInput = {
    where: ContactListItemWhereUniqueInput
    update: XOR<ContactListItemUpdateWithoutContactListInput, ContactListItemUncheckedUpdateWithoutContactListInput>
    create: XOR<ContactListItemCreateWithoutContactListInput, ContactListItemUncheckedCreateWithoutContactListInput>
  }

  export type ContactListItemUpdateWithWhereUniqueWithoutContactListInput = {
    where: ContactListItemWhereUniqueInput
    data: XOR<ContactListItemUpdateWithoutContactListInput, ContactListItemUncheckedUpdateWithoutContactListInput>
  }

  export type ContactListItemUpdateManyWithWhereWithoutContactListInput = {
    where: ContactListItemScalarWhereInput
    data: XOR<ContactListItemUpdateManyMutationInput, ContactListItemUncheckedUpdateManyWithoutContactListInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutContactListInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutContactListInput, CampaignUncheckedUpdateWithoutContactListInput>
    create: XOR<CampaignCreateWithoutContactListInput, CampaignUncheckedCreateWithoutContactListInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutContactListInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutContactListInput, CampaignUncheckedUpdateWithoutContactListInput>
  }

  export type CampaignUpdateManyWithWhereWithoutContactListInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutContactListInput>
  }

  export type CompanyCreateWithoutContactListItemsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContactListItemsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContactListItemsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContactListItemsInput, CompanyUncheckedCreateWithoutContactListItemsInput>
  }

  export type ContactListCreateWithoutItemsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactListsInput
    Campaign?: CampaignCreateNestedManyWithoutContactListInput
  }

  export type ContactListUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    Campaign?: CampaignUncheckedCreateNestedManyWithoutContactListInput
  }

  export type ContactListCreateOrConnectWithoutItemsInput = {
    where: ContactListWhereUniqueInput
    create: XOR<ContactListCreateWithoutItemsInput, ContactListUncheckedCreateWithoutItemsInput>
  }

  export type CampaignShippingCreateWithoutContactInput = {
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutShippingInput
  }

  export type CampaignShippingUncheckedCreateWithoutContactInput = {
    id?: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    campaignId: number
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignShippingCreateOrConnectWithoutContactInput = {
    where: CampaignShippingWhereUniqueInput
    create: XOR<CampaignShippingCreateWithoutContactInput, CampaignShippingUncheckedCreateWithoutContactInput>
  }

  export type CampaignShippingCreateManyContactInputEnvelope = {
    data: CampaignShippingCreateManyContactInput | CampaignShippingCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutContactListItemsInput = {
    update: XOR<CompanyUpdateWithoutContactListItemsInput, CompanyUncheckedUpdateWithoutContactListItemsInput>
    create: XOR<CompanyCreateWithoutContactListItemsInput, CompanyUncheckedCreateWithoutContactListItemsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContactListItemsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContactListItemsInput, CompanyUncheckedUpdateWithoutContactListItemsInput>
  }

  export type CompanyUpdateWithoutContactListItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContactListItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactListUpsertWithoutItemsInput = {
    update: XOR<ContactListUpdateWithoutItemsInput, ContactListUncheckedUpdateWithoutItemsInput>
    create: XOR<ContactListCreateWithoutItemsInput, ContactListUncheckedCreateWithoutItemsInput>
    where?: ContactListWhereInput
  }

  export type ContactListUpdateToOneWithWhereWithoutItemsInput = {
    where?: ContactListWhereInput
    data: XOR<ContactListUpdateWithoutItemsInput, ContactListUncheckedUpdateWithoutItemsInput>
  }

  export type ContactListUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactListsNestedInput
    Campaign?: CampaignUpdateManyWithoutContactListNestedInput
  }

  export type ContactListUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    Campaign?: CampaignUncheckedUpdateManyWithoutContactListNestedInput
  }

  export type CampaignShippingUpsertWithWhereUniqueWithoutContactInput = {
    where: CampaignShippingWhereUniqueInput
    update: XOR<CampaignShippingUpdateWithoutContactInput, CampaignShippingUncheckedUpdateWithoutContactInput>
    create: XOR<CampaignShippingCreateWithoutContactInput, CampaignShippingUncheckedCreateWithoutContactInput>
  }

  export type CampaignShippingUpdateWithWhereUniqueWithoutContactInput = {
    where: CampaignShippingWhereUniqueInput
    data: XOR<CampaignShippingUpdateWithoutContactInput, CampaignShippingUncheckedUpdateWithoutContactInput>
  }

  export type CampaignShippingUpdateManyWithWhereWithoutContactInput = {
    where: CampaignShippingScalarWhereInput
    data: XOR<CampaignShippingUpdateManyMutationInput, CampaignShippingUncheckedUpdateManyWithoutContactInput>
  }

  export type CompanyCreateWithoutFilessInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFilessInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFilessInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFilessInput, CompanyUncheckedCreateWithoutFilessInput>
  }

  export type FilesOptionsCreateWithoutFileInput = {
    name: string
    path: string
    mediaType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FilesOptionsUncheckedCreateWithoutFileInput = {
    id?: number
    name: string
    path: string
    mediaType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FilesOptionsCreateOrConnectWithoutFileInput = {
    where: FilesOptionsWhereUniqueInput
    create: XOR<FilesOptionsCreateWithoutFileInput, FilesOptionsUncheckedCreateWithoutFileInput>
  }

  export type FilesOptionsCreateManyFileInputEnvelope = {
    data: FilesOptionsCreateManyFileInput | FilesOptionsCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutFileListInput = {
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCampaignsInput
    contactList?: ContactListCreateNestedOneWithoutCampaignInput
    whatsapp?: WhatsappCreateNestedOneWithoutCampaignInput
    shipping?: CampaignShippingCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutFileListInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    whatsappId?: number | null
    shipping?: CampaignShippingUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutFileListInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutFileListInput, CampaignUncheckedCreateWithoutFileListInput>
  }

  export type CampaignCreateManyFileListInputEnvelope = {
    data: CampaignCreateManyFileListInput | CampaignCreateManyFileListInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutFilessInput = {
    update: XOR<CompanyUpdateWithoutFilessInput, CompanyUncheckedUpdateWithoutFilessInput>
    create: XOR<CompanyCreateWithoutFilessInput, CompanyUncheckedCreateWithoutFilessInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFilessInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFilessInput, CompanyUncheckedUpdateWithoutFilessInput>
  }

  export type CompanyUpdateWithoutFilessInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFilessInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FilesOptionsUpsertWithWhereUniqueWithoutFileInput = {
    where: FilesOptionsWhereUniqueInput
    update: XOR<FilesOptionsUpdateWithoutFileInput, FilesOptionsUncheckedUpdateWithoutFileInput>
    create: XOR<FilesOptionsCreateWithoutFileInput, FilesOptionsUncheckedCreateWithoutFileInput>
  }

  export type FilesOptionsUpdateWithWhereUniqueWithoutFileInput = {
    where: FilesOptionsWhereUniqueInput
    data: XOR<FilesOptionsUpdateWithoutFileInput, FilesOptionsUncheckedUpdateWithoutFileInput>
  }

  export type FilesOptionsUpdateManyWithWhereWithoutFileInput = {
    where: FilesOptionsScalarWhereInput
    data: XOR<FilesOptionsUpdateManyMutationInput, FilesOptionsUncheckedUpdateManyWithoutFileInput>
  }

  export type FilesOptionsScalarWhereInput = {
    AND?: FilesOptionsScalarWhereInput | FilesOptionsScalarWhereInput[]
    OR?: FilesOptionsScalarWhereInput[]
    NOT?: FilesOptionsScalarWhereInput | FilesOptionsScalarWhereInput[]
    id?: IntFilter<"FilesOptions"> | number
    name?: StringFilter<"FilesOptions"> | string
    path?: StringFilter<"FilesOptions"> | string
    mediaType?: StringFilter<"FilesOptions"> | string
    createdAt?: DateTimeFilter<"FilesOptions"> | Date | string
    updatedAt?: DateTimeFilter<"FilesOptions"> | Date | string
    fileId?: IntFilter<"FilesOptions"> | number
  }

  export type CampaignUpsertWithWhereUniqueWithoutFileListInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutFileListInput, CampaignUncheckedUpdateWithoutFileListInput>
    create: XOR<CampaignCreateWithoutFileListInput, CampaignUncheckedCreateWithoutFileListInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutFileListInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutFileListInput, CampaignUncheckedUpdateWithoutFileListInput>
  }

  export type CampaignUpdateManyWithWhereWithoutFileListInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutFileListInput>
  }

  export type FilesCreateWithoutOptionsInput = {
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutFilessInput
    Campaign?: CampaignCreateNestedManyWithoutFileListInput
  }

  export type FilesUncheckedCreateWithoutOptionsInput = {
    id?: number
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    Campaign?: CampaignUncheckedCreateNestedManyWithoutFileListInput
  }

  export type FilesCreateOrConnectWithoutOptionsInput = {
    where: FilesWhereUniqueInput
    create: XOR<FilesCreateWithoutOptionsInput, FilesUncheckedCreateWithoutOptionsInput>
  }

  export type FilesUpsertWithoutOptionsInput = {
    update: XOR<FilesUpdateWithoutOptionsInput, FilesUncheckedUpdateWithoutOptionsInput>
    create: XOR<FilesCreateWithoutOptionsInput, FilesUncheckedCreateWithoutOptionsInput>
    where?: FilesWhereInput
  }

  export type FilesUpdateToOneWithWhereWithoutOptionsInput = {
    where?: FilesWhereInput
    data: XOR<FilesUpdateWithoutOptionsInput, FilesUncheckedUpdateWithoutOptionsInput>
  }

  export type FilesUpdateWithoutOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutFilessNestedInput
    Campaign?: CampaignUpdateManyWithoutFileListNestedInput
  }

  export type FilesUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    Campaign?: CampaignUncheckedUpdateManyWithoutFileListNestedInput
  }

  export type Action_LogsCreateWithoutSystem_LogsInput = {
    action: string
    message?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAction_LogsInput
    ticket?: TicketCreateNestedOneWithoutAction_LogsInput
  }

  export type Action_LogsUncheckedCreateWithoutSystem_LogsInput = {
    id?: number
    userId: number
    ticketId?: number | null
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type Action_LogsCreateOrConnectWithoutSystem_LogsInput = {
    where: Action_LogsWhereUniqueInput
    create: XOR<Action_LogsCreateWithoutSystem_LogsInput, Action_LogsUncheckedCreateWithoutSystem_LogsInput>
  }

  export type Action_LogsUpsertWithoutSystem_LogsInput = {
    update: XOR<Action_LogsUpdateWithoutSystem_LogsInput, Action_LogsUncheckedUpdateWithoutSystem_LogsInput>
    create: XOR<Action_LogsCreateWithoutSystem_LogsInput, Action_LogsUncheckedCreateWithoutSystem_LogsInput>
    where?: Action_LogsWhereInput
  }

  export type Action_LogsUpdateToOneWithWhereWithoutSystem_LogsInput = {
    where?: Action_LogsWhereInput
    data: XOR<Action_LogsUpdateWithoutSystem_LogsInput, Action_LogsUncheckedUpdateWithoutSystem_LogsInput>
  }

  export type Action_LogsUpdateWithoutSystem_LogsInput = {
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAction_LogsNestedInput
    ticket?: TicketUpdateOneWithoutAction_LogsNestedInput
  }

  export type Action_LogsUncheckedUpdateWithoutSystem_LogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAction_LogsInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAction_LogsInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAction_LogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAction_LogsInput, UserUncheckedCreateWithoutAction_LogsInput>
  }

  export type TicketCreateWithoutAction_LogsInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAction_LogsInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAction_LogsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAction_LogsInput, TicketUncheckedCreateWithoutAction_LogsInput>
  }

  export type System_LogsCreateWithoutActionLogInput = {
    level: string
    message: string
    createdAt?: Date | string
  }

  export type System_LogsUncheckedCreateWithoutActionLogInput = {
    id?: number
    level: string
    message: string
    createdAt?: Date | string
  }

  export type System_LogsCreateOrConnectWithoutActionLogInput = {
    where: System_LogsWhereUniqueInput
    create: XOR<System_LogsCreateWithoutActionLogInput, System_LogsUncheckedCreateWithoutActionLogInput>
  }

  export type System_LogsCreateManyActionLogInputEnvelope = {
    data: System_LogsCreateManyActionLogInput | System_LogsCreateManyActionLogInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAction_LogsInput = {
    update: XOR<UserUpdateWithoutAction_LogsInput, UserUncheckedUpdateWithoutAction_LogsInput>
    create: XOR<UserCreateWithoutAction_LogsInput, UserUncheckedCreateWithoutAction_LogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAction_LogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAction_LogsInput, UserUncheckedUpdateWithoutAction_LogsInput>
  }

  export type UserUpdateWithoutAction_LogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAction_LogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type TicketUpsertWithoutAction_LogsInput = {
    update: XOR<TicketUpdateWithoutAction_LogsInput, TicketUncheckedUpdateWithoutAction_LogsInput>
    create: XOR<TicketCreateWithoutAction_LogsInput, TicketUncheckedCreateWithoutAction_LogsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutAction_LogsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutAction_LogsInput, TicketUncheckedUpdateWithoutAction_LogsInput>
  }

  export type TicketUpdateWithoutAction_LogsInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAction_LogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type System_LogsUpsertWithWhereUniqueWithoutActionLogInput = {
    where: System_LogsWhereUniqueInput
    update: XOR<System_LogsUpdateWithoutActionLogInput, System_LogsUncheckedUpdateWithoutActionLogInput>
    create: XOR<System_LogsCreateWithoutActionLogInput, System_LogsUncheckedCreateWithoutActionLogInput>
  }

  export type System_LogsUpdateWithWhereUniqueWithoutActionLogInput = {
    where: System_LogsWhereUniqueInput
    data: XOR<System_LogsUpdateWithoutActionLogInput, System_LogsUncheckedUpdateWithoutActionLogInput>
  }

  export type System_LogsUpdateManyWithWhereWithoutActionLogInput = {
    where: System_LogsScalarWhereInput
    data: XOR<System_LogsUpdateManyMutationInput, System_LogsUncheckedUpdateManyWithoutActionLogInput>
  }

  export type System_LogsScalarWhereInput = {
    AND?: System_LogsScalarWhereInput | System_LogsScalarWhereInput[]
    OR?: System_LogsScalarWhereInput[]
    NOT?: System_LogsScalarWhereInput | System_LogsScalarWhereInput[]
    id?: IntFilter<"System_Logs"> | number
    level?: StringFilter<"System_Logs"> | string
    message?: StringFilter<"System_Logs"> | string
    createdAt?: DateTimeFilter<"System_Logs"> | Date | string
    actionLogId?: IntNullableFilter<"System_Logs"> | number | null
  }

  export type MessageCreateWithoutMessageInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsg?: MessageCreateNestedOneWithoutMessageInput
    ticket?: TicketCreateNestedOneWithoutMessagesInput
    contact?: ContactCreateNestedOneWithoutMessageInput
    company: CompanyCreateNestedOneWithoutMessagesInput
    queue?: QueueCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutMessageInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
  }

  export type MessageCreateOrConnectWithoutMessageInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMessageInput, MessageUncheckedCreateWithoutMessageInput>
  }

  export type TicketCreateWithoutMessagesInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutMessagesInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutMessagesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
  }

  export type ContactCreateWithoutMessageInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutMessageInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutMessageInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutMessageInput, ContactUncheckedCreateWithoutMessageInput>
  }

  export type CompanyCreateWithoutMessagesInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMessagesInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMessagesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMessagesInput, CompanyUncheckedCreateWithoutMessagesInput>
  }

  export type QueueCreateWithoutMessageInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutMessageInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutMessageInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutMessageInput, QueueUncheckedCreateWithoutMessageInput>
  }

  export type MessageCreateWithoutQuotedMsgInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket?: TicketCreateNestedOneWithoutMessagesInput
    contact?: ContactCreateNestedOneWithoutMessageInput
    company: CompanyCreateNestedOneWithoutMessagesInput
    queue?: QueueCreateNestedOneWithoutMessageInput
    Message?: MessageCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUncheckedCreateWithoutQuotedMsgInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId?: number | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
    Message?: MessageUncheckedCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageCreateOrConnectWithoutQuotedMsgInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutQuotedMsgInput, MessageUncheckedCreateWithoutQuotedMsgInput>
  }

  export type MessageCreateManyQuotedMsgInputEnvelope = {
    data: MessageCreateManyQuotedMsgInput | MessageCreateManyQuotedMsgInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithoutMessageInput = {
    update: XOR<MessageUpdateWithoutMessageInput, MessageUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageCreateWithoutMessageInput, MessageUncheckedCreateWithoutMessageInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutMessageInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutMessageInput, MessageUncheckedUpdateWithoutMessageInput>
  }

  export type MessageUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsg?: MessageUpdateOneWithoutMessageNestedInput
    ticket?: TicketUpdateOneWithoutMessagesNestedInput
    contact?: ContactUpdateOneWithoutMessageNestedInput
    company?: CompanyUpdateOneRequiredWithoutMessagesNestedInput
    queue?: QueueUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketUpsertWithoutMessagesInput = {
    update: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type TicketUpdateWithoutMessagesInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type ContactUpsertWithoutMessageInput = {
    update: XOR<ContactUpdateWithoutMessageInput, ContactUncheckedUpdateWithoutMessageInput>
    create: XOR<ContactCreateWithoutMessageInput, ContactUncheckedCreateWithoutMessageInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutMessageInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutMessageInput, ContactUncheckedUpdateWithoutMessageInput>
  }

  export type ContactUpdateWithoutMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CompanyUpsertWithoutMessagesInput = {
    update: XOR<CompanyUpdateWithoutMessagesInput, CompanyUncheckedUpdateWithoutMessagesInput>
    create: XOR<CompanyCreateWithoutMessagesInput, CompanyUncheckedCreateWithoutMessagesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutMessagesInput, CompanyUncheckedUpdateWithoutMessagesInput>
  }

  export type CompanyUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type QueueUpsertWithoutMessageInput = {
    update: XOR<QueueUpdateWithoutMessageInput, QueueUncheckedUpdateWithoutMessageInput>
    create: XOR<QueueCreateWithoutMessageInput, QueueUncheckedCreateWithoutMessageInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutMessageInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutMessageInput, QueueUncheckedUpdateWithoutMessageInput>
  }

  export type QueueUpdateWithoutMessageInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutQuotedMsgInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutQuotedMsgInput, MessageUncheckedUpdateWithoutQuotedMsgInput>
    create: XOR<MessageCreateWithoutQuotedMsgInput, MessageUncheckedCreateWithoutQuotedMsgInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutQuotedMsgInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutQuotedMsgInput, MessageUncheckedUpdateWithoutQuotedMsgInput>
  }

  export type MessageUpdateManyWithWhereWithoutQuotedMsgInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutQuotedMsgInput>
  }

  export type CompanyCreateWithoutPlanInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPlanInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
  }

  export type CompanyCreateManyPlanInputEnvelope = {
    data: CompanyCreateManyPlanInput | CompanyCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithWhereUniqueWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutPlanInput, CompanyUncheckedUpdateWithoutPlanInput>
    create: XOR<CompanyCreateWithoutPlanInput, CompanyUncheckedCreateWithoutPlanInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutPlanInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutPlanInput, CompanyUncheckedUpdateWithoutPlanInput>
  }

  export type CompanyUpdateManyWithWhereWithoutPlanInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutPlanInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    status?: BoolFilter<"Company"> | boolean
    dueDate?: DateTimeFilter<"Company"> | Date | string
    recurrence?: StringFilter<"Company"> | string
    planId?: IntFilter<"Company"> | number
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type QueueCreateWithoutPromptInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutPromptInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutPromptInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutPromptInput, QueueUncheckedCreateWithoutPromptInput>
  }

  export type CompanyCreateWithoutPromptsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPromptsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPromptsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPromptsInput, CompanyUncheckedCreateWithoutPromptsInput>
  }

  export type WhatsappCreateWithoutPromptInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutPromptInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutPromptInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutPromptInput, WhatsappUncheckedCreateWithoutPromptInput>
  }

  export type WhatsappCreateManyPromptInputEnvelope = {
    data: WhatsappCreateManyPromptInput | WhatsappCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutPromptInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutPromptInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutPromptInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPromptInput, TicketUncheckedCreateWithoutPromptInput>
  }

  export type TicketCreateManyPromptInputEnvelope = {
    data: TicketCreateManyPromptInput | TicketCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type QueueUpsertWithoutPromptInput = {
    update: XOR<QueueUpdateWithoutPromptInput, QueueUncheckedUpdateWithoutPromptInput>
    create: XOR<QueueCreateWithoutPromptInput, QueueUncheckedCreateWithoutPromptInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutPromptInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutPromptInput, QueueUncheckedUpdateWithoutPromptInput>
  }

  export type QueueUpdateWithoutPromptInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutPromptInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type CompanyUpsertWithoutPromptsInput = {
    update: XOR<CompanyUpdateWithoutPromptsInput, CompanyUncheckedUpdateWithoutPromptsInput>
    create: XOR<CompanyCreateWithoutPromptsInput, CompanyUncheckedCreateWithoutPromptsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPromptsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPromptsInput, CompanyUncheckedUpdateWithoutPromptsInput>
  }

  export type CompanyUpdateWithoutPromptsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPromptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WhatsappUpsertWithWhereUniqueWithoutPromptInput = {
    where: WhatsappWhereUniqueInput
    update: XOR<WhatsappUpdateWithoutPromptInput, WhatsappUncheckedUpdateWithoutPromptInput>
    create: XOR<WhatsappCreateWithoutPromptInput, WhatsappUncheckedCreateWithoutPromptInput>
  }

  export type WhatsappUpdateWithWhereUniqueWithoutPromptInput = {
    where: WhatsappWhereUniqueInput
    data: XOR<WhatsappUpdateWithoutPromptInput, WhatsappUncheckedUpdateWithoutPromptInput>
  }

  export type WhatsappUpdateManyWithWhereWithoutPromptInput = {
    where: WhatsappScalarWhereInput
    data: XOR<WhatsappUpdateManyMutationInput, WhatsappUncheckedUpdateManyWithoutPromptInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutPromptInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutPromptInput, TicketUncheckedUpdateWithoutPromptInput>
    create: XOR<TicketCreateWithoutPromptInput, TicketUncheckedCreateWithoutPromptInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutPromptInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutPromptInput, TicketUncheckedUpdateWithoutPromptInput>
  }

  export type TicketUpdateManyWithWhereWithoutPromptInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutPromptInput>
  }

  export type CompanyCreateWithoutQueueInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutQueueInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutQueueInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutQueueInput, CompanyUncheckedCreateWithoutQueueInput>
  }

  export type WhatsappCreateWithoutQueuesInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutQueuesInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutQueuesInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutQueuesInput, WhatsappUncheckedCreateWithoutQueuesInput>
  }

  export type UserCreateWithoutQueuesInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQueuesInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQueuesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQueuesInput, UserUncheckedCreateWithoutQueuesInput>
  }

  export type QueueOptionCreateWithoutQueueInput = {
    title: string
    message?: string | null
    option?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: QueueOptionCreateNestedOneWithoutQueueOptionInput
    Ticket?: TicketCreateNestedManyWithoutQueueOptionInput
    QueueOption?: QueueOptionCreateNestedManyWithoutParentInput
  }

  export type QueueOptionUncheckedCreateWithoutQueueInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueOptionInput
    QueueOption?: QueueOptionUncheckedCreateNestedManyWithoutParentInput
  }

  export type QueueOptionCreateOrConnectWithoutQueueInput = {
    where: QueueOptionWhereUniqueInput
    create: XOR<QueueOptionCreateWithoutQueueInput, QueueOptionUncheckedCreateWithoutQueueInput>
  }

  export type QueueOptionCreateManyQueueInputEnvelope = {
    data: QueueOptionCreateManyQueueInput | QueueOptionCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type QueueIntegrationsCreateWithoutQueueInput = {
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutQueueIntegrationssInput
    Ticket?: TicketCreateNestedManyWithoutQueueIntegrationInput
  }

  export type QueueIntegrationsUncheckedCreateWithoutQueueInput = {
    id?: number
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    companyId: number
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueIntegrationInput
  }

  export type QueueIntegrationsCreateOrConnectWithoutQueueInput = {
    where: QueueIntegrationsWhereUniqueInput
    create: XOR<QueueIntegrationsCreateWithoutQueueInput, QueueIntegrationsUncheckedCreateWithoutQueueInput>
  }

  export type PromptCreateWithoutQueueInput = {
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPromptsInput
    Whatsapp?: WhatsappCreateNestedManyWithoutPromptInput
    Ticket?: TicketCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutQueueInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Whatsapp?: WhatsappUncheckedCreateNestedManyWithoutPromptInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutQueueInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutQueueInput, PromptUncheckedCreateWithoutQueueInput>
  }

  export type PromptCreateManyQueueInputEnvelope = {
    data: PromptCreateManyQueueInput | PromptCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type UserQueueCreateWithoutQueueInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserQueueInput
  }

  export type UserQueueUncheckedCreateWithoutQueueInput = {
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQueueCreateOrConnectWithoutQueueInput = {
    where: UserQueueWhereUniqueInput
    create: XOR<UserQueueCreateWithoutQueueInput, UserQueueUncheckedCreateWithoutQueueInput>
  }

  export type UserQueueCreateManyQueueInputEnvelope = {
    data: UserQueueCreateManyQueueInput | UserQueueCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type WhatsappQueueCreateWithoutQueueInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsapp: WhatsappCreateNestedOneWithoutWhatsappQueuesInput
  }

  export type WhatsappQueueUncheckedCreateWithoutQueueInput = {
    whatsappId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappQueueCreateOrConnectWithoutQueueInput = {
    where: WhatsappQueueWhereUniqueInput
    create: XOR<WhatsappQueueCreateWithoutQueueInput, WhatsappQueueUncheckedCreateWithoutQueueInput>
  }

  export type WhatsappQueueCreateManyQueueInputEnvelope = {
    data: WhatsappQueueCreateManyQueueInput | WhatsappQueueCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutQueueInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutQueueInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutQueueInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutQueueInput, TicketUncheckedCreateWithoutQueueInput>
  }

  export type TicketCreateManyQueueInputEnvelope = {
    data: TicketCreateManyQueueInput | TicketCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutQueueInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsg?: MessageCreateNestedOneWithoutMessageInput
    ticket?: TicketCreateNestedOneWithoutMessagesInput
    contact?: ContactCreateNestedOneWithoutMessageInput
    company: CompanyCreateNestedOneWithoutMessagesInput
    Message?: MessageCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUncheckedCreateWithoutQueueInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    companyId: number
    Message?: MessageUncheckedCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageCreateOrConnectWithoutQueueInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutQueueInput, MessageUncheckedCreateWithoutQueueInput>
  }

  export type MessageCreateManyQueueInputEnvelope = {
    data: MessageCreateManyQueueInput | MessageCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutQueuesInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutQueuesInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutQueuesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutQueuesInput, CompanyUncheckedCreateWithoutQueuesInput>
  }

  export type CompanyUpsertWithoutQueueInput = {
    update: XOR<CompanyUpdateWithoutQueueInput, CompanyUncheckedUpdateWithoutQueueInput>
    create: XOR<CompanyCreateWithoutQueueInput, CompanyUncheckedCreateWithoutQueueInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutQueueInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutQueueInput, CompanyUncheckedUpdateWithoutQueueInput>
  }

  export type CompanyUpdateWithoutQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WhatsappUpsertWithWhereUniqueWithoutQueuesInput = {
    where: WhatsappWhereUniqueInput
    update: XOR<WhatsappUpdateWithoutQueuesInput, WhatsappUncheckedUpdateWithoutQueuesInput>
    create: XOR<WhatsappCreateWithoutQueuesInput, WhatsappUncheckedCreateWithoutQueuesInput>
  }

  export type WhatsappUpdateWithWhereUniqueWithoutQueuesInput = {
    where: WhatsappWhereUniqueInput
    data: XOR<WhatsappUpdateWithoutQueuesInput, WhatsappUncheckedUpdateWithoutQueuesInput>
  }

  export type WhatsappUpdateManyWithWhereWithoutQueuesInput = {
    where: WhatsappScalarWhereInput
    data: XOR<WhatsappUpdateManyMutationInput, WhatsappUncheckedUpdateManyWithoutQueuesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutQueuesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutQueuesInput, UserUncheckedUpdateWithoutQueuesInput>
    create: XOR<UserCreateWithoutQueuesInput, UserUncheckedCreateWithoutQueuesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutQueuesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutQueuesInput, UserUncheckedUpdateWithoutQueuesInput>
  }

  export type UserUpdateManyWithWhereWithoutQueuesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutQueuesInput>
  }

  export type QueueOptionUpsertWithWhereUniqueWithoutQueueInput = {
    where: QueueOptionWhereUniqueInput
    update: XOR<QueueOptionUpdateWithoutQueueInput, QueueOptionUncheckedUpdateWithoutQueueInput>
    create: XOR<QueueOptionCreateWithoutQueueInput, QueueOptionUncheckedCreateWithoutQueueInput>
  }

  export type QueueOptionUpdateWithWhereUniqueWithoutQueueInput = {
    where: QueueOptionWhereUniqueInput
    data: XOR<QueueOptionUpdateWithoutQueueInput, QueueOptionUncheckedUpdateWithoutQueueInput>
  }

  export type QueueOptionUpdateManyWithWhereWithoutQueueInput = {
    where: QueueOptionScalarWhereInput
    data: XOR<QueueOptionUpdateManyMutationInput, QueueOptionUncheckedUpdateManyWithoutQueueInput>
  }

  export type QueueOptionScalarWhereInput = {
    AND?: QueueOptionScalarWhereInput | QueueOptionScalarWhereInput[]
    OR?: QueueOptionScalarWhereInput[]
    NOT?: QueueOptionScalarWhereInput | QueueOptionScalarWhereInput[]
    id?: IntFilter<"QueueOption"> | number
    title?: StringFilter<"QueueOption"> | string
    message?: StringNullableFilter<"QueueOption"> | string | null
    option?: StringNullableFilter<"QueueOption"> | string | null
    queueId?: IntFilter<"QueueOption"> | number
    parentId?: IntNullableFilter<"QueueOption"> | number | null
    createdAt?: DateTimeFilter<"QueueOption"> | Date | string
    updatedAt?: DateTimeFilter<"QueueOption"> | Date | string
  }

  export type QueueIntegrationsUpsertWithoutQueueInput = {
    update: XOR<QueueIntegrationsUpdateWithoutQueueInput, QueueIntegrationsUncheckedUpdateWithoutQueueInput>
    create: XOR<QueueIntegrationsCreateWithoutQueueInput, QueueIntegrationsUncheckedCreateWithoutQueueInput>
    where?: QueueIntegrationsWhereInput
  }

  export type QueueIntegrationsUpdateToOneWithWhereWithoutQueueInput = {
    where?: QueueIntegrationsWhereInput
    data: XOR<QueueIntegrationsUpdateWithoutQueueInput, QueueIntegrationsUncheckedUpdateWithoutQueueInput>
  }

  export type QueueIntegrationsUpdateWithoutQueueInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutQueueIntegrationssNestedInput
    Ticket?: TicketUpdateManyWithoutQueueIntegrationNestedInput
  }

  export type QueueIntegrationsUncheckedUpdateWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueIntegrationNestedInput
  }

  export type PromptUpsertWithWhereUniqueWithoutQueueInput = {
    where: PromptWhereUniqueInput
    update: XOR<PromptUpdateWithoutQueueInput, PromptUncheckedUpdateWithoutQueueInput>
    create: XOR<PromptCreateWithoutQueueInput, PromptUncheckedCreateWithoutQueueInput>
  }

  export type PromptUpdateWithWhereUniqueWithoutQueueInput = {
    where: PromptWhereUniqueInput
    data: XOR<PromptUpdateWithoutQueueInput, PromptUncheckedUpdateWithoutQueueInput>
  }

  export type PromptUpdateManyWithWhereWithoutQueueInput = {
    where: PromptScalarWhereInput
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyWithoutQueueInput>
  }

  export type UserQueueUpsertWithWhereUniqueWithoutQueueInput = {
    where: UserQueueWhereUniqueInput
    update: XOR<UserQueueUpdateWithoutQueueInput, UserQueueUncheckedUpdateWithoutQueueInput>
    create: XOR<UserQueueCreateWithoutQueueInput, UserQueueUncheckedCreateWithoutQueueInput>
  }

  export type UserQueueUpdateWithWhereUniqueWithoutQueueInput = {
    where: UserQueueWhereUniqueInput
    data: XOR<UserQueueUpdateWithoutQueueInput, UserQueueUncheckedUpdateWithoutQueueInput>
  }

  export type UserQueueUpdateManyWithWhereWithoutQueueInput = {
    where: UserQueueScalarWhereInput
    data: XOR<UserQueueUpdateManyMutationInput, UserQueueUncheckedUpdateManyWithoutQueueInput>
  }

  export type UserQueueScalarWhereInput = {
    AND?: UserQueueScalarWhereInput | UserQueueScalarWhereInput[]
    OR?: UserQueueScalarWhereInput[]
    NOT?: UserQueueScalarWhereInput | UserQueueScalarWhereInput[]
    userId?: IntFilter<"UserQueue"> | number
    queueId?: IntFilter<"UserQueue"> | number
    createdAt?: DateTimeFilter<"UserQueue"> | Date | string
    updatedAt?: DateTimeFilter<"UserQueue"> | Date | string
  }

  export type WhatsappQueueUpsertWithWhereUniqueWithoutQueueInput = {
    where: WhatsappQueueWhereUniqueInput
    update: XOR<WhatsappQueueUpdateWithoutQueueInput, WhatsappQueueUncheckedUpdateWithoutQueueInput>
    create: XOR<WhatsappQueueCreateWithoutQueueInput, WhatsappQueueUncheckedCreateWithoutQueueInput>
  }

  export type WhatsappQueueUpdateWithWhereUniqueWithoutQueueInput = {
    where: WhatsappQueueWhereUniqueInput
    data: XOR<WhatsappQueueUpdateWithoutQueueInput, WhatsappQueueUncheckedUpdateWithoutQueueInput>
  }

  export type WhatsappQueueUpdateManyWithWhereWithoutQueueInput = {
    where: WhatsappQueueScalarWhereInput
    data: XOR<WhatsappQueueUpdateManyMutationInput, WhatsappQueueUncheckedUpdateManyWithoutQueueInput>
  }

  export type WhatsappQueueScalarWhereInput = {
    AND?: WhatsappQueueScalarWhereInput | WhatsappQueueScalarWhereInput[]
    OR?: WhatsappQueueScalarWhereInput[]
    NOT?: WhatsappQueueScalarWhereInput | WhatsappQueueScalarWhereInput[]
    whatsappId?: IntFilter<"WhatsappQueue"> | number
    queueId?: IntFilter<"WhatsappQueue"> | number
    createdAt?: DateTimeFilter<"WhatsappQueue"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappQueue"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutQueueInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutQueueInput, TicketUncheckedUpdateWithoutQueueInput>
    create: XOR<TicketCreateWithoutQueueInput, TicketUncheckedCreateWithoutQueueInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutQueueInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutQueueInput, TicketUncheckedUpdateWithoutQueueInput>
  }

  export type TicketUpdateManyWithWhereWithoutQueueInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutQueueInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutQueueInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutQueueInput, MessageUncheckedUpdateWithoutQueueInput>
    create: XOR<MessageCreateWithoutQueueInput, MessageUncheckedCreateWithoutQueueInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutQueueInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutQueueInput, MessageUncheckedUpdateWithoutQueueInput>
  }

  export type MessageUpdateManyWithWhereWithoutQueueInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutQueueInput>
  }

  export type CompanyUpsertWithWhereUniqueWithoutQueuesInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutQueuesInput, CompanyUncheckedUpdateWithoutQueuesInput>
    create: XOR<CompanyCreateWithoutQueuesInput, CompanyUncheckedCreateWithoutQueuesInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutQueuesInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutQueuesInput, CompanyUncheckedUpdateWithoutQueuesInput>
  }

  export type CompanyUpdateManyWithWhereWithoutQueuesInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutQueuesInput>
  }

  export type CompanyCreateWithoutQueueIntegrationssInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutQueueIntegrationssInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutQueueIntegrationssInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutQueueIntegrationssInput, CompanyUncheckedCreateWithoutQueueIntegrationssInput>
  }

  export type TicketCreateWithoutQueueIntegrationInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutQueueIntegrationInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutQueueIntegrationInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutQueueIntegrationInput, TicketUncheckedCreateWithoutQueueIntegrationInput>
  }

  export type TicketCreateManyQueueIntegrationInputEnvelope = {
    data: TicketCreateManyQueueIntegrationInput | TicketCreateManyQueueIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type QueueCreateWithoutQueueIntegrationsInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutQueueIntegrationsInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutQueueIntegrationsInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutQueueIntegrationsInput, QueueUncheckedCreateWithoutQueueIntegrationsInput>
  }

  export type QueueCreateManyQueueIntegrationsInputEnvelope = {
    data: QueueCreateManyQueueIntegrationsInput | QueueCreateManyQueueIntegrationsInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutQueueIntegrationssInput = {
    update: XOR<CompanyUpdateWithoutQueueIntegrationssInput, CompanyUncheckedUpdateWithoutQueueIntegrationssInput>
    create: XOR<CompanyCreateWithoutQueueIntegrationssInput, CompanyUncheckedCreateWithoutQueueIntegrationssInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutQueueIntegrationssInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutQueueIntegrationssInput, CompanyUncheckedUpdateWithoutQueueIntegrationssInput>
  }

  export type CompanyUpdateWithoutQueueIntegrationssInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutQueueIntegrationssInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutQueueIntegrationInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutQueueIntegrationInput, TicketUncheckedUpdateWithoutQueueIntegrationInput>
    create: XOR<TicketCreateWithoutQueueIntegrationInput, TicketUncheckedCreateWithoutQueueIntegrationInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutQueueIntegrationInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutQueueIntegrationInput, TicketUncheckedUpdateWithoutQueueIntegrationInput>
  }

  export type TicketUpdateManyWithWhereWithoutQueueIntegrationInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutQueueIntegrationInput>
  }

  export type QueueUpsertWithWhereUniqueWithoutQueueIntegrationsInput = {
    where: QueueWhereUniqueInput
    update: XOR<QueueUpdateWithoutQueueIntegrationsInput, QueueUncheckedUpdateWithoutQueueIntegrationsInput>
    create: XOR<QueueCreateWithoutQueueIntegrationsInput, QueueUncheckedCreateWithoutQueueIntegrationsInput>
  }

  export type QueueUpdateWithWhereUniqueWithoutQueueIntegrationsInput = {
    where: QueueWhereUniqueInput
    data: XOR<QueueUpdateWithoutQueueIntegrationsInput, QueueUncheckedUpdateWithoutQueueIntegrationsInput>
  }

  export type QueueUpdateManyWithWhereWithoutQueueIntegrationsInput = {
    where: QueueScalarWhereInput
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyWithoutQueueIntegrationsInput>
  }

  export type QueueCreateWithoutOptionsInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutOptionsInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutOptionsInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutOptionsInput, QueueUncheckedCreateWithoutOptionsInput>
  }

  export type QueueOptionCreateWithoutQueueOptionInput = {
    title: string
    message?: string | null
    option?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: QueueCreateNestedOneWithoutOptionsInput
    parent?: QueueOptionCreateNestedOneWithoutQueueOptionInput
    Ticket?: TicketCreateNestedManyWithoutQueueOptionInput
  }

  export type QueueOptionUncheckedCreateWithoutQueueOptionInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    queueId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueOptionInput
  }

  export type QueueOptionCreateOrConnectWithoutQueueOptionInput = {
    where: QueueOptionWhereUniqueInput
    create: XOR<QueueOptionCreateWithoutQueueOptionInput, QueueOptionUncheckedCreateWithoutQueueOptionInput>
  }

  export type TicketCreateWithoutQueueOptionInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutQueueOptionInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutQueueOptionInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutQueueOptionInput, TicketUncheckedCreateWithoutQueueOptionInput>
  }

  export type TicketCreateManyQueueOptionInputEnvelope = {
    data: TicketCreateManyQueueOptionInput | TicketCreateManyQueueOptionInput[]
    skipDuplicates?: boolean
  }

  export type QueueOptionCreateWithoutParentInput = {
    title: string
    message?: string | null
    option?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: QueueCreateNestedOneWithoutOptionsInput
    Ticket?: TicketCreateNestedManyWithoutQueueOptionInput
    QueueOption?: QueueOptionCreateNestedManyWithoutParentInput
  }

  export type QueueOptionUncheckedCreateWithoutParentInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueOptionInput
    QueueOption?: QueueOptionUncheckedCreateNestedManyWithoutParentInput
  }

  export type QueueOptionCreateOrConnectWithoutParentInput = {
    where: QueueOptionWhereUniqueInput
    create: XOR<QueueOptionCreateWithoutParentInput, QueueOptionUncheckedCreateWithoutParentInput>
  }

  export type QueueOptionCreateManyParentInputEnvelope = {
    data: QueueOptionCreateManyParentInput | QueueOptionCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type QueueUpsertWithoutOptionsInput = {
    update: XOR<QueueUpdateWithoutOptionsInput, QueueUncheckedUpdateWithoutOptionsInput>
    create: XOR<QueueCreateWithoutOptionsInput, QueueUncheckedCreateWithoutOptionsInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutOptionsInput, QueueUncheckedUpdateWithoutOptionsInput>
  }

  export type QueueUpdateWithoutOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueOptionUpsertWithoutQueueOptionInput = {
    update: XOR<QueueOptionUpdateWithoutQueueOptionInput, QueueOptionUncheckedUpdateWithoutQueueOptionInput>
    create: XOR<QueueOptionCreateWithoutQueueOptionInput, QueueOptionUncheckedCreateWithoutQueueOptionInput>
    where?: QueueOptionWhereInput
  }

  export type QueueOptionUpdateToOneWithWhereWithoutQueueOptionInput = {
    where?: QueueOptionWhereInput
    data: XOR<QueueOptionUpdateWithoutQueueOptionInput, QueueOptionUncheckedUpdateWithoutQueueOptionInput>
  }

  export type QueueOptionUpdateWithoutQueueOptionInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutOptionsNestedInput
    parent?: QueueOptionUpdateOneWithoutQueueOptionNestedInput
    Ticket?: TicketUpdateManyWithoutQueueOptionNestedInput
  }

  export type QueueOptionUncheckedUpdateWithoutQueueOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueOptionNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutQueueOptionInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutQueueOptionInput, TicketUncheckedUpdateWithoutQueueOptionInput>
    create: XOR<TicketCreateWithoutQueueOptionInput, TicketUncheckedCreateWithoutQueueOptionInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutQueueOptionInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutQueueOptionInput, TicketUncheckedUpdateWithoutQueueOptionInput>
  }

  export type TicketUpdateManyWithWhereWithoutQueueOptionInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutQueueOptionInput>
  }

  export type QueueOptionUpsertWithWhereUniqueWithoutParentInput = {
    where: QueueOptionWhereUniqueInput
    update: XOR<QueueOptionUpdateWithoutParentInput, QueueOptionUncheckedUpdateWithoutParentInput>
    create: XOR<QueueOptionCreateWithoutParentInput, QueueOptionUncheckedCreateWithoutParentInput>
  }

  export type QueueOptionUpdateWithWhereUniqueWithoutParentInput = {
    where: QueueOptionWhereUniqueInput
    data: XOR<QueueOptionUpdateWithoutParentInput, QueueOptionUncheckedUpdateWithoutParentInput>
  }

  export type QueueOptionUpdateManyWithWhereWithoutParentInput = {
    where: QueueOptionScalarWhereInput
    data: XOR<QueueOptionUpdateManyMutationInput, QueueOptionUncheckedUpdateManyWithoutParentInput>
  }

  export type CompanyCreateWithoutQuickMessagesInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutQuickMessagesInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutQuickMessagesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutQuickMessagesInput, CompanyUncheckedCreateWithoutQuickMessagesInput>
  }

  export type UserCreateWithoutQuickMessagesInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuickMessagesInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuickMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuickMessagesInput, UserUncheckedCreateWithoutQuickMessagesInput>
  }

  export type CompanyUpsertWithoutQuickMessagesInput = {
    update: XOR<CompanyUpdateWithoutQuickMessagesInput, CompanyUncheckedUpdateWithoutQuickMessagesInput>
    create: XOR<CompanyCreateWithoutQuickMessagesInput, CompanyUncheckedCreateWithoutQuickMessagesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutQuickMessagesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutQuickMessagesInput, CompanyUncheckedUpdateWithoutQuickMessagesInput>
  }

  export type CompanyUpdateWithoutQuickMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutQuickMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutQuickMessagesInput = {
    update: XOR<UserUpdateWithoutQuickMessagesInput, UserUncheckedUpdateWithoutQuickMessagesInput>
    create: XOR<UserCreateWithoutQuickMessagesInput, UserUncheckedCreateWithoutQuickMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuickMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuickMessagesInput, UserUncheckedUpdateWithoutQuickMessagesInput>
  }

  export type UserUpdateWithoutQuickMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuickMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutRatingsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutRatingsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutRatingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutRatingsInput, CompanyUncheckedCreateWithoutRatingsInput>
  }

  export type CompanyUpsertWithoutRatingsInput = {
    update: XOR<CompanyUpdateWithoutRatingsInput, CompanyUncheckedUpdateWithoutRatingsInput>
    create: XOR<CompanyCreateWithoutRatingsInput, CompanyUncheckedCreateWithoutRatingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutRatingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutRatingsInput, CompanyUncheckedUpdateWithoutRatingsInput>
  }

  export type CompanyUpdateWithoutRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ContactCreateWithoutSchedulesInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutSchedulesInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutSchedulesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutSchedulesInput, ContactUncheckedCreateWithoutSchedulesInput>
  }

  export type TicketCreateWithoutScheduleInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutScheduleInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutScheduleInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutScheduleInput, TicketUncheckedCreateWithoutScheduleInput>
  }

  export type UserCreateWithoutScheduleInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScheduleInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScheduleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>
  }

  export type CompanyCreateWithoutSchedulesInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSchedulesInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSchedulesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
  }

  export type ContactUpsertWithoutSchedulesInput = {
    update: XOR<ContactUpdateWithoutSchedulesInput, ContactUncheckedUpdateWithoutSchedulesInput>
    create: XOR<ContactCreateWithoutSchedulesInput, ContactUncheckedCreateWithoutSchedulesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutSchedulesInput, ContactUncheckedUpdateWithoutSchedulesInput>
  }

  export type ContactUpdateWithoutSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TicketUpsertWithoutScheduleInput = {
    update: XOR<TicketUpdateWithoutScheduleInput, TicketUncheckedUpdateWithoutScheduleInput>
    create: XOR<TicketCreateWithoutScheduleInput, TicketUncheckedCreateWithoutScheduleInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutScheduleInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutScheduleInput, TicketUncheckedUpdateWithoutScheduleInput>
  }

  export type TicketUpdateWithoutScheduleInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type UserUpsertWithoutScheduleInput = {
    update: XOR<UserUpdateWithoutScheduleInput, UserUncheckedUpdateWithoutScheduleInput>
    create: XOR<UserCreateWithoutScheduleInput, UserUncheckedCreateWithoutScheduleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduleInput, UserUncheckedUpdateWithoutScheduleInput>
  }

  export type UserUpdateWithoutScheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutSchedulesInput = {
    update: XOR<CompanyUpdateWithoutSchedulesInput, CompanyUncheckedUpdateWithoutSchedulesInput>
    create: XOR<CompanyCreateWithoutSchedulesInput, CompanyUncheckedCreateWithoutSchedulesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSchedulesInput, CompanyUncheckedUpdateWithoutSchedulesInput>
  }

  export type CompanyUpdateWithoutSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutSettingsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSettingsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSettingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSettingsInput, CompanyUncheckedCreateWithoutSettingsInput>
  }

  export type CompanyUpsertWithoutSettingsInput = {
    update: XOR<CompanyUpdateWithoutSettingsInput, CompanyUncheckedUpdateWithoutSettingsInput>
    create: XOR<CompanyCreateWithoutSettingsInput, CompanyUncheckedCreateWithoutSettingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSettingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSettingsInput, CompanyUncheckedUpdateWithoutSettingsInput>
  }

  export type CompanyUpdateWithoutSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutSubscriptionsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSubscriptionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
  }

  export type CompanyUpsertWithoutSubscriptionsInput = {
    update: XOR<CompanyUpdateWithoutSubscriptionsInput, CompanyUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSubscriptionsInput, CompanyUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CompanyUpdateWithoutSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutTagsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTagsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTagsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTagsInput, CompanyUncheckedCreateWithoutTagsInput>
  }

  export type TicketTagCreateWithoutTagInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutTicketTagsInput
  }

  export type TicketTagUncheckedCreateWithoutTagInput = {
    ticketId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTagCreateOrConnectWithoutTagInput = {
    where: TicketTagWhereUniqueInput
    create: XOR<TicketTagCreateWithoutTagInput, TicketTagUncheckedCreateWithoutTagInput>
  }

  export type TicketTagCreateManyTagInputEnvelope = {
    data: TicketTagCreateManyTagInput | TicketTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutTagsInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTagsInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTagsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type CompanyUpsertWithoutTagsInput = {
    update: XOR<CompanyUpdateWithoutTagsInput, CompanyUncheckedUpdateWithoutTagsInput>
    create: XOR<CompanyCreateWithoutTagsInput, CompanyUncheckedCreateWithoutTagsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTagsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTagsInput, CompanyUncheckedUpdateWithoutTagsInput>
  }

  export type CompanyUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TicketTagUpsertWithWhereUniqueWithoutTagInput = {
    where: TicketTagWhereUniqueInput
    update: XOR<TicketTagUpdateWithoutTagInput, TicketTagUncheckedUpdateWithoutTagInput>
    create: XOR<TicketTagCreateWithoutTagInput, TicketTagUncheckedCreateWithoutTagInput>
  }

  export type TicketTagUpdateWithWhereUniqueWithoutTagInput = {
    where: TicketTagWhereUniqueInput
    data: XOR<TicketTagUpdateWithoutTagInput, TicketTagUncheckedUpdateWithoutTagInput>
  }

  export type TicketTagUpdateManyWithWhereWithoutTagInput = {
    where: TicketTagScalarWhereInput
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TicketTagScalarWhereInput = {
    AND?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
    OR?: TicketTagScalarWhereInput[]
    NOT?: TicketTagScalarWhereInput | TicketTagScalarWhereInput[]
    ticketId?: IntFilter<"TicketTag"> | number
    tagId?: IntFilter<"TicketTag"> | number
    createdAt?: DateTimeFilter<"TicketTag"> | Date | string
    updatedAt?: DateTimeFilter<"TicketTag"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
    create: XOR<TicketCreateWithoutTagsInput, TicketUncheckedCreateWithoutTagsInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTagsInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTagsInput, TicketUncheckedUpdateWithoutTagsInput>
  }

  export type TicketUpdateManyWithWhereWithoutTagsInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTagsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type ContactCreateWithoutTicketsInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTicketsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
  }

  export type WhatsappCreateWithoutTicketsInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutTicketsInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutTicketsInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutTicketsInput, WhatsappUncheckedCreateWithoutTicketsInput>
  }

  export type QueueCreateWithoutTicketInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutTicketInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutTicketInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutTicketInput, QueueUncheckedCreateWithoutTicketInput>
  }

  export type QueueOptionCreateWithoutTicketInput = {
    title: string
    message?: string | null
    option?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: QueueCreateNestedOneWithoutOptionsInput
    parent?: QueueOptionCreateNestedOneWithoutQueueOptionInput
    QueueOption?: QueueOptionCreateNestedManyWithoutParentInput
  }

  export type QueueOptionUncheckedCreateWithoutTicketInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    queueId: number
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QueueOption?: QueueOptionUncheckedCreateNestedManyWithoutParentInput
  }

  export type QueueOptionCreateOrConnectWithoutTicketInput = {
    where: QueueOptionWhereUniqueInput
    create: XOR<QueueOptionCreateWithoutTicketInput, QueueOptionUncheckedCreateWithoutTicketInput>
  }

  export type MessageCreateWithoutTicketInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsg?: MessageCreateNestedOneWithoutMessageInput
    contact?: ContactCreateNestedOneWithoutMessageInput
    company: CompanyCreateNestedOneWithoutMessagesInput
    queue?: QueueCreateNestedOneWithoutMessageInput
    Message?: MessageCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageUncheckedCreateWithoutTicketInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
    Message?: MessageUncheckedCreateNestedManyWithoutQuotedMsgInput
  }

  export type MessageCreateOrConnectWithoutTicketInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutTicketInput, MessageUncheckedCreateWithoutTicketInput>
  }

  export type MessageCreateManyTicketInputEnvelope = {
    data: MessageCreateManyTicketInput | MessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketTagCreateWithoutTicketInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    tag: TagCreateNestedOneWithoutTicketTagsInput
  }

  export type TicketTagUncheckedCreateWithoutTicketInput = {
    tagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTagCreateOrConnectWithoutTicketInput = {
    where: TicketTagWhereUniqueInput
    create: XOR<TicketTagCreateWithoutTicketInput, TicketTagUncheckedCreateWithoutTicketInput>
  }

  export type TicketTagCreateManyTicketInputEnvelope = {
    data: TicketTagCreateManyTicketInput | TicketTagCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutTicketsInput = {
    name: string
    color: string
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTagsInput
    ticketTags?: TicketTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    color: string
    companyId: number
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTicketsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput>
  }

  export type CompanyCreateWithoutTicketsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTicketsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTicketsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
  }

  export type QueueIntegrationsCreateWithoutTicketInput = {
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutQueueIntegrationssInput
    Queue?: QueueCreateNestedManyWithoutQueueIntegrationsInput
  }

  export type QueueIntegrationsUncheckedCreateWithoutTicketInput = {
    id?: number
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    companyId: number
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Queue?: QueueUncheckedCreateNestedManyWithoutQueueIntegrationsInput
  }

  export type QueueIntegrationsCreateOrConnectWithoutTicketInput = {
    where: QueueIntegrationsWhereUniqueInput
    create: XOR<QueueIntegrationsCreateWithoutTicketInput, QueueIntegrationsUncheckedCreateWithoutTicketInput>
  }

  export type PromptCreateWithoutTicketInput = {
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue?: QueueCreateNestedOneWithoutPromptInput
    company: CompanyCreateNestedOneWithoutPromptsInput
    Whatsapp?: WhatsappCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutTicketInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    queueId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Whatsapp?: WhatsappUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutTicketInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutTicketInput, PromptUncheckedCreateWithoutTicketInput>
  }

  export type UserRatingCreateWithoutTicketInput = {
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUserRatingsInput
    user: UserCreateNestedOneWithoutUserRatingInput
  }

  export type UserRatingUncheckedCreateWithoutTicketInput = {
    id?: number
    companyId: number
    userId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingCreateOrConnectWithoutTicketInput = {
    where: UserRatingWhereUniqueInput
    create: XOR<UserRatingCreateWithoutTicketInput, UserRatingUncheckedCreateWithoutTicketInput>
  }

  export type UserRatingCreateManyTicketInputEnvelope = {
    data: UserRatingCreateManyTicketInput | UserRatingCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketTrackingCreateWithoutTicketInput = {
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
    company: CompanyCreateNestedOneWithoutTicketTrackingsInput
    whatsapp?: WhatsappCreateNestedOneWithoutTicketTrackingInput
    user?: UserCreateNestedOneWithoutTicketTrackingInput
  }

  export type TicketTrackingUncheckedCreateWithoutTicketInput = {
    id?: number
    companyId: number
    whatsappId?: number | null
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketTrackingCreateOrConnectWithoutTicketInput = {
    where: TicketTrackingWhereUniqueInput
    create: XOR<TicketTrackingCreateWithoutTicketInput, TicketTrackingUncheckedCreateWithoutTicketInput>
  }

  export type TicketTrackingCreateManyTicketInputEnvelope = {
    data: TicketTrackingCreateManyTicketInput | TicketTrackingCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketNoteCreateWithoutTicketInput = {
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketNoteInput
    contact: ContactCreateNestedOneWithoutTicketNoteInput
  }

  export type TicketNoteUncheckedCreateWithoutTicketInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
  }

  export type TicketNoteCreateOrConnectWithoutTicketInput = {
    where: TicketNoteWhereUniqueInput
    create: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput>
  }

  export type TicketNoteCreateManyTicketInputEnvelope = {
    data: TicketNoteCreateManyTicketInput | TicketNoteCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutTicketInput = {
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutSchedulesInput
    user: UserCreateNestedOneWithoutScheduleInput
    company: CompanyCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutTicketInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    userId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutTicketInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutTicketInput, ScheduleUncheckedCreateWithoutTicketInput>
  }

  export type ScheduleCreateManyTicketInputEnvelope = {
    data: ScheduleCreateManyTicketInput | ScheduleCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type Action_LogsCreateWithoutTicketInput = {
    action: string
    message?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAction_LogsInput
    System_Logs?: System_LogsCreateNestedManyWithoutActionLogInput
  }

  export type Action_LogsUncheckedCreateWithoutTicketInput = {
    id?: number
    userId: number
    action: string
    message?: string | null
    createdAt?: Date | string
    System_Logs?: System_LogsUncheckedCreateNestedManyWithoutActionLogInput
  }

  export type Action_LogsCreateOrConnectWithoutTicketInput = {
    where: Action_LogsWhereUniqueInput
    create: XOR<Action_LogsCreateWithoutTicketInput, Action_LogsUncheckedCreateWithoutTicketInput>
  }

  export type Action_LogsCreateManyTicketInputEnvelope = {
    data: Action_LogsCreateManyTicketInput | Action_LogsCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithoutTicketsInput = {
    update: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type WhatsappUpsertWithoutTicketsInput = {
    update: XOR<WhatsappUpdateWithoutTicketsInput, WhatsappUncheckedUpdateWithoutTicketsInput>
    create: XOR<WhatsappCreateWithoutTicketsInput, WhatsappUncheckedCreateWithoutTicketsInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutTicketsInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutTicketsInput, WhatsappUncheckedUpdateWithoutTicketsInput>
  }

  export type WhatsappUpdateWithoutTicketsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type QueueUpsertWithoutTicketInput = {
    update: XOR<QueueUpdateWithoutTicketInput, QueueUncheckedUpdateWithoutTicketInput>
    create: XOR<QueueCreateWithoutTicketInput, QueueUncheckedCreateWithoutTicketInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutTicketInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutTicketInput, QueueUncheckedUpdateWithoutTicketInput>
  }

  export type QueueUpdateWithoutTicketInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueOptionUpsertWithoutTicketInput = {
    update: XOR<QueueOptionUpdateWithoutTicketInput, QueueOptionUncheckedUpdateWithoutTicketInput>
    create: XOR<QueueOptionCreateWithoutTicketInput, QueueOptionUncheckedCreateWithoutTicketInput>
    where?: QueueOptionWhereInput
  }

  export type QueueOptionUpdateToOneWithWhereWithoutTicketInput = {
    where?: QueueOptionWhereInput
    data: XOR<QueueOptionUpdateWithoutTicketInput, QueueOptionUncheckedUpdateWithoutTicketInput>
  }

  export type QueueOptionUpdateWithoutTicketInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutOptionsNestedInput
    parent?: QueueOptionUpdateOneWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QueueOption?: QueueOptionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutTicketInput, MessageUncheckedUpdateWithoutTicketInput>
    create: XOR<MessageCreateWithoutTicketInput, MessageUncheckedCreateWithoutTicketInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutTicketInput, MessageUncheckedUpdateWithoutTicketInput>
  }

  export type MessageUpdateManyWithWhereWithoutTicketInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketTagUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketTagWhereUniqueInput
    update: XOR<TicketTagUpdateWithoutTicketInput, TicketTagUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketTagCreateWithoutTicketInput, TicketTagUncheckedCreateWithoutTicketInput>
  }

  export type TicketTagUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketTagWhereUniqueInput
    data: XOR<TicketTagUpdateWithoutTicketInput, TicketTagUncheckedUpdateWithoutTicketInput>
  }

  export type TicketTagUpdateManyWithWhereWithoutTicketInput = {
    where: TicketTagScalarWhereInput
    data: XOR<TicketTagUpdateManyMutationInput, TicketTagUncheckedUpdateManyWithoutTicketInput>
  }

  export type TagUpsertWithWhereUniqueWithoutTicketsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTicketsInput, TagUncheckedUpdateWithoutTicketsInput>
    create: XOR<TagCreateWithoutTicketsInput, TagUncheckedCreateWithoutTicketsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTicketsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTicketsInput, TagUncheckedUpdateWithoutTicketsInput>
  }

  export type TagUpdateManyWithWhereWithoutTicketsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTicketsInput>
  }

  export type CompanyUpsertWithoutTicketsInput = {
    update: XOR<CompanyUpdateWithoutTicketsInput, CompanyUncheckedUpdateWithoutTicketsInput>
    create: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTicketsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTicketsInput, CompanyUncheckedUpdateWithoutTicketsInput>
  }

  export type CompanyUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type QueueIntegrationsUpsertWithoutTicketInput = {
    update: XOR<QueueIntegrationsUpdateWithoutTicketInput, QueueIntegrationsUncheckedUpdateWithoutTicketInput>
    create: XOR<QueueIntegrationsCreateWithoutTicketInput, QueueIntegrationsUncheckedCreateWithoutTicketInput>
    where?: QueueIntegrationsWhereInput
  }

  export type QueueIntegrationsUpdateToOneWithWhereWithoutTicketInput = {
    where?: QueueIntegrationsWhereInput
    data: XOR<QueueIntegrationsUpdateWithoutTicketInput, QueueIntegrationsUncheckedUpdateWithoutTicketInput>
  }

  export type QueueIntegrationsUpdateWithoutTicketInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutQueueIntegrationssNestedInput
    Queue?: QueueUpdateManyWithoutQueueIntegrationsNestedInput
  }

  export type QueueIntegrationsUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Queue?: QueueUncheckedUpdateManyWithoutQueueIntegrationsNestedInput
  }

  export type PromptUpsertWithoutTicketInput = {
    update: XOR<PromptUpdateWithoutTicketInput, PromptUncheckedUpdateWithoutTicketInput>
    create: XOR<PromptCreateWithoutTicketInput, PromptUncheckedCreateWithoutTicketInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutTicketInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutTicketInput, PromptUncheckedUpdateWithoutTicketInput>
  }

  export type PromptUpdateWithoutTicketInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneWithoutPromptNestedInput
    company?: CompanyUpdateOneRequiredWithoutPromptsNestedInput
    Whatsapp?: WhatsappUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Whatsapp?: WhatsappUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type UserRatingUpsertWithWhereUniqueWithoutTicketInput = {
    where: UserRatingWhereUniqueInput
    update: XOR<UserRatingUpdateWithoutTicketInput, UserRatingUncheckedUpdateWithoutTicketInput>
    create: XOR<UserRatingCreateWithoutTicketInput, UserRatingUncheckedCreateWithoutTicketInput>
  }

  export type UserRatingUpdateWithWhereUniqueWithoutTicketInput = {
    where: UserRatingWhereUniqueInput
    data: XOR<UserRatingUpdateWithoutTicketInput, UserRatingUncheckedUpdateWithoutTicketInput>
  }

  export type UserRatingUpdateManyWithWhereWithoutTicketInput = {
    where: UserRatingScalarWhereInput
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketTrackingUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketTrackingWhereUniqueInput
    update: XOR<TicketTrackingUpdateWithoutTicketInput, TicketTrackingUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketTrackingCreateWithoutTicketInput, TicketTrackingUncheckedCreateWithoutTicketInput>
  }

  export type TicketTrackingUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketTrackingWhereUniqueInput
    data: XOR<TicketTrackingUpdateWithoutTicketInput, TicketTrackingUncheckedUpdateWithoutTicketInput>
  }

  export type TicketTrackingUpdateManyWithWhereWithoutTicketInput = {
    where: TicketTrackingScalarWhereInput
    data: XOR<TicketTrackingUpdateManyMutationInput, TicketTrackingUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketNoteUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketNoteWhereUniqueInput
    update: XOR<TicketNoteUpdateWithoutTicketInput, TicketNoteUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput>
  }

  export type TicketNoteUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketNoteWhereUniqueInput
    data: XOR<TicketNoteUpdateWithoutTicketInput, TicketNoteUncheckedUpdateWithoutTicketInput>
  }

  export type TicketNoteUpdateManyWithWhereWithoutTicketInput = {
    where: TicketNoteScalarWhereInput
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyWithoutTicketInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutTicketInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutTicketInput, ScheduleUncheckedUpdateWithoutTicketInput>
    create: XOR<ScheduleCreateWithoutTicketInput, ScheduleUncheckedCreateWithoutTicketInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutTicketInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutTicketInput, ScheduleUncheckedUpdateWithoutTicketInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutTicketInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutTicketInput>
  }

  export type Action_LogsUpsertWithWhereUniqueWithoutTicketInput = {
    where: Action_LogsWhereUniqueInput
    update: XOR<Action_LogsUpdateWithoutTicketInput, Action_LogsUncheckedUpdateWithoutTicketInput>
    create: XOR<Action_LogsCreateWithoutTicketInput, Action_LogsUncheckedCreateWithoutTicketInput>
  }

  export type Action_LogsUpdateWithWhereUniqueWithoutTicketInput = {
    where: Action_LogsWhereUniqueInput
    data: XOR<Action_LogsUpdateWithoutTicketInput, Action_LogsUncheckedUpdateWithoutTicketInput>
  }

  export type Action_LogsUpdateManyWithWhereWithoutTicketInput = {
    where: Action_LogsScalarWhereInput
    data: XOR<Action_LogsUpdateManyMutationInput, Action_LogsUncheckedUpdateManyWithoutTicketInput>
  }

  export type Action_LogsScalarWhereInput = {
    AND?: Action_LogsScalarWhereInput | Action_LogsScalarWhereInput[]
    OR?: Action_LogsScalarWhereInput[]
    NOT?: Action_LogsScalarWhereInput | Action_LogsScalarWhereInput[]
    id?: IntFilter<"Action_Logs"> | number
    userId?: IntFilter<"Action_Logs"> | number
    ticketId?: IntNullableFilter<"Action_Logs"> | number | null
    action?: StringFilter<"Action_Logs"> | string
    message?: StringNullableFilter<"Action_Logs"> | string | null
    createdAt?: DateTimeFilter<"Action_Logs"> | Date | string
  }

  export type UserCreateWithoutTicketNoteInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketNoteInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketNoteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketNoteInput, UserUncheckedCreateWithoutTicketNoteInput>
  }

  export type ContactCreateWithoutTicketNoteInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    whatsapp?: WhatsappCreateNestedOneWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTicketNoteInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTicketNoteInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTicketNoteInput, ContactUncheckedCreateWithoutTicketNoteInput>
  }

  export type TicketCreateWithoutTicketNoteInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketNoteInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicketNoteInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketNoteInput, TicketUncheckedCreateWithoutTicketNoteInput>
  }

  export type UserUpsertWithoutTicketNoteInput = {
    update: XOR<UserUpdateWithoutTicketNoteInput, UserUncheckedUpdateWithoutTicketNoteInput>
    create: XOR<UserCreateWithoutTicketNoteInput, UserUncheckedCreateWithoutTicketNoteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketNoteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketNoteInput, UserUncheckedUpdateWithoutTicketNoteInput>
  }

  export type UserUpdateWithoutTicketNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithoutTicketNoteInput = {
    update: XOR<ContactUpdateWithoutTicketNoteInput, ContactUncheckedUpdateWithoutTicketNoteInput>
    create: XOR<ContactCreateWithoutTicketNoteInput, ContactUncheckedCreateWithoutTicketNoteInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTicketNoteInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTicketNoteInput, ContactUncheckedUpdateWithoutTicketNoteInput>
  }

  export type ContactUpdateWithoutTicketNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTicketNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TicketUpsertWithoutTicketNoteInput = {
    update: XOR<TicketUpdateWithoutTicketNoteInput, TicketUncheckedUpdateWithoutTicketNoteInput>
    create: XOR<TicketCreateWithoutTicketNoteInput, TicketUncheckedCreateWithoutTicketNoteInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicketNoteInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicketNoteInput, TicketUncheckedUpdateWithoutTicketNoteInput>
  }

  export type TicketUpdateWithoutTicketNoteInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateWithoutTicketTagsInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketTagsInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicketTagsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketTagsInput, TicketUncheckedCreateWithoutTicketTagsInput>
  }

  export type TagCreateWithoutTicketTagsInput = {
    name: string
    color: string
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTagsInput
    tickets?: TicketCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTicketTagsInput = {
    id?: number
    name: string
    color: string
    companyId: number
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutTicketTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTicketTagsInput, TagUncheckedCreateWithoutTicketTagsInput>
  }

  export type TicketUpsertWithoutTicketTagsInput = {
    update: XOR<TicketUpdateWithoutTicketTagsInput, TicketUncheckedUpdateWithoutTicketTagsInput>
    create: XOR<TicketCreateWithoutTicketTagsInput, TicketUncheckedCreateWithoutTicketTagsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicketTagsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicketTagsInput, TicketUncheckedUpdateWithoutTicketTagsInput>
  }

  export type TicketUpdateWithoutTicketTagsInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TagUpsertWithoutTicketTagsInput = {
    update: XOR<TagUpdateWithoutTicketTagsInput, TagUncheckedUpdateWithoutTicketTagsInput>
    create: XOR<TagCreateWithoutTicketTagsInput, TagUncheckedCreateWithoutTicketTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTicketTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTicketTagsInput, TagUncheckedUpdateWithoutTicketTagsInput>
  }

  export type TagUpdateWithoutTicketTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTagsNestedInput
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTicketTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TicketCreateWithoutTicketTrackingInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTicketTrackingInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTicketTrackingInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTicketTrackingInput, TicketUncheckedCreateWithoutTicketTrackingInput>
  }

  export type CompanyCreateWithoutTicketTrackingsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTicketTrackingsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTicketTrackingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTicketTrackingsInput, CompanyUncheckedCreateWithoutTicketTrackingsInput>
  }

  export type WhatsappCreateWithoutTicketTrackingInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutTicketTrackingInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutTicketTrackingInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutTicketTrackingInput, WhatsappUncheckedCreateWithoutTicketTrackingInput>
  }

  export type UserCreateWithoutTicketTrackingInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketTrackingInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketTrackingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketTrackingInput, UserUncheckedCreateWithoutTicketTrackingInput>
  }

  export type TicketUpsertWithoutTicketTrackingInput = {
    update: XOR<TicketUpdateWithoutTicketTrackingInput, TicketUncheckedUpdateWithoutTicketTrackingInput>
    create: XOR<TicketCreateWithoutTicketTrackingInput, TicketUncheckedCreateWithoutTicketTrackingInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutTicketTrackingInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutTicketTrackingInput, TicketUncheckedUpdateWithoutTicketTrackingInput>
  }

  export type TicketUpdateWithoutTicketTrackingInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTicketTrackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type CompanyUpsertWithoutTicketTrackingsInput = {
    update: XOR<CompanyUpdateWithoutTicketTrackingsInput, CompanyUncheckedUpdateWithoutTicketTrackingsInput>
    create: XOR<CompanyCreateWithoutTicketTrackingsInput, CompanyUncheckedCreateWithoutTicketTrackingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTicketTrackingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTicketTrackingsInput, CompanyUncheckedUpdateWithoutTicketTrackingsInput>
  }

  export type CompanyUpdateWithoutTicketTrackingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTicketTrackingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WhatsappUpsertWithoutTicketTrackingInput = {
    update: XOR<WhatsappUpdateWithoutTicketTrackingInput, WhatsappUncheckedUpdateWithoutTicketTrackingInput>
    create: XOR<WhatsappCreateWithoutTicketTrackingInput, WhatsappUncheckedCreateWithoutTicketTrackingInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutTicketTrackingInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutTicketTrackingInput, WhatsappUncheckedUpdateWithoutTicketTrackingInput>
  }

  export type WhatsappUpdateWithoutTicketTrackingInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutTicketTrackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type UserUpsertWithoutTicketTrackingInput = {
    update: XOR<UserUpdateWithoutTicketTrackingInput, UserUncheckedUpdateWithoutTicketTrackingInput>
    create: XOR<UserCreateWithoutTicketTrackingInput, UserUncheckedCreateWithoutTicketTrackingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketTrackingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketTrackingInput, UserUncheckedUpdateWithoutTicketTrackingInput>
  }

  export type UserUpdateWithoutTicketTrackingInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketTrackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutUsersInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type WhatsappCreateWithoutUserInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueCreateNestedManyWithoutWhatsappInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    whatsappQueues?: WhatsappQueueUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutUserInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutUserInput, WhatsappUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateWithoutUserInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutUserInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateManyUserInputEnvelope = {
    data: TicketCreateManyUserInput | TicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QueueCreateWithoutUsersInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutUsersInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutUsersInput, QueueUncheckedCreateWithoutUsersInput>
  }

  export type QuickMessageCreateWithoutUserInput = {
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutQuickMessagesInput
  }

  export type QuickMessageUncheckedCreateWithoutUserInput = {
    id?: number
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickMessageCreateOrConnectWithoutUserInput = {
    where: QuickMessageWhereUniqueInput
    create: XOR<QuickMessageCreateWithoutUserInput, QuickMessageUncheckedCreateWithoutUserInput>
  }

  export type QuickMessageCreateManyUserInputEnvelope = {
    data: QuickMessageCreateManyUserInput | QuickMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatUserCreateWithoutUserInput = {
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutUsersInput
  }

  export type ChatUserUncheckedCreateWithoutUserInput = {
    id?: number
    chatId: number
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUserCreateOrConnectWithoutUserInput = {
    where: ChatUserWhereUniqueInput
    create: XOR<ChatUserCreateWithoutUserInput, ChatUserUncheckedCreateWithoutUserInput>
  }

  export type ChatUserCreateManyUserInputEnvelope = {
    data: ChatUserCreateManyUserInput | ChatUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserQueueCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: QueueCreateNestedOneWithoutUserQueueInput
  }

  export type UserQueueUncheckedCreateWithoutUserInput = {
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQueueCreateOrConnectWithoutUserInput = {
    where: UserQueueWhereUniqueInput
    create: XOR<UserQueueCreateWithoutUserInput, UserQueueUncheckedCreateWithoutUserInput>
  }

  export type UserQueueCreateManyUserInputEnvelope = {
    data: UserQueueCreateManyUserInput | UserQueueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRatingCreateWithoutUserInput = {
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutUserRatingInput
    company: CompanyCreateNestedOneWithoutUserRatingsInput
  }

  export type UserRatingUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId: number
    companyId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingCreateOrConnectWithoutUserInput = {
    where: UserRatingWhereUniqueInput
    create: XOR<UserRatingCreateWithoutUserInput, UserRatingUncheckedCreateWithoutUserInput>
  }

  export type UserRatingCreateManyUserInputEnvelope = {
    data: UserRatingCreateManyUserInput | UserRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketTrackingCreateWithoutUserInput = {
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
    ticket: TicketCreateNestedOneWithoutTicketTrackingInput
    company: CompanyCreateNestedOneWithoutTicketTrackingsInput
    whatsapp?: WhatsappCreateNestedOneWithoutTicketTrackingInput
  }

  export type TicketTrackingUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId: number
    companyId: number
    whatsappId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketTrackingCreateOrConnectWithoutUserInput = {
    where: TicketTrackingWhereUniqueInput
    create: XOR<TicketTrackingCreateWithoutUserInput, TicketTrackingUncheckedCreateWithoutUserInput>
  }

  export type TicketTrackingCreateManyUserInputEnvelope = {
    data: TicketTrackingCreateManyUserInput | TicketTrackingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketNoteCreateWithoutUserInput = {
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutTicketNoteInput
    ticket: TicketCreateNestedOneWithoutTicketNoteInput
  }

  export type TicketNoteUncheckedCreateWithoutUserInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId: number
    ticketId: number
  }

  export type TicketNoteCreateOrConnectWithoutUserInput = {
    where: TicketNoteWhereUniqueInput
    create: XOR<TicketNoteCreateWithoutUserInput, TicketNoteUncheckedCreateWithoutUserInput>
  }

  export type TicketNoteCreateManyUserInputEnvelope = {
    data: TicketNoteCreateManyUserInput | TicketNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutUserInput = {
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutSchedulesInput
    ticket: TicketCreateNestedOneWithoutScheduleInput
    company: CompanyCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutUserInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>
  }

  export type ScheduleCreateManyUserInputEnvelope = {
    data: ScheduleCreateManyUserInput | ScheduleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    chatId: number
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutOwnerInput = {
    uuid?: string
    title?: string
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutChatsInput
    users?: ChatUserCreateNestedManyWithoutChatInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutOwnerInput = {
    id?: number
    uuid?: string
    title?: string
    lastMessage?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: ChatUserUncheckedCreateNestedManyWithoutChatInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutOwnerInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutOwnerInput, ChatUncheckedCreateWithoutOwnerInput>
  }

  export type ChatCreateManyOwnerInputEnvelope = {
    data: ChatCreateManyOwnerInput | ChatCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type Action_LogsCreateWithoutUserInput = {
    action: string
    message?: string | null
    createdAt?: Date | string
    ticket?: TicketCreateNestedOneWithoutAction_LogsInput
    System_Logs?: System_LogsCreateNestedManyWithoutActionLogInput
  }

  export type Action_LogsUncheckedCreateWithoutUserInput = {
    id?: number
    ticketId?: number | null
    action: string
    message?: string | null
    createdAt?: Date | string
    System_Logs?: System_LogsUncheckedCreateNestedManyWithoutActionLogInput
  }

  export type Action_LogsCreateOrConnectWithoutUserInput = {
    where: Action_LogsWhereUniqueInput
    create: XOR<Action_LogsCreateWithoutUserInput, Action_LogsUncheckedCreateWithoutUserInput>
  }

  export type Action_LogsCreateManyUserInputEnvelope = {
    data: Action_LogsCreateManyUserInput | Action_LogsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WhatsappUpsertWithoutUserInput = {
    update: XOR<WhatsappUpdateWithoutUserInput, WhatsappUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsappCreateWithoutUserInput, WhatsappUncheckedCreateWithoutUserInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutUserInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutUserInput, WhatsappUncheckedUpdateWithoutUserInput>
  }

  export type WhatsappUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUserInput>
  }

  export type QueueUpsertWithWhereUniqueWithoutUsersInput = {
    where: QueueWhereUniqueInput
    update: XOR<QueueUpdateWithoutUsersInput, QueueUncheckedUpdateWithoutUsersInput>
    create: XOR<QueueCreateWithoutUsersInput, QueueUncheckedCreateWithoutUsersInput>
  }

  export type QueueUpdateWithWhereUniqueWithoutUsersInput = {
    where: QueueWhereUniqueInput
    data: XOR<QueueUpdateWithoutUsersInput, QueueUncheckedUpdateWithoutUsersInput>
  }

  export type QueueUpdateManyWithWhereWithoutUsersInput = {
    where: QueueScalarWhereInput
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyWithoutUsersInput>
  }

  export type QuickMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: QuickMessageWhereUniqueInput
    update: XOR<QuickMessageUpdateWithoutUserInput, QuickMessageUncheckedUpdateWithoutUserInput>
    create: XOR<QuickMessageCreateWithoutUserInput, QuickMessageUncheckedCreateWithoutUserInput>
  }

  export type QuickMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: QuickMessageWhereUniqueInput
    data: XOR<QuickMessageUpdateWithoutUserInput, QuickMessageUncheckedUpdateWithoutUserInput>
  }

  export type QuickMessageUpdateManyWithWhereWithoutUserInput = {
    where: QuickMessageScalarWhereInput
    data: XOR<QuickMessageUpdateManyMutationInput, QuickMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatUserWhereUniqueInput
    update: XOR<ChatUserUpdateWithoutUserInput, ChatUserUncheckedUpdateWithoutUserInput>
    create: XOR<ChatUserCreateWithoutUserInput, ChatUserUncheckedCreateWithoutUserInput>
  }

  export type ChatUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatUserWhereUniqueInput
    data: XOR<ChatUserUpdateWithoutUserInput, ChatUserUncheckedUpdateWithoutUserInput>
  }

  export type ChatUserUpdateManyWithWhereWithoutUserInput = {
    where: ChatUserScalarWhereInput
    data: XOR<ChatUserUpdateManyMutationInput, ChatUserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserQueueUpsertWithWhereUniqueWithoutUserInput = {
    where: UserQueueWhereUniqueInput
    update: XOR<UserQueueUpdateWithoutUserInput, UserQueueUncheckedUpdateWithoutUserInput>
    create: XOR<UserQueueCreateWithoutUserInput, UserQueueUncheckedCreateWithoutUserInput>
  }

  export type UserQueueUpdateWithWhereUniqueWithoutUserInput = {
    where: UserQueueWhereUniqueInput
    data: XOR<UserQueueUpdateWithoutUserInput, UserQueueUncheckedUpdateWithoutUserInput>
  }

  export type UserQueueUpdateManyWithWhereWithoutUserInput = {
    where: UserQueueScalarWhereInput
    data: XOR<UserQueueUpdateManyMutationInput, UserQueueUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRatingWhereUniqueInput
    update: XOR<UserRatingUpdateWithoutUserInput, UserRatingUncheckedUpdateWithoutUserInput>
    create: XOR<UserRatingCreateWithoutUserInput, UserRatingUncheckedCreateWithoutUserInput>
  }

  export type UserRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRatingWhereUniqueInput
    data: XOR<UserRatingUpdateWithoutUserInput, UserRatingUncheckedUpdateWithoutUserInput>
  }

  export type UserRatingUpdateManyWithWhereWithoutUserInput = {
    where: UserRatingScalarWhereInput
    data: XOR<UserRatingUpdateManyMutationInput, UserRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketTrackingWhereUniqueInput
    update: XOR<TicketTrackingUpdateWithoutUserInput, TicketTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<TicketTrackingCreateWithoutUserInput, TicketTrackingUncheckedCreateWithoutUserInput>
  }

  export type TicketTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketTrackingWhereUniqueInput
    data: XOR<TicketTrackingUpdateWithoutUserInput, TicketTrackingUncheckedUpdateWithoutUserInput>
  }

  export type TicketTrackingUpdateManyWithWhereWithoutUserInput = {
    where: TicketTrackingScalarWhereInput
    data: XOR<TicketTrackingUpdateManyMutationInput, TicketTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketNoteWhereUniqueInput
    update: XOR<TicketNoteUpdateWithoutUserInput, TicketNoteUncheckedUpdateWithoutUserInput>
    create: XOR<TicketNoteCreateWithoutUserInput, TicketNoteUncheckedCreateWithoutUserInput>
  }

  export type TicketNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketNoteWhereUniqueInput
    data: XOR<TicketNoteUpdateWithoutUserInput, TicketNoteUncheckedUpdateWithoutUserInput>
  }

  export type TicketNoteUpdateManyWithWhereWithoutUserInput = {
    where: TicketNoteScalarWhereInput
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutUserInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutOwnerInput, ChatUncheckedUpdateWithoutOwnerInput>
    create: XOR<ChatCreateWithoutOwnerInput, ChatUncheckedCreateWithoutOwnerInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutOwnerInput, ChatUncheckedUpdateWithoutOwnerInput>
  }

  export type ChatUpdateManyWithWhereWithoutOwnerInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutOwnerInput>
  }

  export type Action_LogsUpsertWithWhereUniqueWithoutUserInput = {
    where: Action_LogsWhereUniqueInput
    update: XOR<Action_LogsUpdateWithoutUserInput, Action_LogsUncheckedUpdateWithoutUserInput>
    create: XOR<Action_LogsCreateWithoutUserInput, Action_LogsUncheckedCreateWithoutUserInput>
  }

  export type Action_LogsUpdateWithWhereUniqueWithoutUserInput = {
    where: Action_LogsWhereUniqueInput
    data: XOR<Action_LogsUpdateWithoutUserInput, Action_LogsUncheckedUpdateWithoutUserInput>
  }

  export type Action_LogsUpdateManyWithWhereWithoutUserInput = {
    where: Action_LogsScalarWhereInput
    data: XOR<Action_LogsUpdateManyMutationInput, Action_LogsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutUserQueueInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserQueueInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserQueueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserQueueInput, UserUncheckedCreateWithoutUserQueueInput>
  }

  export type QueueCreateWithoutUserQueueInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutUserQueueInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutUserQueueInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutUserQueueInput, QueueUncheckedCreateWithoutUserQueueInput>
  }

  export type UserUpsertWithoutUserQueueInput = {
    update: XOR<UserUpdateWithoutUserQueueInput, UserUncheckedUpdateWithoutUserQueueInput>
    create: XOR<UserCreateWithoutUserQueueInput, UserUncheckedCreateWithoutUserQueueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserQueueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserQueueInput, UserUncheckedUpdateWithoutUserQueueInput>
  }

  export type UserUpdateWithoutUserQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QueueUpsertWithoutUserQueueInput = {
    update: XOR<QueueUpdateWithoutUserQueueInput, QueueUncheckedUpdateWithoutUserQueueInput>
    create: XOR<QueueCreateWithoutUserQueueInput, QueueUncheckedCreateWithoutUserQueueInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutUserQueueInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutUserQueueInput, QueueUncheckedUpdateWithoutUserQueueInput>
  }

  export type QueueUpdateWithoutUserQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutUserQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type TicketCreateWithoutUserRatingInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    whatsapp: WhatsappCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutUserRatingInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUserRatingInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUserRatingInput, TicketUncheckedCreateWithoutUserRatingInput>
  }

  export type CompanyCreateWithoutUserRatingsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserRatingsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserRatingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserRatingsInput, CompanyUncheckedCreateWithoutUserRatingsInput>
  }

  export type UserCreateWithoutUserRatingInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    whatsapp?: WhatsappCreateNestedOneWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRatingInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRatingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRatingInput, UserUncheckedCreateWithoutUserRatingInput>
  }

  export type TicketUpsertWithoutUserRatingInput = {
    update: XOR<TicketUpdateWithoutUserRatingInput, TicketUncheckedUpdateWithoutUserRatingInput>
    create: XOR<TicketCreateWithoutUserRatingInput, TicketUncheckedCreateWithoutUserRatingInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutUserRatingInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutUserRatingInput, TicketUncheckedUpdateWithoutUserRatingInput>
  }

  export type TicketUpdateWithoutUserRatingInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUserRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type CompanyUpsertWithoutUserRatingsInput = {
    update: XOR<CompanyUpdateWithoutUserRatingsInput, CompanyUncheckedUpdateWithoutUserRatingsInput>
    create: XOR<CompanyCreateWithoutUserRatingsInput, CompanyUncheckedCreateWithoutUserRatingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUserRatingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUserRatingsInput, CompanyUncheckedUpdateWithoutUserRatingsInput>
  }

  export type CompanyUpdateWithoutUserRatingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutUserRatingInput = {
    update: XOR<UserUpdateWithoutUserRatingInput, UserUncheckedUpdateWithoutUserRatingInput>
    create: XOR<UserCreateWithoutUserRatingInput, UserUncheckedCreateWithoutUserRatingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRatingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRatingInput, UserUncheckedUpdateWithoutUserRatingInput>
  }

  export type UserUpdateWithoutUserRatingInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRatingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketCreateWithoutWhatsappInput = {
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    chatbot?: boolean | null
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    user: UserCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    queue: QueueCreateNestedOneWithoutTicketInput
    queueOption: QueueOptionCreateNestedOneWithoutTicketInput
    messages?: MessageCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagCreateNestedManyWithoutTicketInput
    tags?: TagCreateNestedManyWithoutTicketsInput
    company: CompanyCreateNestedOneWithoutTicketsInput
    queueIntegration?: QueueIntegrationsCreateNestedOneWithoutTicketInput
    prompt?: PromptCreateNestedOneWithoutTicketInput
    UserRating?: UserRatingCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutWhatsappInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
    messages?: MessageUncheckedCreateNestedManyWithoutTicketInput
    ticketTags?: TicketTagUncheckedCreateNestedManyWithoutTicketInput
    tags?: TagUncheckedCreateNestedManyWithoutTicketsInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutTicketInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutTicketInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutTicketInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutWhatsappInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutWhatsappInput, TicketUncheckedCreateWithoutWhatsappInput>
  }

  export type TicketCreateManyWhatsappInputEnvelope = {
    data: TicketCreateManyWhatsappInput | TicketCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type QueueCreateWithoutWhatsappsInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutWhatsappsInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    WhatsappQueue?: WhatsappQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutWhatsappsInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutWhatsappsInput, QueueUncheckedCreateWithoutWhatsappsInput>
  }

  export type WhatsappQueueCreateWithoutWhatsappInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    queue: QueueCreateNestedOneWithoutWhatsappQueueInput
  }

  export type WhatsappQueueUncheckedCreateWithoutWhatsappInput = {
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappQueueCreateOrConnectWithoutWhatsappInput = {
    where: WhatsappQueueWhereUniqueInput
    create: XOR<WhatsappQueueCreateWithoutWhatsappInput, WhatsappQueueUncheckedCreateWithoutWhatsappInput>
  }

  export type WhatsappQueueCreateManyWhatsappInputEnvelope = {
    data: WhatsappQueueCreateManyWhatsappInput | WhatsappQueueCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWhatsappsInput = {
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutCompanyInput
    plan: PlanCreateNestedOneWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingCreateNestedManyWithoutCompanyInput
    queues?: QueueCreateNestedManyWithoutCompanyInput
    messages?: MessageCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
    settings?: SettingCreateNestedManyWithoutCompanyInput
    tags?: TagCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsCreateNestedManyWithoutCompanyInput
    prompts?: PromptCreateNestedManyWithoutCompanyInput
    filess?: FilesCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListCreateNestedManyWithoutCompanyInput
    chats?: ChatCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementCreateNestedManyWithoutCompanyInput
    queue?: QueueCreateNestedManyWithoutCompanyInput
    ratings?: RatingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWhatsappsInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    planId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userRatings?: UserRatingUncheckedCreateNestedManyWithoutCompanyInput
    queues?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    messages?: MessageUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    settings?: SettingUncheckedCreateNestedManyWithoutCompanyInput
    tags?: TagUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    ticketTrackings?: TicketTrackingUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutCompanyInput
    queueIntegrationss?: QueueIntegrationsUncheckedCreateNestedManyWithoutCompanyInput
    prompts?: PromptUncheckedCreateNestedManyWithoutCompanyInput
    filess?: FilesUncheckedCreateNestedManyWithoutCompanyInput
    contactListItems?: ContactListItemUncheckedCreateNestedManyWithoutCompanyInput
    contactLists?: ContactListUncheckedCreateNestedManyWithoutCompanyInput
    chats?: ChatUncheckedCreateNestedManyWithoutCompanyInput
    campaignSettings?: CampaignSettingUncheckedCreateNestedManyWithoutCompanyInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutCompanyInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCompanyInput
    queue?: QueueUncheckedCreateNestedManyWithoutCompanyInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWhatsappsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWhatsappsInput, CompanyUncheckedCreateWithoutWhatsappsInput>
  }

  export type PromptCreateWithoutWhatsappInput = {
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    queue?: QueueCreateNestedOneWithoutPromptInput
    company: CompanyCreateNestedOneWithoutPromptsInput
    Ticket?: TicketCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutWhatsappInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    queueId?: number | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Ticket?: TicketUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutWhatsappInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutWhatsappInput, PromptUncheckedCreateWithoutWhatsappInput>
  }

  export type UserCreateWithoutWhatsappInput = {
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarUrl?: string | null
    company: CompanyCreateNestedOneWithoutUsersInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    queues?: QueueCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueCreateNestedManyWithoutUserInput
    UserRating?: UserRatingCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteCreateNestedManyWithoutUserInput
    Schedule?: ScheduleCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageCreateNestedManyWithoutSenderInput
    Chat?: ChatCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsappInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    avatarUrl?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    queues?: QueueUncheckedCreateNestedManyWithoutUsersInput
    quickMessages?: QuickMessageUncheckedCreateNestedManyWithoutUserInput
    ChatUsers?: ChatUserUncheckedCreateNestedManyWithoutUserInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutUserInput
    UserRating?: UserRatingUncheckedCreateNestedManyWithoutUserInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutUserInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutUserInput
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ChatMessage?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    Chat?: ChatUncheckedCreateNestedManyWithoutOwnerInput
    Action_Logs?: Action_LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsappInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappInput, UserUncheckedCreateWithoutWhatsappInput>
  }

  export type UserCreateManyWhatsappInputEnvelope = {
    data: UserCreateManyWhatsappInput | UserCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type TicketTrackingCreateWithoutWhatsappInput = {
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
    ticket: TicketCreateNestedOneWithoutTicketTrackingInput
    company: CompanyCreateNestedOneWithoutTicketTrackingsInput
    user?: UserCreateNestedOneWithoutTicketTrackingInput
  }

  export type TicketTrackingUncheckedCreateWithoutWhatsappInput = {
    id?: number
    ticketId: number
    companyId: number
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketTrackingCreateOrConnectWithoutWhatsappInput = {
    where: TicketTrackingWhereUniqueInput
    create: XOR<TicketTrackingCreateWithoutWhatsappInput, TicketTrackingUncheckedCreateWithoutWhatsappInput>
  }

  export type TicketTrackingCreateManyWhatsappInputEnvelope = {
    data: TicketTrackingCreateManyWhatsappInput | TicketTrackingCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutWhatsappInput = {
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutContactsInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldCreateNestedManyWithoutContactInput
    schedules?: ScheduleCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteCreateNestedManyWithoutContactInput
    Message?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutWhatsappInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    extraInfo?: ContactCustomFieldUncheckedCreateNestedManyWithoutContactInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutContactInput
    TicketNote?: TicketNoteUncheckedCreateNestedManyWithoutContactInput
    Message?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutWhatsappInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutWhatsappInput, ContactUncheckedCreateWithoutWhatsappInput>
  }

  export type ContactCreateManyWhatsappInputEnvelope = {
    data: ContactCreateManyWhatsappInput | ContactCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutWhatsappInput = {
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutCampaignsInput
    contactList?: ContactListCreateNestedOneWithoutCampaignInput
    fileList: FilesCreateNestedOneWithoutCampaignInput
    shipping?: CampaignShippingCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutWhatsappInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    fileListId: number
    shipping?: CampaignShippingUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutWhatsappInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutWhatsappInput, CampaignUncheckedCreateWithoutWhatsappInput>
  }

  export type CampaignCreateManyWhatsappInputEnvelope = {
    data: CampaignCreateManyWhatsappInput | CampaignCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type BaileysChatsCreateWithoutWhatsappInput = {
    jid: string
    conversationTimestamp: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BaileysChatsUncheckedCreateWithoutWhatsappInput = {
    id?: number
    jid: string
    conversationTimestamp: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BaileysChatsCreateOrConnectWithoutWhatsappInput = {
    where: BaileysChatsWhereUniqueInput
    create: XOR<BaileysChatsCreateWithoutWhatsappInput, BaileysChatsUncheckedCreateWithoutWhatsappInput>
  }

  export type BaileysChatsCreateManyWhatsappInputEnvelope = {
    data: BaileysChatsCreateManyWhatsappInput | BaileysChatsCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type BaileysCreateWithoutWhatsappInput = {
    contacts?: string | null
    chats?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BaileysUncheckedCreateWithoutWhatsappInput = {
    id?: number
    contacts?: string | null
    chats?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BaileysCreateOrConnectWithoutWhatsappInput = {
    where: BaileysWhereUniqueInput
    create: XOR<BaileysCreateWithoutWhatsappInput, BaileysUncheckedCreateWithoutWhatsappInput>
  }

  export type BaileysCreateManyWhatsappInputEnvelope = {
    data: BaileysCreateManyWhatsappInput | BaileysCreateManyWhatsappInput[]
    skipDuplicates?: boolean
  }

  export type TicketUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutWhatsappInput, TicketUncheckedUpdateWithoutWhatsappInput>
    create: XOR<TicketCreateWithoutWhatsappInput, TicketUncheckedCreateWithoutWhatsappInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutWhatsappInput, TicketUncheckedUpdateWithoutWhatsappInput>
  }

  export type TicketUpdateManyWithWhereWithoutWhatsappInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type QueueUpsertWithWhereUniqueWithoutWhatsappsInput = {
    where: QueueWhereUniqueInput
    update: XOR<QueueUpdateWithoutWhatsappsInput, QueueUncheckedUpdateWithoutWhatsappsInput>
    create: XOR<QueueCreateWithoutWhatsappsInput, QueueUncheckedCreateWithoutWhatsappsInput>
  }

  export type QueueUpdateWithWhereUniqueWithoutWhatsappsInput = {
    where: QueueWhereUniqueInput
    data: XOR<QueueUpdateWithoutWhatsappsInput, QueueUncheckedUpdateWithoutWhatsappsInput>
  }

  export type QueueUpdateManyWithWhereWithoutWhatsappsInput = {
    where: QueueScalarWhereInput
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyWithoutWhatsappsInput>
  }

  export type WhatsappQueueUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: WhatsappQueueWhereUniqueInput
    update: XOR<WhatsappQueueUpdateWithoutWhatsappInput, WhatsappQueueUncheckedUpdateWithoutWhatsappInput>
    create: XOR<WhatsappQueueCreateWithoutWhatsappInput, WhatsappQueueUncheckedCreateWithoutWhatsappInput>
  }

  export type WhatsappQueueUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: WhatsappQueueWhereUniqueInput
    data: XOR<WhatsappQueueUpdateWithoutWhatsappInput, WhatsappQueueUncheckedUpdateWithoutWhatsappInput>
  }

  export type WhatsappQueueUpdateManyWithWhereWithoutWhatsappInput = {
    where: WhatsappQueueScalarWhereInput
    data: XOR<WhatsappQueueUpdateManyMutationInput, WhatsappQueueUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type CompanyUpsertWithoutWhatsappsInput = {
    update: XOR<CompanyUpdateWithoutWhatsappsInput, CompanyUncheckedUpdateWithoutWhatsappsInput>
    create: XOR<CompanyCreateWithoutWhatsappsInput, CompanyUncheckedCreateWithoutWhatsappsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWhatsappsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWhatsappsInput, CompanyUncheckedUpdateWithoutWhatsappsInput>
  }

  export type CompanyUpdateWithoutWhatsappsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWhatsappsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PromptUpsertWithoutWhatsappInput = {
    update: XOR<PromptUpdateWithoutWhatsappInput, PromptUncheckedUpdateWithoutWhatsappInput>
    create: XOR<PromptCreateWithoutWhatsappInput, PromptUncheckedCreateWithoutWhatsappInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutWhatsappInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutWhatsappInput, PromptUncheckedUpdateWithoutWhatsappInput>
  }

  export type PromptUpdateWithoutWhatsappInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneWithoutPromptNestedInput
    company?: CompanyUpdateOneRequiredWithoutPromptsNestedInput
    Ticket?: TicketUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutWhatsappInput, UserUncheckedUpdateWithoutWhatsappInput>
    create: XOR<UserCreateWithoutWhatsappInput, UserUncheckedCreateWithoutWhatsappInput>
  }

  export type UserUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutWhatsappInput, UserUncheckedUpdateWithoutWhatsappInput>
  }

  export type UserUpdateManyWithWhereWithoutWhatsappInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type TicketTrackingUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: TicketTrackingWhereUniqueInput
    update: XOR<TicketTrackingUpdateWithoutWhatsappInput, TicketTrackingUncheckedUpdateWithoutWhatsappInput>
    create: XOR<TicketTrackingCreateWithoutWhatsappInput, TicketTrackingUncheckedCreateWithoutWhatsappInput>
  }

  export type TicketTrackingUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: TicketTrackingWhereUniqueInput
    data: XOR<TicketTrackingUpdateWithoutWhatsappInput, TicketTrackingUncheckedUpdateWithoutWhatsappInput>
  }

  export type TicketTrackingUpdateManyWithWhereWithoutWhatsappInput = {
    where: TicketTrackingScalarWhereInput
    data: XOR<TicketTrackingUpdateManyMutationInput, TicketTrackingUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutWhatsappInput, ContactUncheckedUpdateWithoutWhatsappInput>
    create: XOR<ContactCreateWithoutWhatsappInput, ContactUncheckedCreateWithoutWhatsappInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutWhatsappInput, ContactUncheckedUpdateWithoutWhatsappInput>
  }

  export type ContactUpdateManyWithWhereWithoutWhatsappInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutWhatsappInput, CampaignUncheckedUpdateWithoutWhatsappInput>
    create: XOR<CampaignCreateWithoutWhatsappInput, CampaignUncheckedCreateWithoutWhatsappInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutWhatsappInput, CampaignUncheckedUpdateWithoutWhatsappInput>
  }

  export type CampaignUpdateManyWithWhereWithoutWhatsappInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type BaileysChatsUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: BaileysChatsWhereUniqueInput
    update: XOR<BaileysChatsUpdateWithoutWhatsappInput, BaileysChatsUncheckedUpdateWithoutWhatsappInput>
    create: XOR<BaileysChatsCreateWithoutWhatsappInput, BaileysChatsUncheckedCreateWithoutWhatsappInput>
  }

  export type BaileysChatsUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: BaileysChatsWhereUniqueInput
    data: XOR<BaileysChatsUpdateWithoutWhatsappInput, BaileysChatsUncheckedUpdateWithoutWhatsappInput>
  }

  export type BaileysChatsUpdateManyWithWhereWithoutWhatsappInput = {
    where: BaileysChatsScalarWhereInput
    data: XOR<BaileysChatsUpdateManyMutationInput, BaileysChatsUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type BaileysChatsScalarWhereInput = {
    AND?: BaileysChatsScalarWhereInput | BaileysChatsScalarWhereInput[]
    OR?: BaileysChatsScalarWhereInput[]
    NOT?: BaileysChatsScalarWhereInput | BaileysChatsScalarWhereInput[]
    id?: IntFilter<"BaileysChats"> | number
    jid?: StringFilter<"BaileysChats"> | string
    conversationTimestamp?: IntFilter<"BaileysChats"> | number
    unreadCount?: IntFilter<"BaileysChats"> | number
    createdAt?: DateTimeFilter<"BaileysChats"> | Date | string
    updatedAt?: DateTimeFilter<"BaileysChats"> | Date | string
    whatsappId?: IntFilter<"BaileysChats"> | number
  }

  export type BaileysUpsertWithWhereUniqueWithoutWhatsappInput = {
    where: BaileysWhereUniqueInput
    update: XOR<BaileysUpdateWithoutWhatsappInput, BaileysUncheckedUpdateWithoutWhatsappInput>
    create: XOR<BaileysCreateWithoutWhatsappInput, BaileysUncheckedCreateWithoutWhatsappInput>
  }

  export type BaileysUpdateWithWhereUniqueWithoutWhatsappInput = {
    where: BaileysWhereUniqueInput
    data: XOR<BaileysUpdateWithoutWhatsappInput, BaileysUncheckedUpdateWithoutWhatsappInput>
  }

  export type BaileysUpdateManyWithWhereWithoutWhatsappInput = {
    where: BaileysScalarWhereInput
    data: XOR<BaileysUpdateManyMutationInput, BaileysUncheckedUpdateManyWithoutWhatsappInput>
  }

  export type BaileysScalarWhereInput = {
    AND?: BaileysScalarWhereInput | BaileysScalarWhereInput[]
    OR?: BaileysScalarWhereInput[]
    NOT?: BaileysScalarWhereInput | BaileysScalarWhereInput[]
    id?: IntFilter<"Baileys"> | number
    contacts?: StringNullableFilter<"Baileys"> | string | null
    chats?: StringNullableFilter<"Baileys"> | string | null
    createdAt?: DateTimeFilter<"Baileys"> | Date | string
    updatedAt?: DateTimeFilter<"Baileys"> | Date | string
    whatsappId?: IntFilter<"Baileys"> | number
  }

  export type WhatsappCreateWithoutWhatsappQueuesInput = {
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutWhatsappInput
    queues?: QueueCreateNestedManyWithoutWhatsappsInput
    company: CompanyCreateNestedOneWithoutWhatsappsInput
    prompt?: PromptCreateNestedOneWithoutWhatsappInput
    User?: UserCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingCreateNestedManyWithoutWhatsappInput
    Contact?: ContactCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappUncheckedCreateWithoutWhatsappQueuesInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    promptId?: number | null
    tickets?: TicketUncheckedCreateNestedManyWithoutWhatsappInput
    queues?: QueueUncheckedCreateNestedManyWithoutWhatsappsInput
    User?: UserUncheckedCreateNestedManyWithoutWhatsappInput
    TicketTracking?: TicketTrackingUncheckedCreateNestedManyWithoutWhatsappInput
    Contact?: ContactUncheckedCreateNestedManyWithoutWhatsappInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutWhatsappInput
    BaileysChats?: BaileysChatsUncheckedCreateNestedManyWithoutWhatsappInput
    Baileys?: BaileysUncheckedCreateNestedManyWithoutWhatsappInput
  }

  export type WhatsappCreateOrConnectWithoutWhatsappQueuesInput = {
    where: WhatsappWhereUniqueInput
    create: XOR<WhatsappCreateWithoutWhatsappQueuesInput, WhatsappUncheckedCreateWithoutWhatsappQueuesInput>
  }

  export type QueueCreateWithoutWhatsappQueueInput = {
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    promptId?: number | null
    company: CompanyCreateNestedOneWithoutQueueInput
    whatsapps?: WhatsappCreateNestedManyWithoutQueuesInput
    users?: UserCreateNestedManyWithoutQueuesInput
    options?: QueueOptionCreateNestedManyWithoutQueueInput
    queueIntegrations?: QueueIntegrationsCreateNestedOneWithoutQueueInput
    prompt?: PromptCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueCreateNestedManyWithoutQueueInput
    Ticket?: TicketCreateNestedManyWithoutQueueInput
    Message?: MessageCreateNestedManyWithoutQueueInput
    Company?: CompanyCreateNestedManyWithoutQueuesInput
  }

  export type QueueUncheckedCreateWithoutWhatsappQueueInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
    whatsapps?: WhatsappUncheckedCreateNestedManyWithoutQueuesInput
    users?: UserUncheckedCreateNestedManyWithoutQueuesInput
    options?: QueueOptionUncheckedCreateNestedManyWithoutQueueInput
    prompt?: PromptUncheckedCreateNestedManyWithoutQueueInput
    UserQueue?: UserQueueUncheckedCreateNestedManyWithoutQueueInput
    Ticket?: TicketUncheckedCreateNestedManyWithoutQueueInput
    Message?: MessageUncheckedCreateNestedManyWithoutQueueInput
    Company?: CompanyUncheckedCreateNestedManyWithoutQueuesInput
  }

  export type QueueCreateOrConnectWithoutWhatsappQueueInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutWhatsappQueueInput, QueueUncheckedCreateWithoutWhatsappQueueInput>
  }

  export type WhatsappUpsertWithoutWhatsappQueuesInput = {
    update: XOR<WhatsappUpdateWithoutWhatsappQueuesInput, WhatsappUncheckedUpdateWithoutWhatsappQueuesInput>
    create: XOR<WhatsappCreateWithoutWhatsappQueuesInput, WhatsappUncheckedCreateWithoutWhatsappQueuesInput>
    where?: WhatsappWhereInput
  }

  export type WhatsappUpdateToOneWithWhereWithoutWhatsappQueuesInput = {
    where?: WhatsappWhereInput
    data: XOR<WhatsappUpdateWithoutWhatsappQueuesInput, WhatsappUncheckedUpdateWithoutWhatsappQueuesInput>
  }

  export type WhatsappUpdateWithoutWhatsappQueuesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutWhatsappQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type QueueUpsertWithoutWhatsappQueueInput = {
    update: XOR<QueueUpdateWithoutWhatsappQueueInput, QueueUncheckedUpdateWithoutWhatsappQueueInput>
    create: XOR<QueueCreateWithoutWhatsappQueueInput, QueueUncheckedCreateWithoutWhatsappQueueInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutWhatsappQueueInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutWhatsappQueueInput, QueueUncheckedUpdateWithoutWhatsappQueueInput>
  }

  export type QueueUpdateWithoutWhatsappQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutWhatsappQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type CampaignShippingCreateManyCampaignInput = {
    id?: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    contactId: number
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignShippingUpdateWithoutCampaignInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactListItemUpdateOneRequiredWithoutCampaignShippingNestedInput
  }

  export type CampaignShippingUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    contactId?: IntFieldUpdateOperationsInput | number
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignShippingUncheckedUpdateManyWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    contactId?: IntFieldUpdateOperationsInput | number
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserCreateManyChatInput = {
    id?: number
    userId: number
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateManyChatInput = {
    id?: number
    senderId: number
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUserUpdateWithoutChatInput = {
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatUsersNestedInput
  }

  export type ChatUserUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserUncheckedUpdateManyWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutChatInput = {
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutChatMessageNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyCompanyInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCompanyInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId?: number | null
    avatarUrl?: string | null
  }

  export type UserRatingCreateManyCompanyInput = {
    id?: number
    ticketId: number
    userId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappCreateManyCompanyInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId?: number | null
  }

  export type MessageCreateManyCompanyInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    queueId?: number | null
  }

  export type ContactCreateManyCompanyInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappId?: number | null
  }

  export type SettingCreateManyCompanyInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManyCompanyInput = {
    id?: number
    name: string
    color: string
    kanban: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyCompanyInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type TicketTrackingCreateManyCompanyInput = {
    id?: number
    ticketId: number
    whatsappId?: number | null
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type SubscriptionCreateManyCompanyInput = {
    id?: number
    isActive: boolean
    userPriceCents?: number | null
    whatsPriceCents?: number | null
    lastInvoiceUrl?: string | null
    lastPlanChange?: Date | string | null
    expiresAt?: Date | string | null
    providerSubscriptionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuickMessageCreateManyCompanyInput = {
    id?: number
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueueIntegrationsCreateManyCompanyInput = {
    id?: number
    type: string
    name: string
    projectName: string
    jsonContent?: string | null
    language?: string | null
    urlN8N?: string | null
    typebotSlug?: string | null
    typebotExpires?: number | null
    typebotKeywordFinish?: string | null
    typebotUnknownMessage?: string | null
    typebotDelayMessage?: number | null
    typebotKeywordRestart?: string | null
    typebotRestartMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptCreateManyCompanyInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    queueId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FilesCreateManyCompanyInput = {
    id?: number
    name: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactListItemCreateManyCompanyInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactListId: number
  }

  export type ContactListCreateManyCompanyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyCompanyInput = {
    id?: number
    uuid?: string
    title?: string
    ownerId: number
    lastMessage?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignSettingCreateManyCompanyInput = {
    id?: number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyCompanyInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactListId?: number | null
    whatsappId?: number | null
    fileListId: number
  }

  export type AnnouncementCreateManyCompanyInput = {
    id?: number
    priority: number
    title: string
    text: string
    mediaPath?: string | null
    mediaName?: string | null
    status: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueueCreateManyCompanyInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQueue: number
    integrationId?: number | null
    promptId?: number | null
  }

  export type RatingCreateManyCompanyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateWithoutCompanyInput = {
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutSchedulesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutScheduleNestedInput
    user?: UserUpdateOneRequiredWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRatingUpdateWithoutCompanyInput = {
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutUserRatingNestedInput
    user?: UserUpdateOneRequiredWithoutUserRatingNestedInput
  }

  export type UserRatingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
  }

  export type QueueUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
  }

  export type QueueUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhatsappUpdateWithoutCompanyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MessageUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsg?: MessageUpdateOneWithoutMessageNestedInput
    ticket?: TicketUpdateOneWithoutMessagesNestedInput
    contact?: ContactUpdateOneWithoutMessageNestedInput
    queue?: QueueUpdateOneWithoutMessageNestedInput
    Message?: MessageUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    Message?: MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContactUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsapp?: WhatsappUpdateOneWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingUpdateWithoutCompanyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTags?: TicketTagUpdateManyWithoutTagNestedInput
    tickets?: TicketUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTagNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutCompanyInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketTrackingUpdateWithoutCompanyInput = {
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicketTrackingNestedInput
    whatsapp?: WhatsappUpdateOneWithoutTicketTrackingNestedInput
    user?: UserUpdateOneWithoutTicketTrackingNestedInput
  }

  export type TicketTrackingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutCompanyInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    whatsPriceCents?: NullableIntFieldUpdateOperationsInput | number | null
    lastInvoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastPlanChange?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickMessageUpdateWithoutCompanyInput = {
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuickMessagesNestedInput
  }

  export type QuickMessageUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickMessageUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueIntegrationsUpdateWithoutCompanyInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUpdateManyWithoutQueueIntegrationNestedInput
    Queue?: QueueUpdateManyWithoutQueueIntegrationsNestedInput
  }

  export type QueueIntegrationsUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueIntegrationNestedInput
    Queue?: QueueUncheckedUpdateManyWithoutQueueIntegrationsNestedInput
  }

  export type QueueIntegrationsUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    jsonContent?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    urlN8N?: NullableStringFieldUpdateOperationsInput | string | null
    typebotSlug?: NullableStringFieldUpdateOperationsInput | string | null
    typebotExpires?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    typebotUnknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    typebotDelayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    typebotKeywordRestart?: NullableStringFieldUpdateOperationsInput | string | null
    typebotRestartMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneWithoutPromptNestedInput
    Whatsapp?: WhatsappUpdateManyWithoutPromptNestedInput
    Ticket?: TicketUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Whatsapp?: WhatsappUncheckedUpdateManyWithoutPromptNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: FilesOptionsUpdateManyWithoutFileNestedInput
    Campaign?: CampaignUpdateManyWithoutFileListNestedInput
  }

  export type FilesUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: FilesOptionsUncheckedUpdateManyWithoutFileNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutFileListNestedInput
  }

  export type FilesUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactListItemUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactList?: ContactListUpdateOneRequiredWithoutItemsNestedInput
    CampaignShipping?: CampaignShippingUpdateManyWithoutContactNestedInput
  }

  export type ContactListItemUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactListId?: IntFieldUpdateOperationsInput | number
    CampaignShipping?: CampaignShippingUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactListItemUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactListId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactListUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContactListItemUpdateManyWithoutContactListNestedInput
    Campaign?: CampaignUpdateManyWithoutContactListNestedInput
  }

  export type ContactListUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContactListItemUncheckedUpdateManyWithoutContactListNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutContactListNestedInput
  }

  export type ContactListUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutCompanyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutChatNestedInput
    users?: ChatUserUpdateManyWithoutChatNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: ChatUserUncheckedUpdateManyWithoutChatNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ownerId?: IntFieldUpdateOperationsInput | number
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignSettingUpdateWithoutCompanyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignSettingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignSettingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactList?: ContactListUpdateOneWithoutCampaignNestedInput
    whatsapp?: WhatsappUpdateOneWithoutCampaignNestedInput
    fileList?: FilesUpdateOneRequiredWithoutCampaignNestedInput
    shipping?: CampaignShippingUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
    shipping?: CampaignShippingUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
  }

  export type AnnouncementUpdateWithoutCompanyInput = {
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RatingUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyContactInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type ContactCustomFieldCreateManyContactInput = {
    id?: number
    name: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyContactInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    ticketId: number
    userId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketNoteCreateManyContactInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    ticketId: number
  }

  export type MessageCreateManyContactInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    companyId: number
    queueId?: number | null
  }

  export type TicketUpdateWithoutContactInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ContactCustomFieldUpdateWithoutContactInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCustomFieldUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCustomFieldUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutContactInput = {
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutScheduleNestedInput
    user?: UserUpdateOneRequiredWithoutScheduleNestedInput
    company?: CompanyUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    ticketId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUpdateWithoutContactInput = {
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketNoteNestedInput
    ticket?: TicketUpdateOneRequiredWithoutTicketNoteNestedInput
  }

  export type TicketNoteUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketNoteUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type MessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsg?: MessageUpdateOneWithoutMessageNestedInput
    ticket?: TicketUpdateOneWithoutMessagesNestedInput
    company?: CompanyUpdateOneRequiredWithoutMessagesNestedInput
    queue?: QueueUpdateOneWithoutMessageNestedInput
    Message?: MessageUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    Message?: MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContactListItemCreateManyContactListInput = {
    id?: number
    name: string
    number: string
    email?: string
    isWhatsappValid?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type CampaignCreateManyContactListInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    whatsappId?: number | null
    fileListId: number
  }

  export type ContactListItemUpdateWithoutContactListInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactListItemsNestedInput
    CampaignShipping?: CampaignShippingUpdateManyWithoutContactNestedInput
  }

  export type ContactListItemUncheckedUpdateWithoutContactListInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    CampaignShipping?: CampaignShippingUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactListItemUncheckedUpdateManyWithoutContactListInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    isWhatsappValid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignUpdateWithoutContactListInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCampaignsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutCampaignNestedInput
    fileList?: FilesUpdateOneRequiredWithoutCampaignNestedInput
    shipping?: CampaignShippingUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutContactListInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
    shipping?: CampaignShippingUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutContactListInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignShippingCreateManyContactInput = {
    id?: number
    jobId: string
    number: string
    message: string
    confirmationMessage: string
    confirmation: boolean
    campaignId: number
    confirmationRequestedAt?: Date | string | null
    confirmedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignShippingUpdateWithoutContactInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutShippingNestedInput
  }

  export type CampaignShippingUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: IntFieldUpdateOperationsInput | number
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignShippingUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    confirmationMessage?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: IntFieldUpdateOperationsInput | number
    confirmationRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesOptionsCreateManyFileInput = {
    id?: number
    name: string
    path: string
    mediaType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyFileListInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    whatsappId?: number | null
  }

  export type FilesOptionsUpdateWithoutFileInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesOptionsUncheckedUpdateWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilesOptionsUncheckedUpdateManyWithoutFileInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mediaType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutFileListInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCampaignsNestedInput
    contactList?: ContactListUpdateOneWithoutCampaignNestedInput
    whatsapp?: WhatsappUpdateOneWithoutCampaignNestedInput
    shipping?: CampaignShippingUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutFileListInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    shipping?: CampaignShippingUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutFileListInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type System_LogsCreateManyActionLogInput = {
    id?: number
    level: string
    message: string
    createdAt?: Date | string
  }

  export type System_LogsUpdateWithoutActionLogInput = {
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type System_LogsUncheckedUpdateWithoutActionLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type System_LogsUncheckedUpdateManyWithoutActionLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyQuotedMsgInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketId?: number | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
  }

  export type MessageUpdateWithoutQuotedMsgInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneWithoutMessagesNestedInput
    contact?: ContactUpdateOneWithoutMessageNestedInput
    company?: CompanyUpdateOneRequiredWithoutMessagesNestedInput
    queue?: QueueUpdateOneWithoutMessageNestedInput
    Message?: MessageUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateWithoutQuotedMsgInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    Message?: MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutQuotedMsgInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyCreateManyPlanInput = {
    id?: number
    name: string
    phone: string
    email: string
    status: boolean
    dueDate: Date | string
    recurrence: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateWithoutPlanInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    queues?: QueueUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    queues?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappCreateManyPromptInput = {
    id?: number
    name?: string | null
    session?: string | null
    qrcode?: string | null
    status?: string | null
    battery?: string | null
    plugged?: boolean | null
    retries?: number | null
    greetingMessage?: string
    farewellMessage?: string
    complationMessage?: string
    outOfHoursMessage?: string
    ratingMessage?: string
    provider?: string
    isDefault?: boolean | null
    token?: string | null
    transferQueueId?: number | null
    timeToTransfer?: number | null
    maxUseBotQueues?: number | null
    timeUseBotQueues?: string | null
    sendIdQueue?: number | null
    timeSendQueue?: number | null
    integrationId?: number | null
    expiresTicket?: number | null
    expiresInactiveMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type TicketCreateManyPromptInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type WhatsappUpdateWithoutPromptInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutPromptInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    queues?: QueueUncheckedUpdateManyWithoutWhatsappsNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateManyWithoutPromptInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketUpdateWithoutPromptInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutPromptInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutPromptInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QueueOptionCreateManyQueueInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptCreateManyQueueInput = {
    id?: number
    name: string
    prompt: string
    apiKey: string
    maxMessages?: number
    maxTokens?: number
    temperature?: number
    promptTokens?: number
    completionTokens?: number
    totalTokens?: number
    voice: string
    voiceKey?: string | null
    voiceRegion?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQueueCreateManyQueueInput = {
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappQueueCreateManyQueueInput = {
    whatsappId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyQueueInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type MessageCreateManyQueueInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    ticketId?: number | null
    contactId?: number | null
    companyId: number
  }

  export type WhatsappUpdateWithoutQueuesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutWhatsappNestedInput
    whatsappQueues?: WhatsappQueueUpdateManyWithoutWhatsappNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatsappsNestedInput
    prompt?: PromptUpdateOneWithoutWhatsappNestedInput
    User?: UserUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateWithoutQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    tickets?: TicketUncheckedUpdateManyWithoutWhatsappNestedInput
    whatsappQueues?: WhatsappQueueUncheckedUpdateManyWithoutWhatsappNestedInput
    User?: UserUncheckedUpdateManyWithoutWhatsappNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutWhatsappNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutWhatsappNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutWhatsappNestedInput
    BaileysChats?: BaileysChatsUncheckedUpdateManyWithoutWhatsappNestedInput
    Baileys?: BaileysUncheckedUpdateManyWithoutWhatsappNestedInput
  }

  export type WhatsappUncheckedUpdateManyWithoutQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    session?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    battery?: NullableStringFieldUpdateOperationsInput | string | null
    plugged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    retries?: NullableIntFieldUpdateOperationsInput | number | null
    greetingMessage?: StringFieldUpdateOperationsInput | string
    farewellMessage?: StringFieldUpdateOperationsInput | string
    complationMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    ratingMessage?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isDefault?: NullableBoolFieldUpdateOperationsInput | boolean | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    transferQueueId?: NullableIntFieldUpdateOperationsInput | number | null
    timeToTransfer?: NullableIntFieldUpdateOperationsInput | number | null
    maxUseBotQueues?: NullableIntFieldUpdateOperationsInput | number | null
    timeUseBotQueues?: NullableStringFieldUpdateOperationsInput | string | null
    sendIdQueue?: NullableIntFieldUpdateOperationsInput | number | null
    timeSendQueue?: NullableIntFieldUpdateOperationsInput | number | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    expiresTicket?: NullableIntFieldUpdateOperationsInput | number | null
    expiresInactiveMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutQueuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    whatsapp?: WhatsappUpdateOneWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QueueOptionUpdateWithoutQueueInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: QueueOptionUpdateOneWithoutQueueOptionNestedInput
    Ticket?: TicketUpdateManyWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionUncheckedUpdateWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionUncheckedUpdateManyWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUpdateWithoutQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPromptsNestedInput
    Whatsapp?: WhatsappUpdateManyWithoutPromptNestedInput
    Ticket?: TicketUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Whatsapp?: WhatsappUncheckedUpdateManyWithoutPromptNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateManyWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    maxMessages?: IntFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    temperature?: IntFieldUpdateOperationsInput | number
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    voice?: StringFieldUpdateOperationsInput | string
    voiceKey?: NullableStringFieldUpdateOperationsInput | string | null
    voiceRegion?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQueueUpdateWithoutQueueInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserQueueNestedInput
  }

  export type UserQueueUncheckedUpdateWithoutQueueInput = {
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQueueUncheckedUpdateManyWithoutQueueInput = {
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappQueueUpdateWithoutQueueInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsapp?: WhatsappUpdateOneRequiredWithoutWhatsappQueuesNestedInput
  }

  export type WhatsappQueueUncheckedUpdateWithoutQueueInput = {
    whatsappId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappQueueUncheckedUpdateManyWithoutQueueInput = {
    whatsappId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutQueueInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsg?: MessageUpdateOneWithoutMessageNestedInput
    ticket?: TicketUpdateOneWithoutMessagesNestedInput
    contact?: ContactUpdateOneWithoutMessageNestedInput
    company?: CompanyUpdateOneRequiredWithoutMessagesNestedInput
    Message?: MessageUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    Message?: MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyUpdateWithoutQueuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutCompanyNestedInput
    plan?: PlanUpdateOneRequiredWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUpdateManyWithoutCompanyNestedInput
    messages?: MessageUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
    settings?: SettingUpdateManyWithoutCompanyNestedInput
    tags?: TagUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUpdateManyWithoutCompanyNestedInput
    filess?: FilesUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUpdateManyWithoutCompanyNestedInput
    chats?: ChatUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUpdateManyWithoutCompanyNestedInput
    queue?: QueueUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    userRatings?: UserRatingUncheckedUpdateManyWithoutCompanyNestedInput
    whatsapps?: WhatsappUncheckedUpdateManyWithoutCompanyNestedInput
    messages?: MessageUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    settings?: SettingUncheckedUpdateManyWithoutCompanyNestedInput
    tags?: TagUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    ticketTrackings?: TicketTrackingUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutCompanyNestedInput
    queueIntegrationss?: QueueIntegrationsUncheckedUpdateManyWithoutCompanyNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutCompanyNestedInput
    filess?: FilesUncheckedUpdateManyWithoutCompanyNestedInput
    contactListItems?: ContactListItemUncheckedUpdateManyWithoutCompanyNestedInput
    contactLists?: ContactListUncheckedUpdateManyWithoutCompanyNestedInput
    chats?: ChatUncheckedUpdateManyWithoutCompanyNestedInput
    campaignSettings?: CampaignSettingUncheckedUpdateManyWithoutCompanyNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutCompanyNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCompanyNestedInput
    queue?: QueueUncheckedUpdateManyWithoutCompanyNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutQueuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recurrence?: StringFieldUpdateOperationsInput | string
    planId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyQueueIntegrationInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type QueueCreateManyQueueIntegrationsInput = {
    id?: number
    name: string
    color: string
    greetingMessage?: string
    outOfHoursMessage?: string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    orderQueue: number
    promptId?: number | null
  }

  export type TicketUpdateWithoutQueueIntegrationInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutQueueIntegrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutQueueIntegrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QueueUpdateWithoutQueueIntegrationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutQueueIntegrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateManyWithoutQueueIntegrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketCreateManyQueueOptionInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type QueueOptionCreateManyParentInput = {
    id?: number
    title: string
    message?: string | null
    option?: string | null
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateWithoutQueueOptionInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutQueueOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutQueueOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QueueOptionUpdateWithoutParentInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutOptionsNestedInput
    Ticket?: TicketUpdateManyWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ticket?: TicketUncheckedUpdateManyWithoutQueueOptionNestedInput
    QueueOption?: QueueOptionUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QueueOptionUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    option?: NullableStringFieldUpdateOperationsInput | string | null
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagCreateManyTagInput = {
    ticketId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicketTagsNestedInput
  }

  export type TicketTagUncheckedUpdateWithoutTagInput = {
    ticketId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyWithoutTagInput = {
    ticketId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutTagsInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageCreateManyTicketInput = {
    id?: string
    remoteJid: string
    participant: string
    dataJson: string
    ack?: number
    read?: boolean
    fromMe?: boolean
    body: string
    mediaUrl?: string | null
    mediaType: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotedMsgId?: string | null
    contactId?: number | null
    companyId: number
    queueId?: number | null
  }

  export type TicketTagCreateManyTicketInput = {
    tagId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingCreateManyTicketInput = {
    id?: number
    companyId: number
    userId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTrackingCreateManyTicketInput = {
    id?: number
    companyId: number
    whatsappId?: number | null
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketNoteCreateManyTicketInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
  }

  export type ScheduleCreateManyTicketInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    userId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Action_LogsCreateManyTicketInput = {
    id?: number
    userId: number
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsg?: MessageUpdateOneWithoutMessageNestedInput
    contact?: ContactUpdateOneWithoutMessageNestedInput
    company?: CompanyUpdateOneRequiredWithoutMessagesNestedInput
    queue?: QueueUpdateOneWithoutMessageNestedInput
    Message?: MessageUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
    Message?: MessageUncheckedUpdateManyWithoutQuotedMsgNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    participant?: StringFieldUpdateOperationsInput | string
    dataJson?: StringFieldUpdateOperationsInput | string
    ack?: IntFieldUpdateOperationsInput | number
    read?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    body?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotedMsgId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    companyId?: IntFieldUpdateOperationsInput | number
    queueId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TicketTagUpdateWithoutTicketInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutTicketTagsNestedInput
  }

  export type TicketTagUncheckedUpdateWithoutTicketInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTagUncheckedUpdateManyWithoutTicketInput = {
    tagId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutTicketsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTagsNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    kanban?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUpdateWithoutTicketInput = {
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUserRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutUserRatingNestedInput
  }

  export type UserRatingUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUpdateWithoutTicketInput = {
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTicketTrackingsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutTicketTrackingNestedInput
    user?: UserUpdateOneWithoutTicketTrackingNestedInput
  }

  export type TicketTrackingUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUpdateWithoutTicketInput = {
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketNoteNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketNoteNestedInput
  }

  export type TicketNoteUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketNoteUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleUpdateWithoutTicketInput = {
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutSchedulesNestedInput
    user?: UserUpdateOneRequiredWithoutScheduleNestedInput
    company?: CompanyUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Action_LogsUpdateWithoutTicketInput = {
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAction_LogsNestedInput
    System_Logs?: System_LogsUpdateManyWithoutActionLogNestedInput
  }

  export type Action_LogsUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    System_Logs?: System_LogsUncheckedUpdateManyWithoutActionLogNestedInput
  }

  export type Action_LogsUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyUserInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId: number
    whatsappId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type QuickMessageCreateManyUserInput = {
    id?: number
    shortcode: string
    message: string
    mediaName?: string | null
    mediaPath?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUserCreateManyUserInput = {
    id?: number
    chatId: number
    unreads: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQueueCreateManyUserInput = {
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRatingCreateManyUserInput = {
    id?: number
    ticketId: number
    companyId: number
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketTrackingCreateManyUserInput = {
    id?: number
    ticketId: number
    companyId: number
    whatsappId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type TicketNoteCreateManyUserInput = {
    id?: number
    note: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId: number
    ticketId: number
  }

  export type ScheduleCreateManyUserInput = {
    id?: number
    body: string
    sendAt: Date | string
    sentAt?: Date | string | null
    status: string
    mediaPath: string
    mediaName: string
    contactId: number
    ticketId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: number
    chatId: number
    message?: string
    mediaPath?: string | null
    mediaName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyOwnerInput = {
    id?: number
    uuid?: string
    title?: string
    lastMessage?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Action_LogsCreateManyUserInput = {
    id?: number
    ticketId?: number | null
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type TicketUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    whatsapp?: WhatsappUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: IntFieldUpdateOperationsInput | number
    whatsappId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QueueUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    whatsapps?: WhatsappUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    whatsapps?: WhatsappUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuickMessageUpdateWithoutUserInput = {
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutQuickMessagesNestedInput
  }

  export type QuickMessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuickMessageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortcode?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserUpdateWithoutUserInput = {
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ChatUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    unreads?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQueueUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutUserQueueNestedInput
  }

  export type UserQueueUncheckedUpdateWithoutUserInput = {
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQueueUncheckedUpdateManyWithoutUserInput = {
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUpdateWithoutUserInput = {
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutUserRatingNestedInput
    company?: CompanyUpdateOneRequiredWithoutUserRatingsNestedInput
  }

  export type UserRatingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRatingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUpdateWithoutUserInput = {
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicketTrackingNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketTrackingsNestedInput
    whatsapp?: WhatsappUpdateOneWithoutTicketTrackingNestedInput
  }

  export type TicketTrackingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    whatsappId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUpdateWithoutUserInput = {
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutTicketNoteNestedInput
    ticket?: TicketUpdateOneRequiredWithoutTicketNoteNestedInput
  }

  export type TicketNoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type TicketNoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleUpdateWithoutUserInput = {
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutSchedulesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutScheduleNestedInput
    company?: CompanyUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    contactId?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutOwnerInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutChatsNestedInput
    users?: ChatUserUpdateManyWithoutChatNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: ChatUserUncheckedUpdateManyWithoutChatNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessage?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Action_LogsUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneWithoutAction_LogsNestedInput
    System_Logs?: System_LogsUpdateManyWithoutActionLogNestedInput
  }

  export type Action_LogsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    System_Logs?: System_LogsUncheckedUpdateManyWithoutActionLogNestedInput
  }

  export type Action_LogsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyWhatsappInput = {
    id?: number
    status?: string
    unreadMessages?: number | null
    lastMessage?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    contactId: number
    queueId: number
    chatbot?: boolean | null
    queueOptionId: number
    companyId: number
    uuid?: string
    useIntegration?: boolean | null
    integrationId?: number | null
    typebotSessionId?: string | null
    typebotStatus?: boolean
    promptId?: number | null
    fromMe?: boolean | null
    amountUsedBotQueues?: number
    isBot?: boolean | null
  }

  export type WhatsappQueueCreateManyWhatsappInput = {
    queueId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyWhatsappInput = {
    id?: number
    name: string
    email: string
    passwordHash: string
    tokenVersion?: number
    profile?: string
    super: boolean
    online: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    avatarUrl?: string | null
  }

  export type TicketTrackingCreateManyWhatsappInput = {
    id?: number
    ticketId: number
    companyId: number
    userId?: number | null
    rated: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt: Date | string
    queuedAt: Date | string
    finishedAt?: Date | string | null
    closedAt?: Date | string | null
    ratingAt: Date | string
    chatbotAt: Date | string
  }

  export type ContactCreateManyWhatsappInput = {
    id?: number
    name: string
    number: string
    email?: string
    profilePicUrl?: string
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
  }

  export type CampaignCreateManyWhatsappInput = {
    id?: number
    name: string
    message1?: string
    message2?: string
    message3?: string
    message4?: string
    message5?: string
    confirmationMessage1?: string
    confirmationMessage2?: string
    confirmationMessage3?: string
    confirmationMessage4?: string
    confirmationMessage5?: string
    status?: string
    confirmation: boolean
    mediaPath: string
    mediaName: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: number
    contactListId?: number | null
    fileListId: number
  }

  export type BaileysChatsCreateManyWhatsappInput = {
    id?: number
    jid: string
    conversationTimestamp: number
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BaileysCreateManyWhatsappInput = {
    id?: number
    contacts?: string | null
    chats?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateWithoutWhatsappInput = {
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    queue?: QueueUpdateOneRequiredWithoutTicketNestedInput
    queueOption?: QueueOptionUpdateOneRequiredWithoutTicketNestedInput
    messages?: MessageUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUpdateManyWithoutTicketNestedInput
    tags?: TagUpdateManyWithoutTicketsNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketsNestedInput
    queueIntegration?: QueueIntegrationsUpdateOneWithoutTicketNestedInput
    prompt?: PromptUpdateOneWithoutTicketNestedInput
    UserRating?: UserRatingUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messages?: MessageUncheckedUpdateManyWithoutTicketNestedInput
    ticketTags?: TicketTagUncheckedUpdateManyWithoutTicketNestedInput
    tags?: TagUncheckedUpdateManyWithoutTicketsNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutTicketNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutTicketNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutTicketNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    unreadMessages?: NullableIntFieldUpdateOperationsInput | number | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    contactId?: IntFieldUpdateOperationsInput | number
    queueId?: IntFieldUpdateOperationsInput | number
    chatbot?: NullableBoolFieldUpdateOperationsInput | boolean | null
    queueOptionId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    useIntegration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    typebotStatus?: BoolFieldUpdateOperationsInput | boolean
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    fromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    amountUsedBotQueues?: IntFieldUpdateOperationsInput | number
    isBot?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type QueueUpdateWithoutWhatsappsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQueue?: IntFieldUpdateOperationsInput | number
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    company?: CompanyUpdateOneRequiredWithoutQueueNestedInput
    users?: UserUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUpdateManyWithoutQueueNestedInput
    queueIntegrations?: QueueIntegrationsUpdateOneWithoutQueueNestedInput
    prompt?: PromptUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUpdateManyWithoutQueueNestedInput
    Message?: MessageUpdateManyWithoutQueueNestedInput
    Company?: CompanyUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateWithoutWhatsappsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutQueuesNestedInput
    options?: QueueOptionUncheckedUpdateManyWithoutQueueNestedInput
    prompt?: PromptUncheckedUpdateManyWithoutQueueNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutQueueNestedInput
    WhatsappQueue?: WhatsappQueueUncheckedUpdateManyWithoutQueueNestedInput
    Ticket?: TicketUncheckedUpdateManyWithoutQueueNestedInput
    Message?: MessageUncheckedUpdateManyWithoutQueueNestedInput
    Company?: CompanyUncheckedUpdateManyWithoutQueuesNestedInput
  }

  export type QueueUncheckedUpdateManyWithoutWhatsappsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    greetingMessage?: StringFieldUpdateOperationsInput | string
    outOfHoursMessage?: StringFieldUpdateOperationsInput | string
    schedules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    orderQueue?: IntFieldUpdateOperationsInput | number
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
    promptId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhatsappQueueUpdateWithoutWhatsappInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutWhatsappQueueNestedInput
  }

  export type WhatsappQueueUncheckedUpdateWithoutWhatsappInput = {
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappQueueUncheckedUpdateManyWithoutWhatsappInput = {
    queueId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutWhatsappInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    queues?: QueueUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUpdateManyWithoutSenderNestedInput
    Chat?: ChatUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    queues?: QueueUncheckedUpdateManyWithoutUsersNestedInput
    quickMessages?: QuickMessageUncheckedUpdateManyWithoutUserNestedInput
    ChatUsers?: ChatUserUncheckedUpdateManyWithoutUserNestedInput
    UserQueue?: UserQueueUncheckedUpdateManyWithoutUserNestedInput
    UserRating?: UserRatingUncheckedUpdateManyWithoutUserNestedInput
    TicketTracking?: TicketTrackingUncheckedUpdateManyWithoutUserNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutUserNestedInput
    Schedule?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ChatMessage?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    Chat?: ChatUncheckedUpdateManyWithoutOwnerNestedInput
    Action_Logs?: Action_LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    tokenVersion?: IntFieldUpdateOperationsInput | number
    profile?: StringFieldUpdateOperationsInput | string
    super?: BoolFieldUpdateOperationsInput | boolean
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketTrackingUpdateWithoutWhatsappInput = {
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutTicketTrackingNestedInput
    company?: CompanyUpdateOneRequiredWithoutTicketTrackingsNestedInput
    user?: UserUpdateOneWithoutTicketTrackingNestedInput
  }

  export type TicketTrackingUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTrackingUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    rated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ratingAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatbotAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutWhatsappInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutContactsNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUpdateManyWithoutContactNestedInput
    Message?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    extraInfo?: ContactCustomFieldUncheckedUpdateManyWithoutContactNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutContactNestedInput
    TicketNote?: TicketNoteUncheckedUpdateManyWithoutContactNestedInput
    Message?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    profilePicUrl?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type CampaignUpdateWithoutWhatsappInput = {
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutCampaignsNestedInput
    contactList?: ContactListUpdateOneWithoutCampaignNestedInput
    fileList?: FilesUpdateOneRequiredWithoutCampaignNestedInput
    shipping?: CampaignShippingUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
    shipping?: CampaignShippingUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    message1?: StringFieldUpdateOperationsInput | string
    message2?: StringFieldUpdateOperationsInput | string
    message3?: StringFieldUpdateOperationsInput | string
    message4?: StringFieldUpdateOperationsInput | string
    message5?: StringFieldUpdateOperationsInput | string
    confirmationMessage1?: StringFieldUpdateOperationsInput | string
    confirmationMessage2?: StringFieldUpdateOperationsInput | string
    confirmationMessage3?: StringFieldUpdateOperationsInput | string
    confirmationMessage4?: StringFieldUpdateOperationsInput | string
    confirmationMessage5?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    confirmation?: BoolFieldUpdateOperationsInput | boolean
    mediaPath?: StringFieldUpdateOperationsInput | string
    mediaName?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: IntFieldUpdateOperationsInput | number
    contactListId?: NullableIntFieldUpdateOperationsInput | number | null
    fileListId?: IntFieldUpdateOperationsInput | number
  }

  export type BaileysChatsUpdateWithoutWhatsappInput = {
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysChatsUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysChatsUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    jid?: StringFieldUpdateOperationsInput | string
    conversationTimestamp?: IntFieldUpdateOperationsInput | number
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysUpdateWithoutWhatsappInput = {
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysUncheckedUpdateWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BaileysUncheckedUpdateManyWithoutWhatsappInput = {
    id?: IntFieldUpdateOperationsInput | number
    contacts?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactListCountOutputTypeDefaultArgs instead
     */
    export type ContactListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactListItemCountOutputTypeDefaultArgs instead
     */
    export type ContactListItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactListItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilesCountOutputTypeDefaultArgs instead
     */
    export type FilesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Action_LogsCountOutputTypeDefaultArgs instead
     */
    export type Action_LogsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Action_LogsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptCountOutputTypeDefaultArgs instead
     */
    export type PromptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueCountOutputTypeDefaultArgs instead
     */
    export type QueueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueIntegrationsCountOutputTypeDefaultArgs instead
     */
    export type QueueIntegrationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueIntegrationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueOptionCountOutputTypeDefaultArgs instead
     */
    export type QueueOptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueOptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCountOutputTypeDefaultArgs instead
     */
    export type TicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhatsappCountOutputTypeDefaultArgs instead
     */
    export type WhatsappCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhatsappCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnouncementDefaultArgs instead
     */
    export type AnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnouncementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BaileysDefaultArgs instead
     */
    export type BaileysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BaileysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BaileysChatsDefaultArgs instead
     */
    export type BaileysChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BaileysChatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignSettingDefaultArgs instead
     */
    export type CampaignSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignShippingDefaultArgs instead
     */
    export type CampaignShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignShippingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatMessageDefaultArgs instead
     */
    export type ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatUserDefaultArgs instead
     */
    export type ChatUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCustomFieldDefaultArgs instead
     */
    export type ContactCustomFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCustomFieldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactListDefaultArgs instead
     */
    export type ContactListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactListItemDefaultArgs instead
     */
    export type ContactListItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactListItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilesDefaultArgs instead
     */
    export type FilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FilesOptionsDefaultArgs instead
     */
    export type FilesOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FilesOptionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpDefaultArgs instead
     */
    export type HelpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use System_LogsDefaultArgs instead
     */
    export type System_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = System_LogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Action_LogsDefaultArgs instead
     */
    export type Action_LogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Action_LogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptDefaultArgs instead
     */
    export type PromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueDefaultArgs instead
     */
    export type QueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueIntegrationsDefaultArgs instead
     */
    export type QueueIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueIntegrationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueOptionDefaultArgs instead
     */
    export type QueueOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuickMessageDefaultArgs instead
     */
    export type QuickMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuickMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RatingDefaultArgs instead
     */
    export type RatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleDefaultArgs instead
     */
    export type ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketNoteDefaultArgs instead
     */
    export type TicketNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketTagDefaultArgs instead
     */
    export type TicketTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketTrackingDefaultArgs instead
     */
    export type TicketTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserQueueDefaultArgs instead
     */
    export type UserQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRatingDefaultArgs instead
     */
    export type UserRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhatsappDefaultArgs instead
     */
    export type WhatsappArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhatsappDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhatsappQueueDefaultArgs instead
     */
    export type WhatsappQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhatsappQueueDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}